<!DOCTYPE html>
<html lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>Paper Requirement</title>
    <link rel="stylesheet" type="text/css" href="./css/default.css" />
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  </head>
  <body>
    <div id="header">
      <div id="logo">
        <a href="./">Max S. New</a>
      </div>
      <div id="navigation">
        <a href="./docs/maxsnew-cv.pdf">CV</a>
        <a href="./publications.html">Publications</a>
        <a href="./blog.html">Blog</a>
        <a href="./misc.html">Misc</a>
      </div>
    </div>
    <div id="content">
      <h1 id="secure-compilation-via-mediated-universal-embedding">Secure Compilation via Mediated Universal Embedding</h1>
<p><a href="fabcc-paper.pdf">Fully Abstract Compilation via Universal Embedding, ICFP 2016</a></p>
<p>Max S. New, William J. Bowman, and Amal Ahmed</p>
<p>Acceptance rate: 31%</p>
<p>Advisor’s statement:</p>
<p>This is a paper about secure compilation, which ensures that when compiled components are linked with target code (attackers), the latter can make no more observations about the compiled component than a source-level attacker can about the original component. Building secure compilers is hard because target languages have features that source languages don’t, which allows target attackers to make observations that source attackers can’t. <em>Proving</em> that a compiler is secure is even harder because it requires showing that any target code you can link with will behave like some source code — i.e., that it’s “back-translatable” into the source.</p>
<p>This paper studies the closure-conversion pass of a compiler, using static interfaces at the target-level to ensure that compiled code is only linked with well-behaved target attackers. The more significant contribution is a new proof technique, called “back-translation by universal embedding”, that works for non-terminating languages, target features that are untypeable in the source, and control effects even when the source has no control effects.</p>
<p>The universal embedding was entirely Max’s idea and is a major step forward in building verified secure compilers for <em>realistic</em> languages.</p>
<p>Max formalized the back-translation and the multi-language, which allows the compiler’s source and target language to interoperate, and he did almost all of the proofs. He also did the bulk of the writing. Specifically, sections 4 and 5, which contain the heart of the contribution, as well as the excellent discussion in section 7 are entirely his, as are large chunks of the Intro and Related Work sections. (William helped with proofs in an earlier version of the paper but the back-translation technique that we were using then did not pan out. William also wrote a first draft of the intro for the earlier version, but Max has since made significant revisions to the intro.)</p>
    </div>
  </body>
</html>
