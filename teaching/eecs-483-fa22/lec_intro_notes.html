<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 1: Introduction</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="rust.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 1:</span> Introduction</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.What_is_a_.Compiler_%29" class="tocviewlink" data-pltdoc="x">What <span class="emph">is</span> a Compiler?</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Course_.Outline%29" class="tocviewlink" data-pltdoc="x">Course Outline</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.What_will_we_do_%29" class="tocviewlink" data-pltdoc="x">What will <span class="emph">we do</span>?</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.What_will_you_learn_%29" class="tocviewlink" data-pltdoc="x">What will <span class="emph">you learn</span>?</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 1:</span> Introduction</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.What_is_a_.Compiler_%29" class="tocsubseclink" data-pltdoc="x">What <span class="emph">is</span> a Compiler?</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.A_.Bit_of_.History%29" class="tocsubseclink" data-pltdoc="x">A Bit of History</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.What_does_a_.Compiler_look_like_%29" class="tocsubseclink" data-pltdoc="x">What does a Compiler <span class="emph">look like</span>?</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.What_is_.E.E.C.S_483_%29" class="tocsubseclink" data-pltdoc="x">What is EECS 483?</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Course_.Outline%29" class="tocsubseclink" data-pltdoc="x">Course Outline</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.What_will_we_do_%29" class="tocsubseclink" data-pltdoc="x">What will <span class="emph">we do</span>?</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.What_will_you_learn_%29" class="tocsubseclink" data-pltdoc="x">What will <span class="emph">you learn</span>?</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.4</span></div><h2><a name="(part._)"></a><span class="LectureNum">Lecture 1:</span> Introduction</h2><h3>1<tt>&nbsp;</tt><a name="(part._.What_is_a_.Compiler_)"></a>What <span class="emph">is</span> a Compiler?</h3><p>We all have an intuitive understanding of what a program is: it&rsquo;s some
<span class="emph">thing</span> that instructs a computer to do something.  But the language
in which we tend to write our programs is nothing like the language that
the computer understands natively.  Something must <span class="emph">translate</span> the
source code of our programs into a form the computer understands.</p><p>Conceptually, there are two ways this could happen: first, we could
write a program that takes the source code of our program and
<span class="emph">interprets</span> it on the fly, translating as it goes.  This is
roughly how languages like Python and JavaScript run programs in
it. <span class="NoteBox"><span class="NoteContent">In practice JavaScript uses a combination of an interpreter
and "just-in-time" compilation for performance reasons</span></span> The downside
to this approach is that we must keep both the source code and the
interpreter around whenever we want to run the program. In addition,
the interpreter adds a level of runtime overhead because it adds a
layer of indirection: the interpreter has to figure out what the code
means in order to run.</p><p>Second, we could write a program that <span class="emph">translates</span> the source code of our
program into a form the machine can understand directly.  Once this translation
step has completed, we no longer need the source or the translator; we can
just execute the resulting program directly.</p><p>In other words, a compiler is simply a function that maps an <span class="emph">input</span> string to an <span class="emph">output</span> string,</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">compiler : String -&gt; String</code></pre></div></div></p><p>where we typically consider the <span class="emph">input</span> and <span class="emph">output</span> strings to be
programs in two different languages:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">compiler : SourceProgram -&gt; TargetProgram</code></pre></div></div></p><p>For example, here are some well-known <span class="emph">compilers</span></p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">gcc, clang   : C/C++      -&gt; Binary          /* a.out, .exe */
emcc         : C/C++      -&gt; WebAssembly
rustc        : Rust       -&gt; Binary
javac        : Java       -&gt; JvmByteCode     /* .class */
scalac       : Scala      -&gt; JvmByteCode
gwt          : Java       -&gt; JavaScript      /* .js */
v8           : JavaScript -&gt; Binary
nasm         : X64        -&gt; Binary
pdftex       : LaTeX      -&gt; PDF
pandoc       : Markdown   -&gt; PDF or Html or Doc</code></pre></div></div></p><p>Key Requirements on output program:</p><ol><li><p>Has the <span class="emph">same meaning</span> (&ldquo;semantics&rdquo;) as input,</p></li><li><p>Is <span class="emph">executable</span> in relevant <span class="emph">context</span> (VM, microprocessor, web browser).</p></li></ol><h4>1.1<tt>&nbsp;</tt><a name="(part._.A_.Bit_of_.History)"></a>A Bit of History</h4><p>Compilers were invented to <a href="http://worrydream.com/dbx/">avoid writing machine code by hand</a>.</p><p><img src="binary-soap-fortran.png" alt="" width="796" height="500"/></p><p>Richard Hamming &ndash; The Art of Doing Science and Engineering, p25:</p><p><blockquote> In the beginning we programmed in
absolute binary...  Finally, a Symbolic Assembly Program was devised
&ndash; after more years than you are apt to believe during which most
programmers continued their heroic absolute binary programming. At the
time [the assembler] first appeared I would guess about 1% of the
older programmers were interested in it...a real programmer would not
stoop to wasting machine capacity to do the assembly.</blockquote></p><p>John A.N. Lee, Dept of Computer Science, Virginia Polytechnical Institute:</p><p><blockquote>One of von Neumann&rsquo;s students at Princeton recalled that
graduate students were being used to hand assemble programs
into binary for their early machine. This student took time
out to build an assembler, but when von Neumann found out
about it he was very angry, saying that it was a waste of
a valuable scientific computing instrument to use it to do
clerical work.</blockquote></p><p>The term compiler was coined by
<a href="https://en.wikipedia.org/wiki/Grace_Hopper">Grace
Hopper</a>, who also wrote the first "compiler" (more accurately the
first linker in today&rsquo;s terminology). She was an early advocate for
and designer of high-level programming languages.</p><p><img src="grace-hopper.jpg" alt=""/></p><h4>1.2<tt>&nbsp;</tt><a name="(part._.What_does_a_.Compiler_look_like_)"></a>What does a Compiler <span class="emph">look like</span>?</h4><p><a href="http://publicdomainarchive.com/wp-content/uploads/2014/02/public-domain-images-eiffel-tower-construction-1800s-0007.jpg"><img src="eiffel-tower.jpg" alt="" class="titleimage"/></a></p><p>An input source program is converted to an executable binary in many stages:</p><ul><li><p><span style="font-weight: bold">Parsed</span> into a data structure called an <span style="font-weight: bold">Abstract Syntax Tree</span></p></li><li><p><span style="font-weight: bold">Checked</span> to make sure code is well-formed (and well-typed)</p></li><li><p><span style="font-weight: bold">Simplified</span> into some convenient <span style="font-weight: bold">Intermediate Representation</span></p></li><li><p><span style="font-weight: bold">Optimized</span> into (equivalent) but faster program</p></li><li><p><span style="font-weight: bold">Generated</span> into assembly <code>x64</code></p></li><li><p><span style="font-weight: bold">Linked</span> against a run-time (usually written in C)</p></li></ul><h4>1.3<tt>&nbsp;</tt><a name="(part._.What_is_.E.E.C.S_483_)"></a>What is EECS 483?</h4><ul><li><p>A <span class="emph">bridge</span> between two worlds</p><p><ul><li><p><span class="emph">High-level Languages</span> (<span style="font-weight: bold">EECS 281</span>)</p></li><li><p><span class="emph">Machine Code</span>         (<span style="font-weight: bold">EECS 370</span>)</p></li></ul><p>A sequel to both those classes.</p></p></li><li><p>How to write <span style="font-weight: bold">a compiler</span> for a small-ish language to x64:</p><ol><li><p>Parsing</p></li><li><p>Checking &amp; Validation</p></li><li><p>Simplification &amp; Normalizing</p></li><li><p>Optimization</p></li><li><p>Code Generation</p></li></ol></li><li><p>But also, how to write <span style="font-weight: bold">complex programs</span></p><ul><li><p>Design</p></li><li><p>Implement</p></li><li><p>Test</p></li><li><p><span style="font-weight: bold">Iterate</span></p></li></ul></li></ul><h3>2<tt>&nbsp;</tt><a name="(part._.Course_.Outline)"></a>Course Outline</h3><h3>3<tt>&nbsp;</tt><a name="(part._.What_will_we_do_)"></a>What will <span class="emph">we do</span>?</h3><p>Writing a compiler directly from a high-level language to x64 isn&rsquo;t easy to build in a single step.
So we will write <span class="emph">many</span> compilers, each adding new features:</p><ul><li><p>Numbers and increment/decrement</p></li><li><p>Local Variables</p></li><li><p>Nested Binary Operations</p></li><li><p>Booleans, Branches and Dynamic Types</p></li><li><p>Functions</p></li><li><p>Tuples and Structures</p></li><li><p>Lambdas and closures</p></li><li><p>Garbage Collection</p></li></ul><p><p>At this point you will have a language akin to Javascript without objects, but there are many more extensions
we can try:
</p><ul><li><p>Optimizations</p></li><li><p>Static type enforcement</p></li><li><p>Mutable variables</p></li><li><p>Objects</p></li><li><p>...</p></li></ul></p><p>We may not get to implementing all of these, but we will see where they each fit into the
architecture of a compiler.</p><h3>4<tt>&nbsp;</tt><a name="(part._.What_will_you_learn_)"></a>What will <span class="emph">you learn</span>?</h3><ul><li><p><span style="font-weight: bold">Core principles of compiler construction</span></p><ul><li><p>Managing Stacks &amp; Heap</p></li><li><p>Managing Registers/Calling Conventions</p></li><li><p>Intermediate forms</p></li><li><p>Optimization</p></li><li><p>Lexing and Parsing</p></li><li><p>Type Checking/Validation</p></li></ul></li><li><p><span style="font-weight: bold">Programming languages</span></p><ul><li><p><code>Rust</code>        to write the compiler</p></li><li><p><code>Unsafe Rust</code> to write the &ldquo;run-time&rdquo;</p></li><li><p><code>X64</code>         compilation target</p></li></ul></li><li><p><span style="font-weight: bold"><span class="emph">More importantly</span> how to write a large program</span></p><ul><li><p>How to use types for design</p></li><li><p>How to add new features / refactor</p></li><li><p>How to test &amp; validate</p></li></ul></li></ul><a name="(part._(gentag._33._lectureintro))"></a><p class="FootnoteBlock"></p></div></div><div id="contextindicator">&nbsp;</div></body></html>