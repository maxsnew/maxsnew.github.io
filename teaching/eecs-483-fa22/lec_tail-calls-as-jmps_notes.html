<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 8: Local Function Definitions and Tail Calls</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="rust.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 8:</span> Local Function Definitions and Tail Calls</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._tail-calls._.Growing_the_language__local_function_definitions__tail_calls%29" class="tocviewlink" data-pltdoc="x">Growing the language:<span class="mywbr"> &nbsp;</span> local function definitions, tail calls</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 8:</span> Local Function Definitions and Tail Calls</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._tail-calls._.Growing_the_language__local_function_definitions__tail_calls%29" class="tocsubseclink" data-pltdoc="x">Growing the language:<span class="mywbr"> &nbsp;</span> local function definitions, tail calls</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._tail-calls._.Concrete_syntax%29" class="tocsubseclink" data-pltdoc="x">Concrete syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._tail-calls._.Abstract_syntax_for_.Calls%29" class="tocsubseclink" data-pltdoc="x">Abstract syntax for Calls</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._fundefs._tail-calls._.Defining_our_own_functions%29" class="tocsubseclink" data-pltdoc="x">Defining our own functions</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part._tail-calls._.Semantics%29" class="tocsubseclink" data-pltdoc="x">Semantics</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#%28part._tail-calls._.Code_.Generation__.Function_.Definitions%29" class="tocsubseclink" data-pltdoc="x">Code Generation:<span class="mywbr"> &nbsp;</span> Function Definitions</a></td></tr><tr><td><span class="tocsublinknumber">1.6<tt>&nbsp;</tt></span><a href="#%28part._tail-calls._.Code_.Generation__.Tail_.Calls%29" class="tocsubseclink" data-pltdoc="x">Code Generation:<span class="mywbr"> &nbsp;</span> Tail Calls</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.6</span></div><h2><a name="(part._)"></a><span class="LectureNum">Lecture 8:</span> Local Function Definitions and Tail Calls</h2><p>So far we&rsquo;ve developed a nice suite of basic features for our
language:</p><ul><li><p>The ability to perform arithmetic operations</p></li><li><p>The ability to perform logical operations and make decisions based on them</p></li><li><p>The ability to interact with the operating system in limited ways (errors, printing, random numbers etc)</p></li></ul><p>However, the computational power of our language is fundamentally
limited: all of our programs use finite space and terminate in finite
time. Over the next few weeks we will substantially increase the power
of our snake languages by lifting both of these restrictions. We will
use <span class="emph">functions</span> and <span class="emph">looping</span> constructs to lift our
restriction of terminating programs and we will use the <span class="emph">stack</span>
and the <span class="emph">heap</span> to give us access to unbounded memory. Today we
will start this journey towards Turing-completeness by adding function
definitions and a restricted form of calls that can be compiled
directly to jumps. This increases the power of our language to that of
finite-state automata<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._12._lecturetail-calls-as-jmps%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">Note that technically to implement
finite-state automata we would need somethink like a
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">readBool()</code></span> or <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">readInt()</code></span> built-in that
reads the next character from the input string so that we could take
arbitrarily large strings as input.</span></span>.</p><h3>1<tt>&nbsp;</tt><a name="(part._tail-calls._.Growing_the_language__local_function_definitions__tail_calls)"></a>Growing the language: local function definitions, tail calls</h3><p><p>Reminder: Every time we enhance our source language, we need to consider several things:
</p><ol><li><p>Its impact on the <span class="emph">concrete syntax</span> of the language</p></li><li><p>Examples using the new enhancements, so we build intuition of them</p></li><li><p>Its impact on the <span class="emph">abstract syntax</span> and <span class="emph">semantics</span> of the language</p></li><li><p>Any new or changed <span class="emph">transformations</span> needed to process the new
forms</p></li><li><p>Executable <span class="emph">tests</span> to confirm the enhancement works as intended</p></li></ol></p><h4>1.1<tt>&nbsp;</tt><a name="(part._tail-calls._.Concrete_syntax)"></a>Concrete syntax</h4><p> We&rsquo;ll start with concrete syntax. A
function call is a new form of expression that starts with a function
name and takes zero or more comma-separated expressions as arguments.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._tail-calls._(bnf-prod._(funcalls._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28funcalls._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class="bnf-lit">)</span>
<a name="(elem._tail-calls._(bnf-prod._(funcalls._exprs)))"></a><span class="bnf-rule">&#8249;exprs&#8250;</span><span class="bnf-meta">:</span> <span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28funcalls._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span><span class="bnf-meta"> | </span><span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28funcalls._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28funcalls._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span></p></blockquote><p>To account for function definitions we have a choice to make. The
easiest to implement would be to simply have a sequence of top level
function definitions followed by one main body expression. But we will
do something more flexible: we will allow for <span class="emph">local</span> function
definitions <span class="emph">inside</span> arbitrary expressions.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._tail-calls._(bnf-prod._(fundefs._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28fundefs._decls%29%29%29" data-pltdoc="x">&#8249;decls&#8250;</a></span> <span class="bnf-lit">in</span> <span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28fundefs._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
<a name="(elem._tail-calls._(bnf-prod._(fundefs._decls)))"></a><span class="bnf-rule">&#8249;decls&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28fundefs._decl%29%29%29" data-pltdoc="x">&#8249;decl&#8250;</a></span>
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28fundefs._decls%29%29%29" data-pltdoc="x">&#8249;decls&#8250;</a></span> <span class="bnf-lit">and</span> <span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28fundefs._decl%29%29%29" data-pltdoc="x">&#8249;decl&#8250;</a></span>
<a name="(elem._tail-calls._(bnf-prod._(fundefs._decl)))"></a><span class="bnf-rule">&#8249;decl&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class="bnf-lit">def</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28fundefs._ids%29%29%29" data-pltdoc="x">&#8249;ids&#8250;</a></span> <span class="bnf-lit">)</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28fundefs._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">def</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class="bnf-lit">)</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28fundefs._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
<a name="(elem._tail-calls._(bnf-prod._(fundefs._ids)))"></a><span class="bnf-rule">&#8249;ids&#8250;</span><span class="bnf-meta">:</span> 
        <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span>
        <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._tail-calls._%28bnf-prod._%28fundefs._ids%29%29%29" data-pltdoc="x">&#8249;ids&#8250;</a></span></p></blockquote><p>Allowing for local function definitions like this is very convenient
for programming. For instance, we can use recursive functions in lieu
of looping constructs, like in this factorial example:
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def fac(x):
  def loop(x, acc):
    if x == 0:
      acc
    else:
      loop(x - 1, acc * x)
  in
  loop(x, 1)
in
fac(10)</code></span></p><p>If we only had top-level function definitions, the programmer would
have to lift loops (and nested loops) like this to the top-level,
polluting the global namespace and making the program less clear
overall.</p><p>Our new form also allows for <span class="emph">mutually recursive</span> function
definitions. For instance, here is how we might implement a function
that checks if the input is even or odd without having access to a
modulo or div operator:</p><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def even(x):
  def evn(n):
    if n == 0:
      true
    else:
      odd(n - 1)
  and
  def odd(n):
    if n == 0:
      false
    else:
      even(n - 1)
  in
  if x &gt;= 0:
    evn(x)
  else:
    evn(-1 * x)
in
even(24)</code></span></p><p>For our examples, let&rsquo;s design <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max</code></span>, which takes two numeric arguments and
returns the larger of the two.</p><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def max(x,y):
  if x &gt;= y: x else: y
end

max(17,31)</code></span></p><p>should evaluate to <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">31</code></span>.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._tail-calls._.Abstract_syntax_for_.Calls)"></a>Abstract syntax for Calls</h4><p>First, let&rsquo;s cover the calling side of the language.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What should the semantics of <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f(e1, e2, ..., en)</code></span> be?  How should
we represent this in our <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Exp</code></span> data definition?  What knock-on effects
does it have for the transformation passes of our compiler?</p></blockquote><p>The first thing we might notice is that attempting to call an unknown function
should be prohibited &#8212;<wbr></wbr> this is analogous to the scope-checking we already do
for variable names, and should be done at the same time.  Indeed, we can
generalize our scope-checking to a suite of <span class="emph">well-formedness</span> checks, that
assert that the program we&rsquo;re compiling is &ldquo;put together right&rdquo;.  (These
static checks include static type-checking, which we are not yet doing, and
in fact many popular languages these days are focusing heavily on improving the
precision and efficiency of their well-formedness checking as a way to improve
programmer efficiency and correctness.)  Checking for undefined functions
implies that we need something like an environment of known functions.  We
don&rsquo;t yet know what that environment should contain, but at a minimum it needs
to contain the names of the functions we support.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What other programmer mistakes should we try to catch with well-formedness
checking?  What new mistakes are possible with function calls?</p></blockquote><p>What should happen if a programmer tries to call <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(1)</code></span> or
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(1, 2, 3)</code></span>?  Certainly nothing good can happen at runtime if we
allowed this to occur.  Fortunately, we can track enough information to prevent
this at well-formedness time, too.  Our function environment should keep track
of known function names and their arities.  Then we can check every function
call expression and see whether it contains the correct number of actual
arguments.</p><p><p>We need more examples:
</p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Source</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Output</p></td></tr><tr><td><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(1)</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Compile Error: expected 2 arguments, got 1</code></span></p></td></tr><tr><td><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(1, 2, 3)</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Compile Error: expected 2 arguments, got 3</code></span></p></td></tr><tr><td><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">unknown(1, 2)</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Compile Error: unknown function 'unknown'</code></span></p></td></tr></table></p><p>To represent call expressions in our AST, we just need to keep track of the
function name, the argument list, and any tag information:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">
enum Exp&lt;Ann&gt; {
  ...
  Call(String, Vec&lt;Exp&lt;Ann&gt;&gt;, Ann),
}</code></pre></div></div></p><p>We need to consider how our expression evaluates, which in turn means
considering how it should normalize into sequential form.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What are the design choices here?</p></blockquote><p>Since <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Exp::Call</code></span> expressions are compound, containing multiple subexpressions,
they probably should normalize similar to how we normalize <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Prim2</code></span>
expressions: the arguments should all be made immediate.</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">pub enum SeqExp&lt;Ann&gt; {
  ...
  Call(String, Vec&lt;ImmExp&gt;, Ann),
}</code></pre></div></div></p><p>We have at least two possible designs here, for how to normalize these
expressions: we can choose a left-to-right or right-to-left evaluation order
for the arguments.  For consistency with infix operators, we&rsquo;ll choose a
left-to-right ordering.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What tiny example program, using only the expressions we have so
far, would demonstrate the difference between these two orderings?</p></blockquote><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Extend sequentialization to handle <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Exp::Call</code></span>.</p></blockquote><h4>1.3<tt>&nbsp;</tt><a name="(part._fundefs._tail-calls._.Defining_our_own_functions)"></a>Defining our own functions</h4><p>Now that our programs include function definitions and a main
expression, our AST representation now grows to match:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">pub struct FunDecl&lt;E, Ann&gt; {
    pub name: String,
    pub parameters: Vec&lt;String&gt;,
    pub body: E,
    pub ann: Ann,
}

pub struct Prog&lt;E, Ann&gt; {
    pub funs: Vec&lt;FunDecl&lt;E, Ann&gt;&gt;,
    pub main: E,
    pub ann: Ann,
}</code></pre></div></div></p><p>Here we are abstract over annotations, as well as the type of
expressions. This allows us to instantiate to <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Prog&lt;Exp&gt;</code></span> or
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Prog&lt;SeqExp&gt;</code></span> to encode whether or not the expressions are in
sequential form.</p><h4>1.4<tt>&nbsp;</tt><a name="(part._tail-calls._.Semantics)"></a>Semantics</h4><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What new semantic concerns do we have with providing our own
definitions?</p></blockquote><p>As soon as we introduce a new form of definition into our language, we need to
consider scoping concerns.  One possibility is to declare that earlier
definitions can be used by later ones, but not vice versa.  This possibility is
relatively easy to implement, but restrictive: it prevents us from having
mutually-recursive functions.  Fortunately, because all our functions are
statically defined, supporting mutual recursion is not all that difficult; the
only complication is getting the well-formedness checks to work out correctly.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Do so.</p></blockquote><p>Additionally, the bodies of function definitions need to consider scope as
well.</p><p><div class="sourceCodeWrapper"><span data-label="Diamondback" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def sum3(x, y, z):
  a + b + c
end

x + 5</code></pre></div></div></p><p>This program refers to names that are not in scope: <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">a</code></span>, <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">b</code></span> and <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">c</code></span>
are not in scope within <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">sum3</code></span>, and <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> is not in scope outside of it.</p><p><div class="sourceCodeWrapper"><span data-label="Diamondback" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def f(x): x end

def f(y): y end

f(3)</code></pre></div></div></p><p>Repeatedly defining functions of the same name should be problematic: which
function is intended to be called?</p><p><div class="sourceCodeWrapper"><span data-label="Diamondback" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def f(x, x): x end

f(3, 4)</code></pre></div></div></p><p>Having multiple arguments of the same name should be problematic: which
argument should be returned here?</p><h4>1.5<tt>&nbsp;</tt><a name="(part._tail-calls._.Code_.Generation__.Function_.Definitions)"></a>Code Generation: Function Definitions</h4><p>How should we compile function definitions? Well, each function
definition needs to have associated code that we can jump to to
execute the function, so each function will need to produce a label
followed by the code corresponding to the body. But we also need to
consider the <span class="emph">arguments</span> of the function. The simplest thing to
do is to extend our current treatment of local variables in <code>let</code>
bindings: arguments will just be new local variables stored on the
stack. So in an expression like</p><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let a = 1 in
def f(b,c,d):
  let x = 2 in
  def g(y,z):
    ...
  in
  ...
in
...</code></span></p><p>When we compile this code we need to determine where all of the local
variables go. For a first attempt we can extend our treatment of
let-bound variables: <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">a</code></span> goes in the first free stack slot
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">[RSP - 8 * 1]</code></span> and <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">b</code></span> goes in the next <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">[RSP - 8 * 2]</code></span>,
and <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">c,d,x,y,z</code></span> go in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">3,4,5,6,7</code></span> respectively.</p><p>Other than that, the code generation for function definitions is
straightforward: each function definition</p><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def f(x,y,z):
  e
end</code></span></p><p>can be simply compiled to a label followed by the code for the body</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">f:
    ;; code for e</code></pre></div></div></p><p>We just need to make sure the labels we use for the function names are
all unique, using similar techniques for other labels we generate.</p><h4>1.6<tt>&nbsp;</tt><a name="(part._tail-calls._.Code_.Generation__.Tail_.Calls)"></a>Code Generation: Tail Calls</h4><p>Now what about the function <span class="emph">call</span>? Well it turns out that in all
of the example programs so far, the function calls have had a very
special property: they are always the <span class="emph">last</span> thing that the
caller does: for instance in our implementation of <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">even</code></span>,
the main expression ends by calling <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">even(24)</code></span>, each
branch of <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">even</code></span> ends by calling <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">evn</code></span> and the
functions <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">evn</code></span> and <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">odd</code></span> in each branch
either return a value or end with a call to the other. We refer to
these calls as <span class="emph">tail calls</span> because they are at the "tail end" of
the expression. These are very nicely behaved from an implementation
perspective: if the last thing an expression does is call another
function, then that expression should return whatever value that
function does, meaning that the function being called (the callee)
should use the <span class="emph">same</span> return address that the caller has on the
stack. Furthermore, all of the local variables of the caller on the
stack are no longer needed, so we can safely overwrite all of them
with the arguments to the callee and the callee can use the space for
its stack frame. For this reason, tail calls can be implemented
extremely efficiently as simply <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jmp</code></span> instructions, after the
caller places the arguments where the callee expects them to be on the
stack.</p><p>On the other hand, not every function call in a program is a tail
call, for instance consider this implementation of factorial:</p><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def factorial(x):
  if x == 0:
    1
  else:
    x * factorial(x - 1)
in
factorial(6)</code></span></p><p>In this function, the call <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">factorial(6)</code></span> is a tail call,
because it&rsquo;s the last thing the main expression does, but the
recursive call <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">factorial(x - 1)</code></span> is <span class="emph">not</span> a tail
call, because we have to do something else after it returns: multiply
the result by <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span>. Non-tail calls will be compiled
differently, so we will cover them later. For today, we will only
support tail calls.</p><p>Regardless of <span class="emph">how</span> tail and non-tail calls are implemented,
since they are compiled differently, we need to be able to precisely
determine which calls are tail or not. To do this we generalize from
just the calls to define when any sub-expression is in <span class="emph">tail
position</span>:</p><ol><li><p>The expression of our program is in tail position.</p></li><li><p>The body of a function is in tail position.</p></li><li><p>If a let-binding is in tail position, then (a) its body is in tail position,
but (b) the bindings themselves are not.</p></li><li><p>If a conditional is in tail position, then (a) its branches are in tail
position, but (b) the condition itself is not.</p></li><li><p>The operands to an operator are never in tail position.</p></li></ol><p>Visually, green expressions are always in tail position, yellow expressions are
potentially in tail position, and red expressions are never in tail position:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">pub struct Prog&lt;E, Ann&gt; {
    pub funs: Vec&lt;FunDecl&lt;E, Ann&gt;&gt;,
    pub ~hl:3:s~main: E~hl:3:e~
    pub ann: Ann,
}
pub struct FunDecl&lt;E, Ann&gt; {
    pub name: String,
    pub parameters: Vec&lt;String&gt;,
    pub ~hl:3:s~body: E~hl:3:e~,
    pub ann: Ann,
}
pub enum SeqExp&lt;Ann&gt; {
    Imm(~hl:2:s~ImmExp~hl:2:e~, Ann),
    Prim1(Prim1, ~hl:2:s~ImmExp~hl:2:e~, Ann),
    Prim2(Prim2, ~hl:2:s~ImmExp~hl:2:e~, ~hl:2:s~ImmExp~hl:2:e~, Ann),
    Let {
        var: String,
        ~hl:2:s~bound_exp: Box&lt;SeqExp&lt;Ann&gt;&gt;~hl:2:e~,
        ~hl:1:s~body: Box&lt;SeqExp&lt;Ann&gt;&gt;~hl:1:e~,
        ann: Ann,
    },
    If {
        ~hl:2:s~cond: ImmExp~hl:2:e~,
        ~hl:1:s~thn: Box&lt;SeqExp&lt;Ann&gt;&gt;~hl:1:e~,
        ~hl:1:s~els: Box&lt;SeqExp&lt;Ann&gt;&gt;~hl:1:e~,
        ann: Ann,
    },
    ~hl:1:s~Call~hl:1:e~(String, ~hl:2:s~Vec&lt;ImmExp&gt;~hl:2:e~, Ann),
}</code></pre></div></div></p><p>We can codify this, if we so choose, as a kind of tagging operation:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">fn mark_tails&lt;Ann&gt;(e: &amp;SeqExp&lt;Ann&gt;, is_tail: bool) -&gt; SeqExp&lt;bool&gt; {
    match e {
        SeqExp::Imm(i, _) =&gt; SeqExp::Imm(i.clone(), is_tail),
        SeqExp::Prim1(op, i, _) =&gt; SeqExp::Prim1(*op, i.clone(), is_tail),
        ...
        SeqExp::Let {
            var,
            bound_exp,
            body,
            ..
        } =&gt; SeqExp::Let {
            var: var.clone(),
            bound_exp: Box::new(mark_tails(bound_exp, false)),
            body: Box::new(mark_tails(&amp;body, is_tail)),
            ann: is_tail,
        },
        SeqExp::If { cond, thn, els, .. } =&gt; SeqExp::If {
            cond: cond.clone(),
            thn: Box::new(mark_tails(thn, is_tail)),
            els: Box::new(mark_tails(els, is_tail)),
            ann: is_tail,
        },
    }
}</code></pre></div></div></p><p>In practice we probably don&rsquo;t need to, and instead can just carry along a
boolean flag through our <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">compile_with_env</code></span> function that keeps track of our
tail-position status:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">fn compile_with_env&lt;'exp&gt;(
    e: &amp;'exp SeqExp&lt;u32&gt;,
    .., // other arguments
    is_tail: bool) // true when the expression is in tail position
    -&gt; Vec&lt;Instr&gt; {
    match e {
      ...
      SeqExp::Let { var, bound_exp, body, ann } =&gt; {
        ...
        let bound_exp_is = compile_with_env(bound_exp, ..., false);
        ...
        let body_is = compile_with_env(body, ..., is_tail)
      }
      SeqExp::Call(fun, args, ann) =&gt; {
        if is_tail {
          // generate a tail call
        } else {
          // generate a non-tail call
        }
      }
      ...
    }
}</code></pre></div></div></p><p>Ok, now that we know for sure we have a function call in tail
position, how do we compile it? For a simple start, let&rsquo;s say we are
compiling the following expression:
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = 7
def f(a,b,c):
  if b:
    x * a
  else:
    c
in
let y = x * 2 in
let z = print(y) in
f(5, true, 13)</code></span></p><p>Following our scheme for storing local variables, <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x, y</code></span>
will be placed at <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">[RSP - 8 * 1], [RSP - 8 * 2]</code></span>. When we
call <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f(5,true,13)</code></span>, we want to transfer control to the
code where the body of <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span> is implemented, but with the
arguments <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">a,b,c</code></span> having the correct values. So when we
call <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span>, we need to remember that in the body of
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span>, we have access to 4 local variables;
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x,a,b,c</code></span>, which are placed in the first 4 stack slots.
So to compile the function call <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f(5,true,13)</code></span>, we simply
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov</code></span> the arguments to the appropriate place on the stack and then
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jmp</code></span> to <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov [RSP - 8 * 2], 10       ;; a = 5
mov [RSP - 8 * 3], 0x7FF... ;; b = true
mov [RSP - 8 * 4], 26       ;; c = 13
jmp f                       ;; tail call f</code></pre></div></div></p><p>Note here that <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">a</code></span> is at <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP - 8 * 2</code></span> because
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span> expects <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> to be at <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP - 8 * 1</code></span>.
This works for constants, but there is one tricky situation we should
be careful of more generally. Consider the following seemingly
innocuous change: change the call to <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f(5, true, y)</code></span>. Then
if we na\"ively try to compile it the same way something horribly
wrong happens:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov [RSP - 8 * 2], 10       ;; a = 5
mov [RSP - 8 * 3], 0x7FF... ;; b = true
mov RAX, [RSP - 8 * 2]      ;; load y
mov [RSP - 8 * 4], RAX      ;; c = y
jmp f                       ;; tail call f</code></pre></div></div></p><p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What went horribly wrong?</p></blockquote><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Try to fix it.</p></blockquote></p><p>Since a tail call re-uses the current stack frame in place, we
overwrote the value of <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">y</code></span> on the stack before we were
able to use it as an argument! The effect is that the call is
accidentally compiled as if it were <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f(5,true,5)</code></span>.</p><p>How can we avoid this happening? Well the easiest way is for our
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">sequentialize</code></span> function to <span class="emph">always</span> generate new
temporaries for the arguments, that way, whenever we load the
arguments for the function call, they will always be stored at an
address higher on the stack than the addresses that have been
overwritten before it. For instance, this function would instead be:</p><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = 7
def f(a,b,c):
  if b:
    x * a
  else:
    c
in
let y = x * 2 in
let z = print(y) in
let a = 5 in
let b = true in
let c = y in
f(a, b, c)</code></span></p><p>in which case the call would be compiled as
<div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RAX, [RSP - 8 * 4]      ;; load a
mov [RSP - 8 * 2], RAX       ;; a = a
mov RAX, [RSP - 8 * 5]      ;; load b
mov [RSP - 8 * 3], RAX       ;; b = b
mov RAX, [RSP - 8 * 6]      ;; load c
mov [RSP - 8 * 4], RAX       ;; c = c
jmp f                       ;; tail call f</code></pre></div></div></p><p>A little wasteful to be sure, but the good news is that clearly we can
never run into the problem from before: all of these locals are stored
at addresses that have not been overwritten when they are used. In
this case, the variable <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">a</code></span> will be overwritten when we
store the value for <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">c</code></span>, but at that point it is ok
because we no longer need its value.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>We could have avoided this problem by loading the arguments
in a different order (i.e., loading the third argument first). Can you come up with an example program where this is not possible?</p></blockquote><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Come up with an algorithm that minimizes the total number of
extra temporaries needed to perform a tail call.</p></blockquote><a name="(part._(gentag._11._lecturetail-calls-as-jmps))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._12._lecturetail-calls-as-jmps))"></a>1</span></span>Note that technically to implement
finite-state automata we would need somethink like a
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">readBool()</code></span> or <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">readInt()</code></span> built-in that
reads the next character from the input string so that we could take
arbitrarily large strings as input.</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>