<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 6: Runtime representations for multiple value types</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="rust.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 6:</span> Runtime representations for multiple value types</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._tagging._.Growing_the_language__adding_boolean_values%29" class="tocviewlink" data-pltdoc="x">Growing the language:<span class="mywbr"> &nbsp;</span> adding boolean values</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Representation_choices%29" class="tocviewlink" data-pltdoc="x">Representation choices</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Overflow_and_.Bogus_.Arguments%29" class="tocviewlink" data-pltdoc="x">Overflow and Bogus Arguments</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Testing%29" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 6:</span> Runtime representations for multiple value types</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._tagging._.Growing_the_language__adding_boolean_values%29" class="tocsubseclink" data-pltdoc="x">Growing the language:<span class="mywbr"> &nbsp;</span> adding boolean values</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._tagging._.Wait__what_about_static_typing_%29" class="tocsubseclink" data-pltdoc="x">Wait, what about static typing?</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._tagging._.The_new_concrete_syntax%29" class="tocsubseclink" data-pltdoc="x">The new concrete syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._tagging._.Examples%29" class="tocsubseclink" data-pltdoc="x">Examples</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part._tagging._.Enhancing_the_abstract_syntax%29" class="tocsubseclink" data-pltdoc="x">Enhancing the abstract syntax</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Representation_choices%29" class="tocsubseclink" data-pltdoc="x">Representation choices</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Attempt_1__.Why_limit_ourselves_to_64-bits_%29" class="tocsubseclink" data-pltdoc="x">Attempt 1:<span class="mywbr"> &nbsp;</span> Why limit ourselves to 64-<wbr></wbr>bits?</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Attempt_2__.We_don_t_need_64_bits_for_a_tag%29" class="tocsubseclink" data-pltdoc="x">Attempt 2:<span class="mywbr"> &nbsp;</span> We don&rsquo;t need 64 bits for a tag</a></td></tr><tr><td><span class="tocsublinknumber">2.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Booleans%29" class="tocsubseclink" data-pltdoc="x">Booleans</a></td></tr><tr><td><span class="tocsublinknumber">2.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Numbers%29" class="tocsubseclink" data-pltdoc="x">Numbers</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.Compiling_constants%29" class="tocsubseclink" data-pltdoc="x">Compiling constants</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#%28part._.Defining_arithmetic_over_our_representations%29" class="tocsubseclink" data-pltdoc="x">Defining arithmetic over our representations</a></td></tr><tr><td><span class="tocsublinknumber">2.5<tt>&nbsp;</tt></span><a href="#%28part._.Defining_logic_operations_over_our_representations%29" class="tocsubseclink" data-pltdoc="x">Defining logic operations over our representations</a></td></tr><tr><td><span class="tocsublinknumber">2.6<tt>&nbsp;</tt></span><a href="#%28part._.Defining_comparisons_over_our_representations%29" class="tocsubseclink" data-pltdoc="x">Defining comparisons over our representations</a></td></tr><tr><td><span class="tocsublinknumber">2.6.1<tt>&nbsp;</tt></span><a href="#%28part._.Using_cmp%29" class="tocsubseclink" data-pltdoc="x">Using <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span></a></td></tr><tr><td><span class="tocsublinknumber">2.6.2<tt>&nbsp;</tt></span><a href="#%28part._.Being__clever__%29" class="tocsubseclink" data-pltdoc="x">Being &ldquo;clever&rdquo;?</a></td></tr><tr><td><span class="tocsublinknumber">2.6.3<tt>&nbsp;</tt></span><a href="#%28part._.So_why_does_cmp_work_%29" class="tocsubseclink" data-pltdoc="x">So why does <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span> work?</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Overflow_and_.Bogus_.Arguments%29" class="tocsubseclink" data-pltdoc="x">Overflow and Bogus Arguments</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Testing%29" class="tocsubseclink" data-pltdoc="x">Testing</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.4</span></div><h2><a name="(part._)"></a><span class="LectureNum">Lecture 6:</span> Runtime representations for multiple value types</h2><p>We ought to be able to handle more kinds of values than just numbers. Let&rsquo;s try
to add at least one more type of value to our language.  Doing so will trigger
a large number of problems, which will all need to be resolved to make things
work again.</p><h3>1<tt>&nbsp;</tt><a name="(part._tagging._.Growing_the_language__adding_boolean_values)"></a>Growing the language: adding boolean values</h3><p><p>Reminder: Every time we enhance our source language, we need to consider several things:
</p><ol><li><p>Its impact on the <span class="emph">concrete syntax</span> of the language</p></li><li><p>Examples using the new enhancements, so we build intuition of them</p></li><li><p>Its impact on the <span class="emph">abstract syntax</span> and <span class="emph">semantics</span> of the language</p></li><li><p>Any new or changed <span class="emph">transformations</span> needed to process the new
forms</p></li><li><p>Executable <span class="emph">tests</span> to confirm the enhancement works as intended</p></li></ol></p><p>When we introduced conditionals and branching control-flow <a href="lec_anf_notes.html" data-pltdoc="x">last time</a>,
we were a bit dissatisfied with the semantics of &ldquo;branch if it&rsquo;s nonzero
or not&rdquo; &#8212;<wbr></wbr> that seemed like a hack justified only by the limitations of our
language.  Today, let&rsquo;s consider adding the simplest additional type of data to
our language: boolean values.  It&rsquo;s just two new values!  What will we need to
support them?</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What new primitive operations should we add to operate with
booleans?  What should happen if we give numeric arguments to boolean
operations?  Or vice versa?</p></blockquote><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>We currently represent numbers as themselves.  How can we represent
booleans?</p></blockquote><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>How can we prevent things from going wrong?</p></blockquote><p><p>The key challenge, from which all the other problems today will arise, is that
our current encoding of numbers is too big.  We&rsquo;ve assigned a numeric meaning
to every 64-bit pattern, and therefore <span class="emph">used them all up</span>: there are no
bit patterns left to represent boolean values.  Somehow, we need to carve out
space for our booleans.  As soon as we do that, though:
</p><ul><li><p>Not all operations should operate on all bit patterns, which means we
have to ensure that operations can <span class="emph">distinguish</span> valid operands from invalid
ones.</p></li><li><p>Not all patterns can be considered numbers, which means we have to <span class="emph">ensure</span>
that our compilation of numbers makes sense in this new extended setup.</p></li><li><p>It becomes apparent that <span class="emph">just</span> supporting booleans is shortsighted:
we&rsquo;d like to be able to broaden these techniques to other datatypes later on,
such as pointers, tuples, structures, closures, or others.</p></li></ul></p><p>A lot of work, for just two values!  But that work forms a blueprint to follow
when growing the language further.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._tagging._.Wait__what_about_static_typing_)"></a>Wait, what about static typing?</h4><p>Surely we can resolve some if not all of these problems by designing a
type-checker for our language?  After all, if we can determine statically that
the program never miuses an operation with the wrong type of operands, then we
don&rsquo;t need to distinguish those types of values at runtime?</p><p>Sadly, not quite: while some operations will be simplified if we do this, there
are still features we&rsquo;d like to have in our compiler, such as garbage
collection, that will inevitably need to treat some types of values differently
than others.  Without getting into the details now (we&rsquo;ll save that for later),
learning how to deal with distinguishing values now, while the language is
still small, will be good practice when the language gets more complicated soon.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._tagging._.The_new_concrete_syntax)"></a>The new concrete syntax</h4><p><p>Today&rsquo;s language changes themselves are syntactically quite simple: only two
new expression forms, and a bunch of new operators.  Notice that we have
operators that consume and return booleans, and also operators that consume
numbers and return booleans &ndash; language features interact.
</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._tagging._(bnf-prod._(booleans._prim1)))"></a><span class="bnf-rule">&#8249;prim1&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span><span class="bnf-meta"> | </span><span class="bnf-lit">!</span>
<a name="(elem._tagging._(bnf-prod._(booleans._prim2)))"></a><span class="bnf-rule">&#8249;prim2&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span><span class="bnf-meta"> | </span><span class="bnf-lit">&amp;&amp;</span><span class="bnf-meta"> | </span><span class="bnf-lit">||</span><span class="bnf-meta"> | </span><span class="bnf-lit">&lt;</span><span class="bnf-meta"> | </span><span class="bnf-lit">&lt;=</span><span class="bnf-meta"> | </span><span class="bnf-lit">&gt;</span><span class="bnf-meta"> | </span><span class="bnf-lit">&gt;=</span><span class="bnf-meta"> | </span><span class="bnf-lit">==</span><span class="bnf-meta"> | </span><span class="bnf-lit">!=</span>
<a name="(elem._tagging._(bnf-prod._(booleans._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span><span class="bnf-meta"> | </span><span class="bnf-lit">true</span><span class="bnf-meta"> | </span><span class="bnf-lit">false</span></p></blockquote></p><h4>1.3<tt>&nbsp;</tt><a name="(part._tagging._.Examples)"></a>Examples</h4><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Develop a suite of test examples for using booleans.  Be thorough,
and consider as many edge cases as possible.</p></blockquote><h4>1.4<tt>&nbsp;</tt><a name="(part._tagging._.Enhancing_the_abstract_syntax)"></a>Enhancing the abstract syntax</h4><p>The abstract syntax changes are similarly straightforward to the concrete ones.
<div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">enum Prim1 {
     ...
     Not
}

enum Prim2 {
     ...
     And,
     Or,
     Lt,
     Leq,
     Gt,
     Geq,
     Eq,
     Neq,
}

enum Exp&lt;Ann&gt; {
     ...
     Bool(bool)
}

enum ImmExp&lt;Ann&gt; {
     ...
     Bool(bool)
}</code></pre></div></div></p><p>Like numbers, we will consider <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Bool(_)</code></span> values to be immediates for the
purposes of sequential form: no further computation on them is needed.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Representation_choices)"></a>Representation choices</h3><p>If all of our bit-patterns so far are used for numbers, then when we choose
some patterns to reinterpret as booleans, we must have some way of
distinguishing boolean (or other) patterns from numeric ones.</p><p>A note about notation: since we will be discussing actual bit-level
representations today, it will be useful to use either binary or hexadecimal
notations for numbers, rather than more common decimal notation.  I.e.</p><p><p class="center"><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b00000000_0000....0000_00001010</code></span> = <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x000000000000000A</code></span> = <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">10</code></span></p></p><p>For clarity, if needed, we&rsquo;ll include underscores to separate the bytes in the
binary representation, and elide the middle bits if they&rsquo;re not interesting.
Further, if there are &ldquo;wildcard&rdquo; bits that we don&rsquo;t care about, we will mark
them as <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">w</code></span> in the binary representation.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._.Attempt_1__.Why_limit_ourselves_to_64-bits_)"></a>Attempt 1: Why limit ourselves to 64-bits?</h4><p>If all the patterns in a 64-bit word are used up...let&rsquo;s use more words.
Suppose we encode all our values as <span class="emph">two</span> words, where the first word is a
<span class="emph">tag word</span> describing what type of value comes next &#8212;<wbr></wbr> e.g. <code>0</code> for
number, <code>1</code> for boolean &#8212;<wbr></wbr> and the subsequent word contains the actual
value.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>List at least three consequences of this approach.</p></blockquote><p>On the one hand, this approach is certainly future-proof: we have room to
distinguish 9 quintillion distinct types of data in our programs!  But on the
other, consider how we would have to implement any of our operations.  Because
our values are now larger than our word-size, they won&rsquo;t fit into registers any
more, which in turn means that our invariant of &ldquo;the answer always goes in
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>&rdquo; won&rsquo;t work any longer.  Instead, we will need to always put our
answers on the stack, and then put the <span class="emph">address</span> of the first word of the
answer into <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>: i.e., the <span class="emph">actual</span> answer can be found in
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">[RAX]</code></span> and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">[RAX - 8]</code></span>.  This in turn means that every single
operation we want to perform will require at least two memory reads and writes
&#8212;<wbr></wbr> which is an exorbitant cost.</p><h4>2.2<tt>&nbsp;</tt><a name="(part._.Attempt_2__.We_don_t_need_64_bits_for_a_tag)"></a>Attempt 2: We don&rsquo;t need 64 bits for a tag</h4><p><p>If having 64 tag bits is overkill, let&rsquo;s try the minimum needed: could we get
away with a single tag bit?  We can pick any bit we like for this, but for
reasons that will become apparent soon, let&rsquo;s choose the
<span class="emph">least-significant bit</span> (LSB) to denote numbers versus booleans:
</p><ul><li><p>LSB = <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0</code></span> implies the value is a <span class="emph">number</span></p></li><li><p>LSB = <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">1</code></span> implies the value is a <span class="emph">boolean</span></p></li></ul></p><p>This may still feel like overkill: we have 4 quintillion bit patterns reserved
just for booleans, and we&rsquo;ve given up half of our available space for numbers.
In practice, we&rsquo;ll accept the loss of range on numbers for now, and we&rsquo;ll
refine our notion of what it means to &ldquo;tag a boolean&rdquo; so that we can use the
rest of that reserved space for other types of values, later.</p><h5>2.2.1<tt>&nbsp;</tt><a name="(part._.Booleans)"></a>Booleans</h5><p><p>We now need to choose representations for <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span> themselves.
Since it&rsquo;s very likely that tags are going to get more complex later, we
probably want to reserve several low-order bits for future tag use &#8212;<wbr></wbr> so using
any of those bits to encode our values is probably not future-proof.  Instead,
let&rsquo;s look to the other end of the value, at its <span class="emph">most-significant bit</span>
(MSB), and declare that
</p><ul><li><p>MSB = <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0</code></span> encodes <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></li><li><p>MSB = <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">1</code></span> encodes <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></li></ul></p><p>In other words, our true and false values will therefore be
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1wwwwwww_wwww.....wwww_wwwwwww1</code></span> and
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0wwwwwww_wwww.....wwww_wwwwwww1</code></span>, respectively.  We can choose
whatever bits we want in between: two obvious choices would be either all zeros
or all ones.  Arbitrarily, we&rsquo;ll choose all-ones.</p><h5>2.2.2<tt>&nbsp;</tt><a name="(part._.Numbers)"></a>Numbers</h5><p>How should we represent numbers, then?  Since we&rsquo;ve decided that an LSB of zero
indicates a number, we effectively have all the
bit-patterns-formerly-interpreted-as-even-numbers available to us as numbers.
This lends itself to a convenient encoding: we&rsquo;ll simply represent the number
<span style="font-style: italic">n</span> as the bit-pattern that used to represent <span style="font-style: italic"></span>2<span style="font-style: italic">n</span>:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Number</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Representation</p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b00000000_0000.....0000_00000010</code></span></p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">6</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b00000000_0000.....0000_00001100</code></span></p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">42</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b00000000_0000.....0000_01010100</code></span></p></td></tr></table></p><p>This is clearly a one-to-one mapping, so it&rsquo;s a faithful encoding; let&rsquo;s see if
it&rsquo;s a <span class="emph">useful</span> one, too.</p><h4>2.3<tt>&nbsp;</tt><a name="(part._.Compiling_constants)"></a>Compiling constants</h4><p>Compiling our new constants is fairly straightforward.  There is a twist: we
need to ensure <span class="emph">at compile time</span> that any numeric constants we have in our
source program aren&rsquo;t inherently overflowing:
<div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">static MAX_SNAKE_INT = i64::max &gt;&gt; 1;
static MIN_SNAKE_INT = i64::min &gt;&gt; 1;
fn compile_imm(e: &amp;ImmExp, env: &amp;[(&amp;str, i32)]) -&gt; Arg64 {
  match e {
    ImmExp::Num(n) =&gt; {
      if n &gt; MAX_SNAKE_INT || n &lt; MIN_SNAKE_INT {
        panic!("Integer constant doesn't fit into 63 bits: {}", n);
      } else {
        Arg64::Imm(n &lt;&lt; 1)
      }
    }
    ImmExp::Bool(b) =&gt; {
      if b {
        SNAKE_TRUE
      } else {
        SNAKE_FALSE
      }
    }
  }
}</code></pre></div></div>
Here, the left shift <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">&lt;&lt;</code></span> operator shifts the bits
of its first operand by some number of places given by the second operand.  The
newly vacated bits are filled in with zeros.  As a consequence,
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">(n &lt;&lt; 1) == 2 * n</code></span>...but since we&rsquo;re contemplating these values as bit
patterns, it&rsquo;s a useful observation to notice that multiplying by two simply
slides the bits around: perhaps we can rely on that later to unslide them as needed.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>It&rsquo;s worth pausing to confirm that <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">&lt;&lt;</code></span> does have the desired
semantics in all cases, especially when <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">&lt;&lt;</code></span> is negative.  Given that our
numbers use <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two&rsquo;s
complement</a> representation, what can we determine about the most significant
bits of any negative number in our valid range of numbers?  Given <span class="emph">that</span>,
what we can we deduce about the behavior of <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">&lt;&lt;</code></span>?</p></blockquote><p>The <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">SNAKE_TRUE</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">SNAKE_FALSE</code></span> values are whatever bit patterns we
chose above; for legibility, we ought to define them as named constants in our
compiler, rather than scatter magic numbers throughought our code.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Now that we have defined how to compile constants, what output will
we get from executing the program <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">15</code></span>?  What will we get from running the
program <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span>?</p></blockquote><h4>2.4<tt>&nbsp;</tt><a name="(part._.Defining_arithmetic_over_our_representations)"></a>Defining arithmetic over our representations</h4><p>Well clearly, even before arithmetic, the first operation we should redefine is
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">print</code></span> &ndash; or else we cannot trust any output of our program!</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>How many cases of output should we check for, if we&rsquo;re coding
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">print</code></span> defensively?</p></blockquote><p>Since we now have at least two different types of values in our
language, it doesn&rsquo;t quite make sense to use the Rust type <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">i64</code></span>
to describe them: they&rsquo;re not meaningfully <span class="emph">numbers</span> in Rust,
necessarily, but rather are just 64 bits of data.  Accordingly, we&rsquo;ll
use a single-argument struct to create a wrapper type around
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">u64</code></span>, to remind ourselves of which values are meaningful
values-in-our-program, and which values are meaningful-in-C.  All bit
patterns ending in zeros will be considered numbers.  Only two
patterns that end in a one have any meaning, as <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span> and
<span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span>; everything else is an error for now:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">#[repr(C)]
#[derive(PartialEq, Eq, Copy, Clone)]
struct SNAKE_VAL(u64);


static BOOL_TAG: u64 = 0x00_00_00_00_00_00_00_01;
static SNAKE_TRU: SNAKE_VAL = SNAKE_VAL(0xFF_FF_FF_FF_FF_FF_FF_FF);
static SNAKE_FLS: SNAKE_VAL = SNAKE_VAL(0x7F_FF_FF_FF_FF_FF_FF_FF);

#[link(name = "compiled_code", kind = "static")]
extern "C" {
    #[link_name = "\x01start_here"]
    fn start_here() -&gt; SNAKE_VAL;
}

// reinterprets the bytes of an unsigned number to a signed number
fn unsigned_to_signed(x: u64) -&gt; i64 {
    i64::from_le_bytes(x.to_le_bytes())
}

fn sprint_snake_val(x: SNAKE_VAL) -&gt; String {
    if x.0 &amp; BOOL_TAG == 0 { // it's a number
        format!("{}", unsigned_to_signed(x.0) &gt;&gt; 1)
    } else if x == SNAKE_TRU {
        String::from("true")
    } else if x == SNAKE_FLS {
        String::from("false")
    } else {
        panic!("Invalid snake value")
    }
}

fn main() {
    let output = unsafe { start_here() };
    println!("As unsigned number: {}", output.0);
    println!("As signed   number: {}", i64::from_le_bytes(output.0.to_le_bytes()));
    println!("As binary:           0b{:064b}", output.0);
    println!("As hex:              0x{:016x}", output.0);
    println!("As snake value:      {}", sprint_snake_val(output));
}</code></pre></div></div></p><p><span class="emph">Now</span> let&rsquo;s consider arithmetic operations.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What currently is output if we execute <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">add1(0)</code></span>?  Redefine
<span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">add1</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">sub1</code></span> to fix this.</p></blockquote><p>Zero is represented as <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x00000000</code></span>, so <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">add1(0)</code></span> currently produces
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x00000001</code></span>, which is a representation of a boolean value!  Our
implementations of <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">add1</code></span>, and more generally addition and subtraction, need
to take that representation into account.</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Operation</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Representation</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Result</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Interpretation</p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">3 + 4</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x0000000000000006 + 0x0000000000000008</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x000000000000000D</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">7</code></span></p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">8 + 9</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x0000000000000010 + 0x0000000000000012</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x0000000000000022</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">17</code></span></p></td></tr><tr><td><p><span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"> + n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span style="font-style: italic"></span>2<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"> + </span>2<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span style="font-style: italic"></span>2<span style="font-style: italic"></span>(<span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"> + n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span>)<span style="font-style: italic"></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span style="font-style: italic">n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>1<span style="font-style: italic"></span></span><span style="font-style: italic"> + n</span><span style="vertical-align: sub; font-size: 80%"><span style="font-style: italic"></span>2<span style="font-style: italic"></span></span><span style="font-style: italic"></span></p></td></tr></table></p><p>Interestingly, our notion of addition and subtraction <span class="emph">just works</span> with
our encoding, because multiplication distributes over addition.  This is very
convenient: no changes are needed to how we compile addition or
subtraction.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._10._lecturetagging-values%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">Not quite!  What important cases are we missing?  There&rsquo;s
nothing we can do about them yet, but we shoudl be aware that there are
lingering problems.</span></span>  And it informs us how we should revise <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">add1</code></span> and
<span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">sub1</code></span>: they should add or subtract not 1, but rather <span class="emph">the
representation of 1</span>, i.e. <span class="emph">2</span>.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What currently is output if we execute <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">3 * 2</code></span>?  Redefine
multiplication to fix this.</p></blockquote><p>Following the same logic as above, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">3 * 2</code></span> is encoded as <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">6 * 4</code></span>, which
produces <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">24</code></span> as a result, which is interpreted as <span class="emph">12</span>, which is
twice as big as the desired result.  When we multiply, we wind up with an extra
factor of two since both operands have individually been multiplied by two.
Our implementation of multiplication must shift the result right by one bit, to
compensate.  The <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">shr val, bits</code></span> instruction shifts the given <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">val</code></span> to
the right by the given number of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">bits</code></span>.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Ok, so multiplication seems fixed.  What happens if we execute
<span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">2 * (-1)</code></span>?  Why does that result appear?</p></blockquote><p>Our program <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">print</code></span>s <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">4611686018427387902</code></span>, which is represented by
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">9223372036854775804</code></span>, or <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x7FFFFFFFFFFFFFFFC</code></span>.  The trouble is that
negative numbers are represented by having the MSB set to 1 (the &ldquo;sign bit&rdquo;),
and shifting right does not preserve that sign bit: our output has an MSB of
zero, even though it should be representing a negative number.  Instead, we need
<span class="emph">arithmetic shift right</span>, instead of <span class="emph">logical shift right</span>: a
dedicated instruction <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sar</code></span> that behaves like <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">shr</code></span>, except it keeps
the sign bit unchanged.</p><h4>2.5<tt>&nbsp;</tt><a name="(part._.Defining_logic_operations_over_our_representations)"></a>Defining logic operations over our representations</h4><p>Logical <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">and</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">or</code></span> are very easy to define.  Because we&rsquo;ve confined
the differences between the representations of <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span> to a
single bit (the MSB), and in all other bits they are the same, <span class="emph">logical</span>
<span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">and</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">or</code></span> are equivalent to <span class="emph">bitwise</span> <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">and</code></span> and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">or</code></span>, for
which we have dedicated assembly instructions.  Specifically:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>val1</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val2</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val1-rep</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val2-rep</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val1-rep bitwise-AND val2-rep</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val1 and val2</p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td></tr></table></p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>val1</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val2</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val1-rep</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val2-rep</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val1-rep bitwise-OR val2-rep</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val1 or val2</p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td></tr></table></p><p>Logical <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">not</code></span> is slightly trickier.  We could use <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">not</code></span> to invert the
MSB, but that would invert all the bits of the value &#8212;<wbr></wbr> including the tag bit,
which would convert the result into a representation of a number.  Really, we
want to invert <span class="emph">only</span> the MSB, and leave all the other bits alone.  In
other words, we want the following truth table:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Input bit</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Flip?</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Output</p></td></tr><tr><td><p>1</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>1</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>0</p></td></tr><tr><td><p>0</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>1</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>1</p></td></tr><tr><td><p>1</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>0</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>1</p></td></tr><tr><td><p>0</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>0</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>0</p></td></tr></table></p><p>This is the truth table that defines the exclusive-or operation, and the
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">xor</code></span> instruction applies this operation bitwise.  Suppose we designed a
<span class="emph">mask</span> <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">BOOL_MASK</code></span> equal to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x8000000000000000</code></span>, whose only active bit is
the MSB.  Then <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">xor RAX, BOOL_MASK</code></span> will negate only the MSB, and leave
the rest unchanged, as desired:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>val</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val-rep</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>BOOL_MASK</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>val-rep bitwise-XOR BOOL_MASK</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>not(val)</p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x8000000000000000</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td></tr><tr><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x8000000000000000</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b1ww...ww1</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span></p></td></tr></table></p><p>Note that unfortunately, we cannot write <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">xor RAX, 0x8000000000000000</code></span>.
Due to a limitation of x64 syntax, we cannot specify a 64-bit literal argument
to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">xor</code></span> (or to many other operators, either).  Instead, we would have to
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov</code></span> that value into a temporary register or a stack slot first, and then
we could <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">xor</code></span> <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> with that temporary value.  This infelicity of x64
assembly syntax will come back to bother us later, so it&rsquo;s useful to point out
now.</p><h4>2.6<tt>&nbsp;</tt><a name="(part._.Defining_comparisons_over_our_representations)"></a>Defining comparisons over our representations</h4><p>Comparisons are slightly finicky to define well.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What are the kinds of numbers most likely to cause problems?  Work
through the bitwise representation of those numbers, and try to construct some
assembly sequence that would take two (representations of) numbers and produce
a (representation of a) boolean that represents their comparison.</p></blockquote><p>Here are two potential strategies, focusing just on the less-than operator:</p><h5>2.6.1<tt>&nbsp;</tt><a name="(part._.Using_cmp)"></a>Using <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span></h5><p>Most simply, we can just use the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span> operation,
which compares its two operands arithmetically.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._11._lecturetagging-values%29%29" data-pltdoc="x">2</a></span></span><span class="FootnoteContent">In fact, the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span>
operator simply subtracts one argument from the other, just like <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sub</code></span>
does, and sets the same overflow, zero, and signedness flags.  In contrast to
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sub</code></span>, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span> discards the result of the subtraction, and doesn&rsquo;t
overwrite its first argument.
<a href="http://unixwiz.net/techtips/x86-jumps.html">This link</a> provides a
nice summary of the various conditional jumps available in assembly, as well as
the meaning of the flags that are set by comparisons or subtractions.</span></span>  We then
use one of the conditional jump instructions much like compiling an
if-expression, and move the appropriate boolean constant into <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> as a
result.  Assuming we have values in stack slots 1 and 2, we might start with
the following assembly:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ;;; NOTE: cmp does not allow both arguments to be memory accesses
  mov RAX, [RSP - 8*1] ;; Load first value
  cmp RAX, [RSP - 8*2] ;; Compare with second value
  jl less
greater:
  ....
  j done
less:
  ....
done:
  ...</code></pre></div></div></p><p>and we can refine it to produce the needed boolean.  This scaffold looks pretty
similar to the structure for compiling an <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> expression, but we don&rsquo;t
need the full generality of that structure.  We can assume the result will be
<span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span>, perform the comparison and jump, and if the comparison fails
we&rsquo;ll update the result to be <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  mov RAX, [RSP - 8*1]
  cmp RAX, [RSP - 8*2]
  ;; The comparison has now set the necessary flags,
  ;; so we can safely clobber RAX:
  mov RAX, 0x8000000000000001 ;; Assume the result is true
  jl less                     ;; If this jump falls through,
  mov RAX, 0x0000000000000001 ;; then the comparison failed
less:
  ...</code></pre></div></div></p><p>We could also have flipped the assumption, started from <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span>, and
jumped if the comparison failed:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  mov RAX, [RSP - 8*1]
  cmp RAX, [RSP - 8*2]
  ;; The comparison has now set the necessary flags,
  ;; so we can safely clobber RAX:
  mov RAX, 0x0000000000000001 ;; Assume the result is false
  jge less                    ;; If this (inverted) jump falls through,
  mov RAX, 0x8000000000000001 ;; then the comparison succeeded
greater_eq:
  ...</code></pre></div></div></p><p>This is straightforward, but potentially expensive, since conditional jump
instructions can stall the processor if the processor &ldquo;guesses wrong&rdquo; about
whether the branch will be taken or not.  We can try to build an optimizer to
choose which of these two compilations to pick, based on whether we think the
condition is more often true or false, and that might be worthwhile for
critical inner loops...</p><p>Can we do &ldquo;better&rdquo; and avoid needing any conditional jumps?</p><h5>2.6.2<tt>&nbsp;</tt><a name="(part._.Being__clever__)"></a>Being &ldquo;clever&rdquo;?</h5><p>There are arithmetic and bitwise tricks we can play to get the answer correct
in nearly every case.  For example, to determine if <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">6 &lt; 15</code></span>, we can
simply compute their difference, or <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">-9</code></span>.  Because this is a negative
number, its MSB is <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">1</code></span>, which is exactly the defining bit of <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span>.
We merely need to set all the remaining bits to <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">SNAKE_TRUE</code></span>&rsquo;s bits.  If we
chose a representation with all zeros, then <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">and</code></span>&rsquo;ing our answer with
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">BOOL_MASK</code></span> will force all the remaining bits to zeros.  If we chose a
representation with all ones, then <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">or</code></span>&rsquo;ing our answer with the complement
of <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">BOOL_MASK</code></span> will force all the remaining bits to ones.  A similar argument
holds for checking if <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">15 &lt; 6</code></span>, because that subtraction yields a
positive number, whose MSB is zero, which is the defining bit for
<span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span>.  So for example, we might try the following for <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">6 &lt; 15</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RAX, 12 ;; Representation of 6
sub RAX, 30 ;; Representation of 15
and RAX, 0x8000000000000000 ;; Mask off all the irrelevant bits,
or  RAX, 0x0000000000000001 ;; and make sure to tag it back as a boolean!</code></pre></div></div></p><p>Unfortunately, this approach fails for large numbers.  Checking if
<span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">4611686018427387903 &lt; -4611686018427387904</code></span> fails <span class="emph">with our representations</span>, because we
represent the former by <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x7ffffffffffffffe</code></span>, and the latter by <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x8000000000000000</code></span>.
Subtracting the latter from the former yields <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0xfffffffffffffffe</code></span>, or <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">-2</code></span>
(which in turn encodes <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">-1</code></span> in our representation), whose MSB is 1,
leading to a conclusion that <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">4611686018427387903 &lt; -4611686018427387904</code></span> is <span class="emph">true!</span>  The
problem is that our subtraction overflowed 63 bits on these large numbers, and
no longer makes sense under our representation.  The solution, then, is to use
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sar</code></span> to shift both operands right by one bit, <span class="emph">before</span> doing the
subtraction, so that overflow can&rsquo;t spill into the sign bit.  Using these two
extra shifts affects our compilation: even though we&rsquo;ve compiled both arguments
to the comparison into immediates, we actually need to preprocess both of them,
which means we need a place to stash them both.  Practically speaking, we can
use <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> for one, and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBX</code></span> for the other, so long as nothing else in
our compilation is using <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBX</code></span> (which at the moment, indeed, nothing is).
This would look like:<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._12._lecturetagging-values%29%29" data-pltdoc="x">3</a></span></span><span class="FootnoteContent">If we wanted to be a bit more careful with
producing exactly our two canonical booleans, all of whose bits are 1, then in
the final step we should <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">or</code></span> with <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x7fffffffffffffff</code></span>.</span></span></p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RAX, 0x7ffffffffffffffe ;; Representation of 2^62 - 1
sar RAX, 1                  ;; Shift (arithmetic) right by 1 bit
mov RBX, 0x8000000000000000 ;; Representation of -2^62
sar RBX, 1                  ;; Shift (arithmetic) right by 1 bit
sub RAX, RBX                ;; Produce the difference
and RAX, 0x8000000000000000 ;; Mask off the irrelevant bits
or  RAX, 0x0000000000000001 ;; and tag it again as a boolean</code></pre></div></div></p><p>(Actually, technically, this approach also fails, but for a far less
interesting reason: again, due to the limitation on 64-bit literal constants in
most assembly instructions.  If we were to try to implement the code above
properly, we&rsquo;d actually have to move the argument to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">and</code></span> into a temporary
register first, and then <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">and</code></span> <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> with that temporary register.  The
following command for <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">or</code></span> &ldquo;works&rdquo;, only because truncating that constant
to its lower 32 bits yields the same value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">1</code></span> as the entire 64-bit
constant does.)</p><h5>2.6.3<tt>&nbsp;</tt><a name="(part._.So_why_does_cmp_work_)"></a>So why does <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span> work?</h5><p>Internally, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span> really does perform a subtraction on its two arguments,
but as we just showed above, that doesn&rsquo;t quite work as smoothly as we&rsquo;d like!
Looking carefully at the failure above, we see that when an overflow occurs,
our sign bit is exactly wrong.  Reading the documentation for <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span> and
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sub</code></span>, it turns out they set a few flag bits indicating whether an
operation has overflowed, is negative, is zero, etc.  The meaning of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jl</code></span>,
subtly, is to check whether <span class="emph">either</span> the operation overflowed and is
negative, <span class="emph">or</span> the operation didn&rsquo;t overflow and is positive.  In other
words, it checks whether the overflow flag is not equal to the signedness
flag.  Since we don&rsquo;t have a trivial way of implementing that check via
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">and</code></span>, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">or</code></span> or <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">xor</code></span>, our simple code above failed.</p><p>There exist techniques to copy the flags register into an actual register (or
onto the stack) so that we can manipulate it further, but a detailed analysis
of the cycle counts for
<a href="https://pdos.csail.mit.edu/6.828/2008/readings/i386/Jcc.htm">conditional
jumps</a> versus
<a href="https://pdos.csail.mit.edu/6.828/2008/readings/i386/PUSHF.htm">pushing</a>
and
<a href="https://pdos.csail.mit.edu/6.828/2008/readings/i386/POPF.htm">popping</a>
the flags register shows that the conditional jump is both simpler and faster,
uses fewer registers, and works in all cases.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Complete this analysis for other comparison operations, being
careful about overflow in all cases.</p></blockquote><h3>3<tt>&nbsp;</tt><a name="(part._.Overflow_and_.Bogus_.Arguments)"></a>Overflow and Bogus Arguments</h3><p>Unfortunately, our code currently does not prohibit bogus programs, such as
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">5 + true</code></span>.  Indeed, we don&rsquo;t even have a mechanism yet for enforcing such
things.  Additionally, while our compilation of constants prohibits
compile-time constants that overflow 63 bits, nothing prohibits us from adding
numbers together until they overlow.  Checking for such broken behaviors is the
focus of next lecture.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Testing)"></a>Testing</h3><p>As we&rsquo;ve now added a new type of value to our language, it&rsquo;s crucial to test
thoroughly that we properly process and render each type of value
consistently: that is, any operations that produce booleans should always
produce valid boolean representations, and similarly for numeric operations.
Moreover, operations should process their operands correctly.  (We don&rsquo;t yet
have to worry about operations handling operands of the wrong types, as noted
above.)  Catching inconsistencies at this stage is substantially easier than it
will be later, since we haven&rsquo;t added too many new expression forms to the language.</p><a name="(part._(gentag._9._lecturetagging-values))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._10._lecturetagging-values))"></a>1</span></span>Not quite!  What important cases are we missing?  There&rsquo;s
nothing we can do about them yet, but we shoudl be aware that there are
lingering problems.</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._11._lecturetagging-values))"></a>2</span></span>In fact, the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span>
operator simply subtracts one argument from the other, just like <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sub</code></span>
does, and sets the same overflow, zero, and signedness flags.  In contrast to
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sub</code></span>, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span> discards the result of the subtraction, and doesn&rsquo;t
overwrite its first argument.
<a href="http://unixwiz.net/techtips/x86-jumps.html">This link</a> provides a
nice summary of the various conditional jumps available in assembly, as well as
the meaning of the flags that are set by comparisons or subtractions.</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._12._lecturetagging-values))"></a>3</span></span>If we wanted to be a bit more careful with
producing exactly our two canonical booleans, all of whose bits are 1, then in
the final step we should <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">or</code></span> with <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x7fffffffffffffff</code></span>.</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>