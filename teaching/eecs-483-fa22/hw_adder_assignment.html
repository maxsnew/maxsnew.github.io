<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Assignment 1: Adder: A starter language</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="rust.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 1:</span> Adder:<span class="mywbr"> &nbsp;</span> A starter language</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.The_.Adder_.Language%29" class="tocviewlink" data-pltdoc="x">The Adder Language</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Starter_code_for_this_assignment%29" class="tocviewlink" data-pltdoc="x">Starter code for this assignment</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Implementing_a_.Compiler_for_.Adder%29" class="tocviewlink" data-pltdoc="x">Implementing a Compiler for Adder</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Cross-platform_.Issues%29" class="tocviewlink" data-pltdoc="x">Cross-<wbr></wbr>platform Issues</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Rust_.Tips%29" class="tocviewlink" data-pltdoc="x">Rust Tips</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.List_of_.Deliverables%29" class="tocviewlink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#%28part._.Grading_.Standards%29" class="tocviewlink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="#%28part._.Submission%29" class="tocviewlink" data-pltdoc="x">Submission</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="AssignmentNum">Assignment 1:</span> Adder:<span class="mywbr"> &nbsp;</span> A starter language</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Adder_.Language%29" class="tocsubseclink" data-pltdoc="x">The Adder Language</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Concrete_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Concrete Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Abstract_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Abstract Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Semantics%29" class="tocsubseclink" data-pltdoc="x">Semantics</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Starter_code_for_this_assignment%29" class="tocsubseclink" data-pltdoc="x">Starter code for this assignment</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Implementing_a_.Compiler_for_.Adder%29" class="tocsubseclink" data-pltdoc="x">Implementing a Compiler for Adder</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Writing_the_.Compiler%29" class="tocsubseclink" data-pltdoc="x">Writing the Compiler</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Testing_the_.Compiler%29" class="tocsubseclink" data-pltdoc="x">Testing the Compiler</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._.Running_main_and_compiling_to_binary%29" class="tocsubseclink" data-pltdoc="x">Running main and compiling to binary</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Cross-platform_.Issues%29" class="tocsubseclink" data-pltdoc="x">Cross-<wbr></wbr>platform Issues</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Rust_.Tips%29" class="tocsubseclink" data-pltdoc="x">Rust Tips</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.List_of_.Deliverables%29" class="tocsubseclink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._.Grading_.Standards%29" class="tocsubseclink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td><span class="tocsublinknumber">8<tt>&nbsp;</tt></span><a href="#%28part._.Submission%29" class="tocsubseclink" data-pltdoc="x">Submission</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.4</span></div><h2><a name="(part._)"></a><span class="AssignmentNum">Assignment 1:</span> Adder: A starter language</h2><p><h4 class="due">Due: Fri 09/23 at 5:00pm</h4></p><p><p class="git-clone"><code><span class="kw">git clone </span><input onclick="this.select();" readonly="readonly" value="https://gitlab.eecs.umich.edu/483-fa22/starter-code/adder"/></code></p></p><p>In this assignment you&rsquo;ll implement a compiler for a small language called
Adder (because it primarily adds things). <a href="https://upload.wikimedia.org/wikipedia/commons/2/28/Loch_Shin_adder.JPG">Click for scary snake picture!</a></p><h3>1<tt>&nbsp;</tt><a name="(part._.The_.Adder_.Language)"></a>The Adder Language</h3><p>In each of the next several assignments, we&rsquo;ll introduce a language that we&rsquo;ll
implement.  We&rsquo;ll start small, and build up features incrementally.  We&rsquo;re
starting with Adder, which has just a few features &#8212;<wbr></wbr> defining variables, and
primitive operations on numbers.</p><p>There are a few pieces that go into defining a language for us to compile.</p><ul><li><p>A description of the concrete syntax &#8212;<wbr></wbr> the text the programmer writes</p></li><li><p>A description of the abstract syntax &#8212;<wbr></wbr> how to express what the
programmer wrote in a data structure our compiler uses.</p></li><li><p>The <span class="emph">semantics</span> &#8212; or description of the behavior &#8212; of the abstract
syntax, so our compiler knows what the code it generates should do.</p></li></ul><h4>1.1<tt>&nbsp;</tt><a name="(part._.Concrete_.Syntax)"></a>Concrete Syntax</h4><p>The concrete syntax of Adder is:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Adder._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">NUMBER</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">add1</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">sub1</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">let</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._bindings%29%29%29" data-pltdoc="x">&#8249;bindings&#8250;</a></span> <span class="bnf-lit">in</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Adder._bindings)))"></a><span class="bnf-rule">&#8249;bindings&#8250;</span><span class="bnf-meta">:</span> 
                  <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">=</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
                  <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">=</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._bindings%29%29%29" data-pltdoc="x">&#8249;bindings&#8250;</a></span></p></blockquote><p>The main difference from the language we discussed in class is that a
<span title="Adder" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let</code></span> expression can have one <span class="emph">or many</span> bindings.  An
<span class="bnf-lit bnf-unknown">IDENTIFIER</span> is any non-sequence
of letters and digits (starting with a letter).  Any <span class="bnf-lit">highlighted</span> text is a literal token, meaning the
programmer must type exactly those characters or keywords.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Abstract_.Syntax)"></a>Abstract Syntax</h4><p>The abstract syntax of Adder is a Rust datatype, and corresponds
nearly one-to-one with the concrete syntax. We parameterize the AST by
a type of annotations.</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Exp&lt;Ann&gt; {
    Num(i64, Ann),
    Var(String, Ann),
    Prim1(Prim1, Box&lt;Exp&lt;Ann&gt;&gt;, Ann),
    Let { bindings: Vec&lt;(String, Exp&lt;Ann&gt;)&gt;, // new binding declarations
          body: Box&lt;Exp&lt;Ann&gt;&gt;,  // the expression in which the new variables are bound
          ann: Ann
        }
}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum Prim1 {
    Add1,
    Sub1,
}</code></pre></div></div></p><p>For now, the only annotations we&rsquo;ll use are <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Span</code></span>s, which are
regions of the source code (defined in <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">span.rs</code></span>). These are used
to give nicer error messages.</p><h4>1.3<tt>&nbsp;</tt><a name="(part._.Semantics)"></a>Semantics</h4><p>An Adder program always evaluates to a single integer.  <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Num</code></span>s
evaluate to themselves (so a program just consisting of <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Num(5)</code></span>
should evaluate to the integer <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">5</code></span>).  Primitive expressions
perform addition or subtraction by one on their argument. Let
bindings should evaluate all the binding expressions to values one by
one, and after each, store a mapping from the given name to the
corresponding value in both (a) the rest of the bindings, and (b) the
body of the let expression. Identifiers evaluate to whatever their
current stored value is.  There are several examples further down to
make this concrete.</p><p><p>The compiler should return an error if
</p><ul><li><p>There is a binding list containing two or more bindings with the same name</p></li><li><p>An identifier is unbound (there is no surrounding let binding for it)</p></li></ul><p>These errors are encoded in the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">CompileError</code></span> type in
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">compile.rs</code></span>.</p></p><p>Here are some examples of Adder programs (ignoring the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Ann</code></span>
written in the style of Debug):</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Concrete Syntax</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Abstract Syntax</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Answer</p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Adder" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">5</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Num(5)</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>5</code></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Adder" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">sub1(add1(sub1(5)))</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Prim1(Sub1, Prim1(Add1, Prim1(Sub1, Num(5))))</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>4</code></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Adder" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = 5 in add1(x)</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Let{ bindings: [("x", Num(5))],
     body: Prim1(Add1, Var("x")) } </code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>6</code></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Adder" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = 5,
    y = sub1(x)
in sub1(y)</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Let{ bindings: [("x", Num(5)),
                ("y", Prim1(Sub1, Var("x")))],
     body: Prim1(Sub1, Var("y"))}</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>3</code></p></td></tr></table></p><p>Note that shadowing of variables is allowed, but all variable names in
a single binding list must be unique. So</p><p><div class="sourceCodeWrapper"><span data-label="Adder" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = 3 in
let x = 4 in
x</code></pre></div></div></p><p>is a valid program, but</p><p><div class="sourceCodeWrapper"><span data-label="Adder" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = 3, x = 4 in
x</code></pre></div></div></p><p>should produce a compile-time error.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Starter_code_for_this_assignment)"></a>Starter code for this assignment</h3><p>You&rsquo;ve been given a starter codebase that has several pieces of
infrastructure:</p><ul><li><p>A file <code>syntax.rs</code> that defines our abstract syntax trees.</p></li><li><p>A file <code>asm.rs</code> that defines types registers, instructions
and their arguments. Read over these types carefully to see how we
encode the invariants of x86-64 using Rust&rsquo;s type system.</p></li><li><p>A file <code>compile.rs</code> that defines the compiler to a sequence
of instructions. You will be editing this file.</p></li><li><p><code>lib.rs</code> which declares the modules in the package.</p></li><li><p>A file <code>parser.lalrpop</code> that defines a grammer describing
the concrete syntax of the language and <code>parser.rs</code>, an
automatically generated file that parses according to that grammar.</p></li><li><p>A main program (<code>main.rs</code>) that uses the support code in
<code>span.rs</code>, <code>runner.rs</code> and <code>interp.rs</code> to implement interactively
running the compiler, linking with the runtime and using the reference
interpreter.</p></li><li><p>A file <code>runtime/stub.rs</code> that links with your compilation
output to form executables.</p></li><li><p>A file <code>tests/examples.rs</code> with some helper code for writing
integration tests (see below).</p></li><li><p>A file <code>examples/parse_error.adder</code> to demonstrate where to
put example files for integration tests.</p></li></ul><p>You will complete the compiler by editing <code>compile.rs</code>, but you
are free to add more modules if you like (you will need to list them
in <code>lib.rs</code> if you do). Remember, you can make any helper
functions you want, but do <span class="emph">not</span> change the <span class="emph">type</span> of any
function marked <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">pub</code></span> or your code will fail to type check
against the autograder.</p><p>You can use <code>test/examples.rs</code> to write integration tests (see below).</p><h3>3<tt>&nbsp;</tt><a name="(part._.Implementing_a_.Compiler_for_.Adder)"></a>Implementing a Compiler for Adder</h3><h4>3.1<tt>&nbsp;</tt><a name="(part._.Writing_the_.Compiler)"></a>Writing the Compiler</h4><p>The primary task of writing the Adder compiler is simple to state: take an
instance of the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Exp</code></span> datatype and turn it into a list of assembly
instructions.  The provided compiler skeleton is set up to do just this,
broken up over a couple of functions in <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">compile.rs</code></span>.</p><p>First:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">pub fn check_prog&lt;Span&gt;(e: &amp;Exp&lt;Span&gt;) -&gt; Result&lt;(), CompileErr&lt;Span&gt;&gt;
where Span: Clone</code></pre></div></div></p><p>is a function for checking that the parsed program is well-formed. If
it is well formed, the function returns <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Ok(())</code></span> and if it is
ill-formed, it returns <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Err(e)</code></span> where <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">e</code></span> is an informative
error message. Note that this is a <span class="emph">generic</span> function, generic in
the type <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Span</code></span> of source locations, with the side-condition that
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Span</code></span> implements the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Clone</code></span> trait. This just means that
you don&rsquo;t need to care about the details of how <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Span</code></span>s are
implemented, except that you can <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">clone</code></span> them if you ever need to
use one in a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">CompileErr&lt;Span&gt;</code></span>.</p><p>Next:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">pub fn compile_to_instrs&lt;Ann&gt;(e: &amp;Exp&lt;Ann&gt;) -&gt; Vec&lt;Instr&gt;</code></pre></div></div></p><p>is the main code-generation function. This takes a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Exp</code></span> value
(abstract syntax, with annotations) and turns it into a list of
assembly instructions, represented by the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Instr</code></span> type.  Use only
the provided instruction types for this assignment; we will be
gradually expanding this set of instructions as the semester
progresses. We suggest you read <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">asm.rs</code></span> to get familiar with the
x64 assembly instructions you have available to you.</p><p>For this assignment, do not simply run an interpreter on the code and
output a two line-assembly program that directly returns the final
result. You will receive 0 points on the assignment if you do so. Once
we add interactive features to the language (reading from
stdin/command-line arguments) this won&rsquo;t be possible anyway.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Testing_the_.Compiler)"></a>Testing the Compiler</h4><p>The code-generation portion of the compiler pipeline is not as
amenable to unit testing since we do not want to over-constrain what
specific instructions we use for a given input. Instead, this week we
will be introducing <span class="emph">integration tests</span>, which test the entire
compiler pipeline.</p><p>Cargo looks for integration tests in the <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">tests/</code></span>
directory. Included in the startup code are two macros, <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">mk_test</code></span>
and <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">mk_fail_test</code></span> for writing end-to-end compiler tests. To use
them, add a file to the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">examples/</code></span> directory and then call
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">mk_test</code></span> with a name for the test, the name of the file in the
example directory you are testing, and the expected number for it to
output. For failing tests, you can use <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">mk_fail_test</code></span> to include
a string that you expect to occur in the error message.</p><h4>3.3<tt>&nbsp;</tt><a name="(part._.Running_main_and_compiling_to_binary)"></a>Running main and compiling to binary</h4><p><code>main.rs</code> provides some convenient infrastructure for running
your compiler and interpreter from a terminal. To see the expected
arguments simply run <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">cargo run</code></span> with no options. Note that to
distinguish the flags for your program from Cargo&rsquo;s flags you need to
insert <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode"> -- </code></span> before your flags. For example, to run the
interpreter on a file <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">example.adder</code></span> you can use</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ cargo run -- --interp example.adder</code></pre></div></div></p><p>Alternatively, you can compile <code>main.rs</code> to a binary using
<span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">cargo build --release</code></span>. Then the binary will be located at
<code>./target/release/snake</code>.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Cross-platform_.Issues)"></a>Cross-platform Issues</h3><p>On any platform you need to have <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">nasm</code></span> and <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">ar</code></span>
installed. Ask on Piazza if you have any issues installing these. If
you have installed these correctly and are using Mac or Linux the
runner should correctly use the right flags for your platform when
creating the final binary.</p><p>Here are the explicit commands the runner uses to build an executable
from an assembly code file <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">compiled_code.s</code></span> and the rust stub
<span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">stub.rs</code></span>. First build an object file using <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">nasm</code></span>,
passing the appropriate format flag for your platform.</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ nasm -felf64 compiled_code.s -o compiled_code.o   # Linux
$ nasm -fmacho64 compiled_code.s -o compiled_code.o # Mac</code></pre></div></div></p><p>Then build a static library file to link with the rust file
<div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ ar r libcompiled_code.a compiled_code.o # Linux &amp; Mac</code></pre></div></div></p><p>Finally, compile the rust file, indicating where to look for the static library.</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ rustc stub.rs -L . -o stub.exe                              # Linux
$ rustc stub.rs -L . --target x86_64-apple-darwin -o stub.exe # Mac</code></pre></div></div></p><p>This should make an executable that you can run.
<div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ ./stub.exe</code></pre></div></div></p><p>We recommend you try this out with the sample file
<div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">section .text
global start_here
start_here:
  mov RAX, 483
  ret</code></pre></div></div>
To make sure you have installed <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">nasm</code></span> and <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">ar</code></span> correctly.</p><h3>5<tt>&nbsp;</tt><a name="(part._.Rust_.Tips)"></a>Rust Tips</h3><p>To read more about pattern matching on structs like <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">MemRef</code></span> and
enums with named arguments like <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Exp</code></span> see
<a href="https://doc.rust-lang.org/stable/book/ch18-03-pattern-syntax.html">this
chapter of the Rust book</a>.</p><p>Sometimes you need to convert between different numeric types in Rust,
typically using the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Into</code></span> and <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">TryInto</code></span> traits. These
traits can be a bit tedious to use in my opinion because they often
need type annotations in weird places. To make things simple for you,
We&rsquo;ve included a function <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">usize_to_i32</code></span> in <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">compile.rs</code></span>
that tries to convert a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">usize</code></span> to an <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">i32</code></span>, panicking if it
does not fit. We used this in the reference solution so you may find it
useful.</p><p>Finally, in checking binding-lists for duplicates you might want to
use a data structure to keep track of the names. You can use a vector,
like we use in the interpreter, or you may want to try out the
<a href="https://doc.rust-lang.org/std/collections/struct.HashSet.html#">HashSet
module in the standard library</a>.</p><h3>6<tt>&nbsp;</tt><a name="(part._.List_of_.Deliverables)"></a>List of Deliverables</h3><p>Include (at least) the following files in your zip submission (you
only need to change <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">src/compile.rs</code></span>).</p><ul><li><p>Cargo.toml</p></li><li><p>src/compile.rs</p></li><li><p>src/lib.rs</p></li><li><p>src/asm.rs</p></li><li><p>src/interp.rs</p></li><li><p>src/parser.rs</p></li><li><p>src/runner.rs</p></li><li><p>src/syntax.rs</p></li><li><p>src/span.rs</p></li><li><p>any additional modules you saw fit to write</p></li><li><p>your compiler integration tests (<code>tests/examples.rs</code>)</p></li><li><p>The test input programs (<code>examples/*.adder</code> files) you wrote</p></li></ul><p>We&rsquo;ve included a script <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">mk-submission.sh</code></span> in the starter code
repo that should make the correct zip file for you.</p><h3>7<tt>&nbsp;</tt><a name="(part._.Grading_.Standards)"></a>Grading Standards</h3><p>For this assignment, you will be graded on whether your code
implements the specification (functional correctness). We encourage
you to test but your test coverage is not graded.</p><h3>8<tt>&nbsp;</tt><a name="(part._.Submission)"></a>Submission</h3><p><p><span style="font-weight: bold">Wait!</span> Please read the assignment again and verify that you have not forgotten anything!</p></p><p>Please submit your homework on gradescope by the above deadline.</p><a name="(part._(gentag._4._assignmentadder))"></a><p class="FootnoteBlock"></p></div></div><div id="contextindicator">&nbsp;</div></body></html>