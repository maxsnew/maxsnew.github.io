<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Assignment 5: Optimization and Register Allocation</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="rust.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 5:</span> Optimization and Register Allocation</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Register_.Allocation%29" class="tocviewlink" data-pltdoc="x">Register Allocation</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Assertion_.Removal%29" class="tocviewlink" data-pltdoc="x">Assertion Removal</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Updated_.Command_.Line_.Interface%29" class="tocviewlink" data-pltdoc="x">Updated Command Line Interface</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Testing_and_.Performance_.Evaluation%29" class="tocviewlink" data-pltdoc="x">Testing and Performance Evaluation</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Starter_.Code_and_.Deliverables%29" class="tocviewlink" data-pltdoc="x">Starter Code and Deliverables</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.Grading_.Standards%29" class="tocviewlink" data-pltdoc="x">Grading Standards</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="AssignmentNum">Assignment 5:</span> Optimization and Register Allocation</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Register_.Allocation%29" class="tocsubseclink" data-pltdoc="x">Register Allocation</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Liveness_.Analysis%29" class="tocsubseclink" data-pltdoc="x">Liveness Analysis</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Conflict_.Analysis_and_.Elimination_.Ordering%29" class="tocsubseclink" data-pltdoc="x">Conflict Analysis and Elimination Ordering</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Graph_.Coloring%29" class="tocsubseclink" data-pltdoc="x">Graph Coloring</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Assertion_.Removal%29" class="tocsubseclink" data-pltdoc="x">Assertion Removal</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Possible_.Values_.Analysis%29" class="tocsubseclink" data-pltdoc="x">Possible Values Analysis</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Assertion_.Removal%29" class="tocsubseclink" data-pltdoc="x">Assertion Removal</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Updated_.Command_.Line_.Interface%29" class="tocsubseclink" data-pltdoc="x">Updated Command Line Interface</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Testing_and_.Performance_.Evaluation%29" class="tocsubseclink" data-pltdoc="x">Testing and Performance Evaluation</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Starter_.Code_and_.Deliverables%29" class="tocsubseclink" data-pltdoc="x">Starter Code and Deliverables</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.Grading_.Standards%29" class="tocsubseclink" data-pltdoc="x">Grading Standards</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.15</span></div><h2 class="heading"><a name="(part._)"></a><span class="AssignmentNum">Assignment 5:</span> Optimization and Register Allocation<span class="button-group"><a href="#(part._)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h2><p><h4 class="due">Due: Sun 04/20 at 11:59pm</h4>
<p class="git-clone"><code><span class="kw">git clone </span><input onclick="this.select();" readonly="readonly" value="https://gitlab.eecs.umich.edu/483-wn25/optimization"/></code></p></p><p><span class="emph">As of initial release, the starter code is available, but the autograder will not be until Tuesday or Wednesday.</span></p><p><p>In this assignment, you will improve the performance of your compiled Diamondback code by implementing two optimizations:
</p><ul><li><p>Register allocation</p></li><li><p>Elimination of integer type assertions</p></li></ul></p><p>Each of these optimizations is based on a corresponding <span class="emph">analysis</span>:</p><ul><li><p>Liveness Analysis to determine the interference graph for register allocation</p></li><li><p>Possible Values Analysis to determine if a value is guaranteed to be a (tagged) integer.</p></li></ul><p>To support these analyses, the SSA datatypes have been extended with a new generic type parameter <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Ana</code></span>, standing for "Analysis", with every program point containing an element of this type.</p><h3 class="heading">1<tt>&nbsp;</tt><a name="(part._.Register_.Allocation)"></a>Register Allocation<span class="button-group"><a href="#(part._.Register_.Allocation)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>The incorporation of register allocation into the compiler is broken down into several tasks:</p><ul><li><p>Liveness Analysis</p></li><li><p>Construction of the interference graph and the perfect elimination ordering</p></li><li><p>Coloring the interference graph using Chaitin&rsquo;s algorithm</p></li><li><p>Adapting code generation to use the provided coloring</p></li></ul><p>You will implement the first three of these in <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">backend.rs</code></span>. The <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Emitter</code></span> has already been extended to us the output of the prevoius passes.</p><h4 class="heading">1.1<tt>&nbsp;</tt><a name="(part._.Liveness_.Analysis)"></a>Liveness Analysis<span class="button-group"><a href="#(part._.Liveness_.Analysis)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>Liveness analysis is implemented as methods in the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">LivenessAnalyzer</code></span>. The liveness analysis is an iterative reverse dataflow analysis. The <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">LivenessAnalyzer</code></span> struct contains two fields <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">previous</code></span> and <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">current</code></span> which keep track of what variables are live in each basic block in the program. You need to implement the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">LivenessAnalyzer::analyze_prog</code></span> method, which fills in the liveness information for the program, using <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">previous</code></span> as a starting point, and updating the information for the basic blocks in <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">current</code></span>.</p><h4 class="heading">1.2<tt>&nbsp;</tt><a name="(part._.Conflict_.Analysis_and_.Elimination_.Ordering)"></a>Conflict Analysis and Elimination Ordering<span class="button-group"><a href="#(part._.Conflict_.Analysis_and_.Elimination_.Ordering)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The output of the liveness analysis feeds into the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">ConflictAnalysis</code></span>. This traverses a program annotated with liveness information and constructs two pieces of data: an <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">interference</code></span> graph and a perfect elimination <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">order</code></span> of the vertices. The interference graph should include all in the program that are subject to register allocation<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._1._assignmentoptimizations%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">The only variables not subject to register allocation are function block parameters and extern parameters</span></span> as vertices, and an edge if the variables cannot be assigned to the same register. The perfect elimination ordering is an ordering of all of these variables in the program. A perfect elimination order can be constructed by ordering the variables in scope/dominance order: if <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> is already in scope when <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">y</code></span> is defined, then <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> should occur earlier than <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">y</code></span> in the ordering.</p><h4 class="heading">1.3<tt>&nbsp;</tt><a name="(part._.Graph_.Coloring)"></a>Graph Coloring<span class="button-group"><a href="#(part._.Graph_.Coloring)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The final step of the register allocation is graph coloring, implemented in the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">RegisterAllocator</code></span> struct. This contains fields for the register assignment you are constructing as well as the next available spill offset. You will implement the graph coloring algorithm in <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">RegisterAllocator::chaitin</code></span> described in class, removing the nodes from the graph and recursively coloring the sub-graph before adding the node back and coloring it.</p><h3 class="heading">2<tt>&nbsp;</tt><a name="(part._.Assertion_.Removal)"></a>Assertion Removal<span class="button-group"><a href="#(part._.Assertion_.Removal)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>The second optimization we perform is <span class="emph">type assertion removal</span>. Specifically, we are removing assertions of the form <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">AssertInt(imm)</code></span> when we can be sure at runtime that <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">imm</code></span> is a tagged integer, i.e., that it is <span class="emph">even</span>.
For simplicity, the analysis you implement is an <span class="emph">intraprocedural</span> analysis, meaning we assume that any function call, whether to external or internal functions, can always produce arbtitrary values.</p><p>The assertion removal optimization is implemented in <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">middle_end.rs</code></span>, and is run on the SSA code produced by <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Lowerer::lower_prog</code></span>.</p><h4 class="heading">2.1<tt>&nbsp;</tt><a name="(part._.Possible_.Values_.Analysis)"></a>Possible Values Analysis<span class="button-group"><a href="#(part._.Possible_.Values_.Analysis)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>The possible values analysis is a <span class="emph">forward</span> dataflow analysis based on a lattice of <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">PossibleValuesEnv</code></span>ironments. A <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">PossibleValuesEnv</code></span> is a finite map from variables to <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">PossibleValues</code></span>, where a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">PossibleValues</code></span> is an abstraction of a set of possible 64-bit integers. The cases of <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">PossibleValues</code></span> are</p><ul><li><p><span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Any</code></span>, representing the set of all possible 64-bit integer values</p></li><li><p><span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Even</code></span>, representing the set of even 64-bit integer values, i.e., the set of tagged integer values</p></li><li><p><span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">None</code></span>, representing the empty set. This occurs when a variable is never set, which in our well-formed SSA IR can only happen in dead code.</p></li></ul><p>These are ordered by subset inclusion: <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">None</code></span> is less than <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Even</code></span> is less than <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Any</code></span>. <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">PossibleValuesEnv</code></span>ironments lift this ordering to maps: an environment <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">e1</code></span> is less than an environment <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">e2</code></span> if for every <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">x |-&gt; p1</code></span> in <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">e1</code></span>, <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">x |-&gt; p2</code></span> in <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">e2</code></span> and <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">p1</code></span> is less than <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">p2</code></span>. If the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">HashMap</code></span> does not contain a key <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">x</code></span>, then this is considered equivalent to mapping <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">x |-&gt; None</code></span>.</p><p>The possible values analysis assigns a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">PossibleValuesEnv</code></span> to every program point by storing it in the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">ana</code></span> fields of the constructors. This works by an iterative procedure: the program is initialized with the assumption that all variables are never set (<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">x |-&gt; None</code></span>) and this is iteratively refined based on analyzing the program until reaching a fixed point.</p><p>The starter code provides much of the infrastructure of this analysis, in <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">AssertionRemover::analyze</code></span>, as well as the cases for function blocks, basic blocks and terminators. You need to complete the cases for <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">BlockBody</code></span> as well as lattice operations for <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">PossibleValues</code></span> and <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">PossibleValuesEnv</code></span>.</p><h4 class="heading">2.2<tt>&nbsp;</tt><a name="(part._.Assertion_.Removal)"></a>Assertion Removal<span class="button-group"><a href="#(part._.Assertion_.Removal)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h4><p>After the program has been annotated with possible values information, the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">AssertionRemover::remove_assertions</code></span> function you implement should traverse the program and remove assertions that are guaranteed to succeed by the dataflow analysis.</p><h3 class="heading">3<tt>&nbsp;</tt><a name="(part._.Updated_.Command_.Line_.Interface)"></a>Updated Command Line Interface<span class="button-group"><a href="#(part._.Updated_.Command_.Line_.Interface)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>The command-line interface has been extended significantly to enable you to run your compiler with different optimizations and inspect intermediate states of your analyses.</p><p><p>There are two new flags that let you tune the optimizations:
</p><ul><li><p>The <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">-O</code></span> flag lets you specify which optimizations to run. These include "ar" for your assertion removal pass, as well as "cp" (Copy Propagation) and "dce" (Dead Store Elimination/Parameter Dropping) that we have provided.</p></li><li><p>The <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">-R</code></span> flag lets you specify what registers to use in register allocation. Setting this to "none" will spill all variables, similar to compilers for the previous assignments.</p></li></ul></p><p>Additionally, there are new targets you can pass to <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">-t</code></span> to output the intermediate states of your register allocator.</p><h3 class="heading">4<tt>&nbsp;</tt><a name="(part._.Testing_and_.Performance_.Evaluation)"></a>Testing and Performance Evaluation<span class="button-group"><a href="#(part._.Testing_and_.Performance_.Evaluation)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>As of the initial release, we have provided some extra public tests for stress testing your compiler. For example, we have provided a tail recursive loop example that in the reference solution exhibits a nearly 5x speedup when assertion removal and register allocation are implemented correctly. You can use this as a benchmark for performance evaluation.</p><p>When the autograder is released we will provide additional public tests that test for the soundness and precision of your analyses.</p><h3 class="heading">5<tt>&nbsp;</tt><a name="(part._.Starter_.Code_and_.Deliverables)"></a>Starter Code and Deliverables<span class="button-group"><a href="#(part._.Starter_.Code_and_.Deliverables)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>This assignment&rsquo;s starter code includes a full implemtation of the frontend, and much of the scaffolding of the middle end.</p><p><p>For this assignment you will submit your updated versions of two files:
</p><ul><li><p>src/middle_end.rs</p></li><li><p>src/backend.rs</p></li></ul></p><p>You can inspect <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">src/ssa.rs</code></span> to see how cases for analysis annotations have been added to the SSA AST, and <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">src/ana.rs</code></span> has been added which defines some types (<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">LiveSet</code></span>, <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Graph</code></span>, <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Nil</code></span>, and <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">PerfectEliminationOrder</code></span>) that are used in your analyses.</p><p>These are the only files that you can change in your submission, your
code will be linked with reference versions of the other files.</p><p>We&rsquo;ve included a script <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">mk_submission.sh</code></span> in the starter code
repo that should make zip file with just those three files and your
testing files that you should upload to gradescope. The testing files
are included for us to get some idea of how students are testing their
code, they are not graded.</p><h3 class="heading">6<tt>&nbsp;</tt><a name="(part._.Grading_.Standards)"></a>Grading Standards<span class="button-group"><a href="#(part._.Grading_.Standards)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><p>Your compiler will be tested on the
</p><ul><li><p>Soundness of your optimizations: you never assign conflicting variables the same register and you never remove assertions that may fail.</p></li><li><p>Precision of your analyses: your analyses are effective at finding assertions that can be removed safely and your register allocation doesn&rsquo;t spill excessively.</p></li></ul></p><a name="(part._(gentag._0._assignmentoptimizations))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._1._assignmentoptimizations))"></a>1</span></span>The only variables not subject to register allocation are function block parameters and extern parameters</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>