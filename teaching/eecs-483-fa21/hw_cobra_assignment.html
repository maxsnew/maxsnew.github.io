<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Assignment 4: Cobra: Multiple types of values</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 4:</span> Cobra:<span class="mywbr"> &nbsp;</span> Multiple types of values</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.The_.Cobra_.Language%29" class="tocviewlink" data-pltdoc="x">The Cobra Language</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Examples%29" class="tocviewlink" data-pltdoc="x">Examples</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Implementation_strategies%29" class="tocviewlink" data-pltdoc="x">Implementation strategies</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Recommended_.T.O.D.O_.List%29" class="tocviewlink" data-pltdoc="x">Recommended TODO List</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Running_main%29" class="tocviewlink" data-pltdoc="x">Running main</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.List_of_.Deliverables%29" class="tocviewlink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#%28part._.Grading_.Standards%29" class="tocviewlink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="#%28part._.Submission%29" class="tocviewlink" data-pltdoc="x">Submission</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="AssignmentNum">Assignment 4:</span> Cobra:<span class="mywbr"> &nbsp;</span> Multiple types of values</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Cobra_.Language%29" class="tocsubseclink" data-pltdoc="x">The Cobra Language</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Concrete_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Concrete Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Abstract_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Abstract Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Semantics%29" class="tocsubseclink" data-pltdoc="x">Semantics</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Examples%29" class="tocsubseclink" data-pltdoc="x">Examples</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Implementation_strategies%29" class="tocsubseclink" data-pltdoc="x">Implementation strategies</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Rendering_errors%29" class="tocsubseclink" data-pltdoc="x">Rendering errors</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Memory_.Layout_and_.Calling_.C_.Functions%29" class="tocsubseclink" data-pltdoc="x">Memory Layout and Calling C Functions</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._.New_.Assembly_.Constructs%29" class="tocsubseclink" data-pltdoc="x">New Assembly Constructs</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#%28part._.Some_software_engineering_considerations%29" class="tocsubseclink" data-pltdoc="x">Some software engineering considerations</a></td></tr><tr><td><span class="tocsublinknumber">3.5<tt>&nbsp;</tt></span><a href="#%28part._.Testing_.Functions%29" class="tocsubseclink" data-pltdoc="x">Testing Functions</a></td></tr><tr><td><span class="tocsublinknumber">3.5.1<tt>&nbsp;</tt></span><a href="#%28part._.Unit_testing_parts_of_the_compiler%29" class="tocsubseclink" data-pltdoc="x">Unit testing parts of the compiler</a></td></tr><tr><td><span class="tocsublinknumber">3.5.2<tt>&nbsp;</tt></span><a href="#%28part._.Integration_testing_the_compiler%29" class="tocsubseclink" data-pltdoc="x">Integration testing the compiler</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Recommended_.T.O.D.O_.List%29" class="tocsubseclink" data-pltdoc="x">Recommended TODO List</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Running_main%29" class="tocsubseclink" data-pltdoc="x">Running main</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.List_of_.Deliverables%29" class="tocsubseclink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._.Grading_.Standards%29" class="tocsubseclink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td><span class="tocsublinknumber">8<tt>&nbsp;</tt></span><a href="#%28part._.Submission%29" class="tocsubseclink" data-pltdoc="x">Submission</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="AssignmentNum">Assignment 4:</span> Cobra: Multiple types of values</h2><p><h4 class="due">Due: Thurs 02/06 at 8:59pm</h4></p><p><p class="git-clone"><code><span class="kw">git clone </span><input onclick="this.select();" readonly="readonly" value="https://github.ccs.neu.edu/cs4410/starter-cobra"/></code></p></p><p><span style="font-style: italic">In this compiler, you&rsquo;ll deal with COded Binary RepresntAtions of values.</span>
<p style="text-align: center"><img class="titleimage" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/Indian_Cobra.JPG/1920px-Indian_Cobra.JPG"/></p></p><h3>1<tt>&nbsp;</tt><a name="(part._.The_.Cobra_.Language)"></a>The Cobra Language</h3><h4>1.1<tt>&nbsp;</tt><a name="(part._.Concrete_.Syntax)"></a>Concrete Syntax</h4><p>The concrete syntax of Cobra is very similar to Boa, with a few new additions.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Cobra._prim1)))"></a><span class="bnf-rule">&#8249;prim1&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">!</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">print</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">isbool</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">isnum</span>
<a name="(elem._(bnf-prod._(.Cobra._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">true</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">false</span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">&lt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">&gt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">&lt;=</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">&gt;=</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">==</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">&amp;&amp;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">||</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Cobra._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span></p></blockquote><h4>1.2<tt>&nbsp;</tt><a name="(part._.Abstract_.Syntax)"></a>Abstract Syntax</h4><p>The abstract syntax is very similar to Boa, also:
<div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type prim1 = ...
  | Print
  | IsBool
  | IsNum
  | Not

type prim2 = ...
  | And
  | Or
  | Greater
  | GreaterEq
  | Less
  | LessEq
  | Eq

type 'a expr = ...
  | EBool of bool * 'a</code></pre></div></div></p><h4>1.3<tt>&nbsp;</tt><a name="(part._.Semantics)"></a>Semantics</h4><p>The semantics of booleans are straightforward.  The semantics of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EIf</code></span>
changes slightly: its condition must evaluate to a boolean, and it branches on
the truth or falsehood of that value, rather than whether it&rsquo;s nonzero.</p><p>With the addition of two types to the language, there are two main changes that
ripple through the implementation:</p><ul><li><p>The representation of values</p></li><li><p>The possibility of errors</p></li></ul><p>There is one other major addition, which is the <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> primitive, discussed
more below.</p><p>The representation of values requires a definition. We&rsquo;ll use the following
representations for the Cobra runtime:</p><ul><li><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span> will be represented as the constant
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0xFFFFFFFFFFFFFFFF</code></span>. (<span style="font-weight: bold">NOTE:</span> in class, we only specified the outermost bits; this is <span style="font-style: italic">mandating</span> that the middle bits all be set, too.)</p></li><li><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span> will be represented as the constant
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x7FFFFFFFFFFFFFFF</code></span>. (<span style="font-weight: bold">NOTE:</span> in class, we only specified the outermost bits; this is <span style="font-style: italic">mandating</span> that the middle bits all be set, too.)</p></li><li><p>numbers will be represented with a zero in the rightmost bit, by shifting
them left 1 bit. So, for example, 2 is represented as <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x0000000000000004</code></span>.</p></li></ul><p>You should augment the provided <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">print</code></span> function in <code>main.c</code> to print
these values correctly: <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span> should print as those words,
and numbers should print out as the underlying number being represented.</p><p>You should raise errors in the following cases:</p><ul><li><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">-</code></span>, <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">+</code></span>, <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">*</code></span>, <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">add1</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">sub1</code></span> should raise an error (by
printing it out) with the substring <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">"arithmetic expected a number"</code></span> if the
operation&rsquo;s argument(s) are not numbers.  You can print more information than
this if you like, but the message must have at least this substring.</p></li><li><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">&lt;</code></span>, <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">&lt;=</code></span>, <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">&gt;</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">&gt;=</code></span> should raise an error with the
substring <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">"comparison expected a number"</code></span> if the arguments are not both numbers.</p></li><li><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">+</code></span>, <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">-</code></span>, <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">*</code></span>, <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">add1</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">sub1</code></span> should raise an error
with the substring <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">"overflow"</code></span> if the result overflows, and falls outside
the range representable in 63 bits. The <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jo</code></span> instruction will be useful: it
jumps if the last instruction overflowed.</p></li><li><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> should raise an error with the substring <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">"if expected a boolean"</code></span>
if the conditional value is not a boolean.</p></li><li><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">and</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">or</code></span> should should short-circuit if their left
argument determines the answer fully, without evaluating or tag-checking the
right argument.  Otherwise, they should raise an error with the substring
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">"logic expected a boolean"</code></span> if the arguments are not both booleans.</p></li><li><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">not</code></span> should raise an error with the substring <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">"logic expected
a boolean"</code></span> if its argument is not a boolean.</p></li><li><p><span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">==</code></span> should work polymorphically, regardless of the types of its inputs.</p></li></ul><p>These error messages should be printed on standard error. The other operators
never fail, and so never produce errors.</p><p>We add two new primitive operations, <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">isbool</code></span> and <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">isnum</code></span>.  These two
operations have an effective type of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Any -&gt; Bool</code></span>, and will return
<span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span> if the argument they receive is indeed a boolean or number,
respectively.</p><p>The last required primitive operation is <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span>, which prints its single
argument to the command line, and then returns it.  The <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">print</code></span> function in
<code>main.c</code> explicitly returns its argument; you will need to retrieve and
use that value in your compiled output.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Examples)"></a>Examples</h3><ol><li><p>The expression</p><p><div class="sourceCodeWrapper"><span data-label="Cobra" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = 1 in
let y = print(x + 1) in
print(y + 2)</code></pre></div></div></p><p>will output
<div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">2
4
4</code></pre></div></div></p><p>The first 2 comes from the first <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> expression. The first 4 comes from the
second <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> expression. The final line prints the answer of the program as
usual, so there&rsquo;s an &ldquo;extra&rdquo; 4.</p></li><li><p>The expression</p><p><div class="sourceCodeWrapper"><span data-label="Cobra" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if 54: true else: false</code></pre></div></div></p><p>prints (on standard error) something like:</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">Error: expected a boolean in if, got 54</code></pre></div></div></p></li></ol><h3>3<tt>&nbsp;</tt><a name="(part._.Implementation_strategies)"></a>Implementation strategies</h3><h4>3.1<tt>&nbsp;</tt><a name="(part._.Rendering_errors)"></a>Rendering errors</h4><p>To display error messages on standard error, you&rsquo;ll need to use a call something like:</p><p><div class="sourceCodeWrapper"><span data-label="C/C++" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-csrc" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">fprintf(stderr, "Error: expected a number");</code></pre></div></div></p><p>I recommend that you design a function <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">void error(int errCode)</code></span> in
<code>main.c</code>, that handles all errors in uniform manner.  Then, you should add
a suffix to your generated assembly (i.e., change what goes in
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">compile_anf_to_string</code></span>) that looks something like:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">err_arith_not_num:
  mov RDI, &lt;whatever your error code for arithmetic-op-didn't-get-numbers is&gt;
  call error</code></pre></div></div></p><p>You are welcome to make this signature more elaborate, to pass the mistaken
value into the error handler so that it can be printed as part of the error
message.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Memory_.Layout_and_.Calling_.C_.Functions)"></a>Memory Layout and Calling C Functions</h4><p>In order to set up the stack properly to call C functions, like <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">print</code></span> and your
error functions, it&rsquo;s necessary to make a few changes to what we had in Boa.</p><ul><li><p> Allocating stack space ahead of time: At the start of our generated code
(which we now recognize is a function body participating in a C runtime stack),
we need to make sure we make enough stack space for all variables we create,
and reserve that space ahead of time. To do this, we move <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> to point to a
location that is N words away (so N * 8 bytes for us), where N is the greatest
number of variables we need at once. This is actually tricky to compute to be
fully optimal (teaser for later in the semester: by "tricky" I mean NP-hard),
but it&rsquo;s easy to get an OK heuristic &#8212;<wbr></wbr> we can compute the maximum depth of
nested definitions.</p><p>To do this, we need the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">count_vars</code></span> function.  This is a straightforward
function and not very interesting right now, so I&rsquo;ve provided it. You need to
add instructions to compiled output in order to make sure the correct space is
allocated on the stack by subtracting the right amount from <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span>.  You may
choose to implement this via a simple increment of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span>, or you may choose
to explicitly <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push</code></span> an appropriate number of zeros onto the stack, to
clear out any uninitialized values.  (The former is more efficient; the latter
might be helpful for debugging.)</p></li><li><p>Using the Base Pointer: In addition, this means that all variable
references need to happen from <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> rather than from <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span>. This is
because <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> can change while we are pushing arguments onto the stack for
other function calls, so RBP is the place we should trust for consistent
offsets.</p></li><li><p>Participating in the C stack: As a C function callee (from <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">main</code></span>) and
caller (of <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">error</code></span> functions and <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">print</code></span>), our code has some
responsibilities. First, we need to store the old base pointer upon entry, and
update the base pointer to hold the current top of the stack (which includes
the return pointer into main, for example). This is why the typical top two
lines of most C functions are:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push RBP
mov RBP, RSP</code></pre></div></div></p><p>Similarly, when we&rsquo;re done with the function, we need to restore the stack
pointer to its old location, and put the old base pointer value back. This is
why the last lines before a <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">ret</code></span> in a C function are often:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RSP, RBP
pop RBP</code></pre></div></div></p></li><li><p>Other Responsibilities: If we were using registers beyond <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>,
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span>, and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span>, we&rsquo;d be responsible for storing some of them as
callee, and some as caller. But we&rsquo;re not going to go into those details for
this assignment. Since we aren&rsquo;t using those registers, it has no effect on our
code&rsquo;s behavior.</p></li></ul><p>If you write any functions in <code>main.c</code> that you need to be available in
your assembly, you need to declare them in the assembly via:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">;; In your generated assembly
extern &lt;exported name of function&gt;</code></pre></div></div></p><p>They <span style="font-style: italic">also</span> need to be declared in <code>main.c</code> such that the compiler won&rsquo;t
mangle their names, via</p><p><div class="sourceCodeWrapper"><span data-label="C/C++" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-csrc" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">// In main.c
extern &lt;your function signature here&gt; asm("exported name of function");</code></pre></div></div></p><p>If you forget either of these, your code will not link correctly.</p><h4>3.3<tt>&nbsp;</tt><a name="(part._.New_.Assembly_.Constructs)"></a>New Assembly Constructs</h4><ul><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Sized</code></span>: You may run into errors that report that the size of an
operation is ambiguous. This could happen if you write, for example:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp [RBP-8], 0</code></pre></div></div></p><p>because the assembler doesn&rsquo;t know if the program should compare a four-byte
zero, a one-byte zero, or something in between into memory starting at
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">[RBP-8]</code></span>. To solve this, you can supply a size:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp [RBP-8], QWORD 0</code></pre></div></div></p><p>The <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">QWORD</code></span> keyword tells the assembler to use the "quad word" size for 0,
which corresponds to 64 bits. A <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">WORD</code></span> corresponds to 16 bits, a <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">BYTE</code></span>
corresponds to 8 bits, and a <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">DWORD</code></span> corresponds to 32 bits. To get a sized
argument, you can use the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Sized</code></span> constructor from <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">arg</code></span>.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">HexConst</code></span>: Sometimes it&rsquo;s nice to read things in hex notation as
opposed to decimal constants. I&rsquo;ve provided a new <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">HexConst</code></span> arg that&rsquo;s useful
for this case, and augmented <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">arg_to_asm</code></span> for you to support it.  It has the
same meaning as <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Const</code></span>, and just prints out differently.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">IPush</code></span>, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">IPop</code></span>: These two instructions manage values on the
stack. <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push</code></span> adds a value at the current location of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span>, and
decrements <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> to point past the added value (remember, the stack grows
toward numerically-smaller addresses, even though we draw it as
growing upward in diagrams). <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">pop</code></span> increments
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> and moves the value at the location <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> was pointing to into
the provided arg.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ICall</code></span>: A <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span> does two things:</p><ul><li><p>Pushes the next code location onto the stack (just like a <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push</code></span>), which becomes the return pointer</p></li><li><p>Performs an unconditional jump to the provided label</p></li></ul><p>Note that <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span> does not affect <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span>, which the program must maintain on its
own.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">IShr</code></span>, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">IShl</code></span>, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ISar</code></span>: Bit shifting operations.  <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sar</code></span>
(shift-arithmetic-right) preserves the sign bit of the value being shifted,
while <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">shr</code></span> (shift-right) simply fills in a zero bit.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">IAnd</code></span>, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">IOr</code></span>, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">IXor</code></span>: Bitwise logical operations.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ITest</code></span>: Performs a bitwise-and of the two arguments, and records
whether the result was zero, signed, or overflowed.  This can be used in tandem
with jumps like <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jo</code></span> or <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jz</code></span>.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">IJo</code></span>, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">IJno</code></span>: Jump to the provided label if the last arithmetic
operation did/did not overflow</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ILineComment</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">IInstrComment</code></span>: these allow you to add a
comment on a line by itself, or in-line after an instruction.  These might be
helpful for readability of your generated output, while you&rsquo;re debugging.</p></li></ul><h4>3.4<tt>&nbsp;</tt><a name="(part._.Some_software_engineering_considerations)"></a>Some software engineering considerations</h4><p>Our compiler is getting sufficiently sophisticated that the pipeline is several
stages long already.  Bugs can occur in almost any stage of the pipeline.  As a
result, one very useful debugging trick is to engineer the compiler to
<span style="font-style: italic">save</span> each stage of the pipeline, and print them all out if requested.
Until now, our compiler has produced a string, or thrown an exception.  We have
already seen the use of the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">('a, 'b) result</code></span> type to return either an
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Ok</code></span> value or an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Error</code></span> message.  In <code>phases.ml</code>, I&rsquo;ve combined
these ideas for you.</p><p><p>First, the file contains several constructors for naming each phase of the
compiler, and it defines an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a pipeline</code></span> to be a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">result</code></span> containing
either
</p><ul><li><p>An <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a</code></span> answer, paired with a list of phases describing how we got
here; or</p></li><li><p>A list of exceptions, paired with a list of phases describing how far
we&rsquo;d gotten in compilation</p></li></ul><p>The <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a</code></span> part of the answer is whatever the most recent compiler phase
produced as its result.</p></p><p>Next, I&rsquo;ve defined a few helper functions to add a new phase onto a growing
pipeline.  Look carefully at the type for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">add_phase</code></span>: it takes a function
that transforms an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a</code></span> into a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'b</code></span>, and an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a pipeline</code></span>, and
produces a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'b pipeline</code></span> as a result...and turns the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'b</code></span> answer into a
phase and adds it to the growing list.  <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">add_phase</code></span> should be used for
phases of the compiler that you don&rsquo;t expect to ever fail: any exceptions that
arise are internal compiler errors.  By contrast <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">add_err_phase</code></span> takes a
function that takes the current <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a</code></span> result and produces an
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">('b, exn list) result</code></span>, that is, it might reasonably produce error messages.</p><p>To use these functions, look at the end of <code>compile.ml</code>:
<div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let compile_to_string (prog : sourcespan program pipeline) : string pipeline =
  prog
  |&gt; (add_phase well_formed check_scope)
  |&gt; (add_phase tagged tag)
  |&gt; (add_phase renamed rename)
  |&gt; (add_phase anfed (fun p -&gt; tag (anf p)))
  |&gt; (add_phase result compile_prog)
;;</code></pre></div></div></p><p>The <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">|&gt;</code></span> operator is reverse function application: <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">x |&gt; f</code></span> is the exact
same thing as <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(f x)</code></span>, but it allows us to write pipelines in a neatly
chained form.</p><p>You are welcome to add phases to your compiler, should you wish to.</p><p>Finally, look at <code>main.ml</code>.  If you run <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">./main -t yourFile.cobra</code></span>,
the compiler will print out the trace of the entire pipeline.  If you leave out
the <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">-t</code></span> option, it will print the output assembly just as before.</p><h4>3.5<tt>&nbsp;</tt><a name="(part._.Testing_.Functions)"></a>Testing Functions</h4><h5>3.5.1<tt>&nbsp;</tt><a name="(part._.Unit_testing_parts_of_the_compiler)"></a>Unit testing parts of the compiler</h5><p>These are the same as they were for Boa. ANF is provided, and hasn&rsquo;t changed
aside from the addition of new primitives and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EBool</code></span>. So your tests should
focus on <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">te</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">t</code></span> tests.</p><p>If your program exits with -10 as its exit code, it probably has segfaulted,
meaning it tried to access memory that was not allocated.  If you&rsquo;re familiar
with tools like valgrind, you can run <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">valgrind output/some_test.run</code></span> in
order to get a little more feedback. This can sometimes tip you off quite well
as to how memory is off, since sometimes you&rsquo;ll see code trying to jump to a
constant that&rsquo;s in your code, or other obvious tells that there&rsquo;s something off
in the stack. Also, if you&rsquo;ve done all your stack management correctly,
valgrind will report a clean run for your program!<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._11._assignmentcobra%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">You may need to
install the <code>libc6-dbg</code> package.</span></span></p><h5>3.5.2<tt>&nbsp;</tt><a name="(part._.Integration_testing_the_compiler)"></a>Integration testing the compiler</h5><p>In addition to the unit-testing functions, I have added some structure to the
<code>input/</code> directory, and added support for this in your <code>test.ml</code>
file.  There are now four subdirectories:</p><ul><li><p><code>input/do_pass</code>: should contain programs that do indeed compile
through your compiler and run correctly.</p></li><li><p><code>input/do_err</code>: should contain programs that do indeed produce
compile or runtime errors</p></li><li><p><code>input/dont_pass</code>: should contain programs that you think
<span style="font-style: italic">should</span> work properly, but that your compiler doesn&rsquo;t currently compile
correctly</p></li><li><p><code>input/dont_err</code>: should contain programs that you think
<span style="font-style: italic">should</span> produce compile or runtime errors, but that your compiler
compiles for some reason</p></li></ul><p>To specify the intended output or error messages of these programs, read the
<code>README</code> files in each directory that explains what files you should
create.</p><p>Finally, the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">input_file_test_suite ()</code></span> in <code>test.ml</code> will run all the
programs in your <code>input/</code> directory as part of your oUnit test suite.  I
suspect this will be a much easier way to produce larger-scale test cases than
writing everything in <code>test.ml</code> directly.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Recommended_.T.O.D.O_.List)"></a>Recommended TODO List</h3><p>Here&rsquo;s an order in which you could consider tackling the implementation:</p><ol><li><p>Fix the <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">print</code></span> function in <code>main.c</code> so that it prints out the right output. It will need to check for the tag using C bitwise operators, and use <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">printf</code></span> or one of its variants to print the right value.</p></li><li><p>Take a first shot at figuring out how to increase the stack appropriately by using <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">count_vars</code></span>.</p></li><li><p>Fill in the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPrim1</code></span> case for everything but <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span>, and figure out how to check for errors, and call the "non-number" error reporting function. Test as you go. Be aware that if the function call segfaults, it may be because you need to refine step 2.</p></li><li><p>Implement compiling <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> to assembly by pushing appropriate
arguments, then <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span>ing <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">print</code></span>. Be aware that if the call doesn&rsquo;t
work, it may be because of step 2 again. Test as you go; be aware that you
should test interesting sequences of print expressions and let-bindings to make
sure your stack integrity is good before and after calls.</p></li><li><p>Fill in all of the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPrim2</code></span> cases, using the error-reporting from the last step. Test as you go.</p></li><li><p>Complete the if case and test as you go.</p></li></ol><h3>5<tt>&nbsp;</tt><a name="(part._.Running_main)"></a>Running main</h3><p>Running your own programs is the same as with Boa, except you&rsquo;ll give them
the <code>.cobra</code> file extension.</p><p>You can also use the <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">-t</code></span> command-line flag (described above) to print
out a trace of the compilation process.</p><h3>6<tt>&nbsp;</tt><a name="(part._.List_of_.Deliverables)"></a>List of Deliverables</h3><ul><li><p>your <code>compile.ml</code></p></li><li><p>any additional modules you saw fit to write</p></li><li><p>tests in an OUnit test module (<code>test.ml</code>)</p></li><li><p>any test input programs (<code>input/*.cobra</code> files or <code>input/*/*</code> subdirectories)</p></li><li><p>any additional files that are needed to build your tests (e.g. <code>main.c</code>, etc)</p></li></ul><p><span style="font-weight: bold">Again, please ensure the makefile builds your code properly.
The black-box tests will give you an automatic 0 if they cannot compile your code!</span></p><p><span style="font-weight: bold">DO NOT SUBMIT YOUR <code>.git</code> DIRECTORY!</span>  For that matter, don&rsquo;t submit
your <code>output</code> or <code>_build</code> directories.</p><h3>7<tt>&nbsp;</tt><a name="(part._.Grading_.Standards)"></a>Grading Standards</h3><p><p>For this assignment, you will be graded on
</p><ul><li><p>Whether your code implements the specification (functional correctness),</p></li><li><p>the clarity and cleanliness of your code, and</p></li><li><p>the comprehensiveness of your test coverage</p></li></ul></p><h3>8<tt>&nbsp;</tt><a name="(part._.Submission)"></a>Submission</h3><p><p><span style="font-weight: bold">Wait!</span> Please read the assignment again and verify that you have not forgotten anything!</p></p><p>Please submit your homework to <a href="https://handins.ccs.neu.edu/"><span class="url">https://handins.ccs.neu.edu/</span></a> by the above deadline.</p><a name="(part._(gentag._10._assignmentcobra))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._11._assignmentcobra))"></a>1</span></span>You may need to
install the <code>libc6-dbg</code> package.</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>