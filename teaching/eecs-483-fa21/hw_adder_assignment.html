<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Assignment 2: Adder: A starter language</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="racket.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 2:</span> Adder:<span class="mywbr"> &nbsp;</span> A starter language</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.The_.Adder_.Language%29" class="tocviewlink" data-pltdoc="x">The Adder Language</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Starter_code_for_this_assignment%29" class="tocviewlink" data-pltdoc="x">Starter code for this assignment</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Implementing_a_.Compiler_for_.Adder%29" class="tocviewlink" data-pltdoc="x">Implementing a Compiler for Adder</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.List_of_.Deliverables%29" class="tocviewlink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Grading_.Standards%29" class="tocviewlink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.Submission%29" class="tocviewlink" data-pltdoc="x">Submission</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="AssignmentNum">Assignment 2:</span> Adder:<span class="mywbr"> &nbsp;</span> A starter language</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Adder_.Language%29" class="tocsubseclink" data-pltdoc="x">The Adder Language</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Concrete_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Concrete Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Abstract_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Abstract Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Semantics%29" class="tocsubseclink" data-pltdoc="x">Semantics</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Starter_code_for_this_assignment%29" class="tocsubseclink" data-pltdoc="x">Starter code for this assignment</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Implementing_a_.Compiler_for_.Adder%29" class="tocsubseclink" data-pltdoc="x">Implementing a Compiler for Adder</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Writing_the_.Compiler%29" class="tocsubseclink" data-pltdoc="x">Writing the Compiler</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Testing_the_.Compiler%29" class="tocsubseclink" data-pltdoc="x">Testing the Compiler</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._.Running_main%29" class="tocsubseclink" data-pltdoc="x">Running main</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.List_of_.Deliverables%29" class="tocsubseclink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Grading_.Standards%29" class="tocsubseclink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.Submission%29" class="tocsubseclink" data-pltdoc="x">Submission</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="AssignmentNum">Assignment 2:</span> Adder: A starter language</h2><p><h4 class="due">Due: Tue 01/21 at 8:59pm</h4></p><p><p class="git-clone"><code><span class="kw">git clone </span><input onclick="this.select();" readonly="readonly" value="https://github.ccs.neu.edu/cs4410/starter-adder"/></code></p></p><p><span style="font-weight: bold">Note:</span> The starter code for this assignment contains answers for the
previous assignment.  If you are taking a late day on that assignment, you must
not view this code until you have completed the previous one.</p><p><span style="font-weight: bold">Note:</span> You will be working with partners on this assignment.  Make sure
that you&rsquo;ve
<a href="http://www.ccs.neu.edu/home/blerner/handin-server/handin-server-guide.html#%28part._request-teammates%29">requested
a team</a> on <a href="https://handins.ccs.neu.edu/"><span class="url">https://handins.ccs.neu.edu/</span></a> well before the deadline, so that
we can approve the team.  Working solo is not allowed.  Also, if either member
of a team is enrolled in CS6410 (graduate), you will be graded at the graduate level,
rather than the undergrad level.  If you are working in a team of three, you
will also be graded at the graduate level.</p><p><p style="text-align: center"><img class="titleimage" src="https://upload.wikimedia.org/wikipedia/commons/2/28/Loch_Shin_adder.JPG"/></p></p><p>In this assignment you&rsquo;ll implement a compiler for a small language called
Adder (because it primarily adds things).</p><p><span style="font-weight: bold">Reminder:</span> Test names cannot have spaces; this is due to the way the <code>Makefile</code> relies
on test names being used for filenames.</p><h3>1<tt>&nbsp;</tt><a name="(part._.The_.Adder_.Language)"></a>The Adder Language</h3><p>In each of the next several assignments, we&rsquo;ll introduce a language that we&rsquo;ll
implement.  We&rsquo;ll start small, and build up features incrementally.  We&rsquo;re
starting with Adder, which has just a few features &#8212;<wbr></wbr> defining variables, and
primitive operations on numbers.</p><p>There are a few pieces that go into defining a language for us to compile.</p><ul><li><p>A description of the concrete syntax &#8212;<wbr></wbr> the text the programmer writes</p></li><li><p>A description of the abstract syntax &#8212;<wbr></wbr> how to express what the
programmer wrote in a data structure our compiler uses.</p></li><li><p>The <span style="font-style: italic">semantics</span> &#8212; or description of the behavior &#8212; of the abstract
syntax, so our compiler knows what the code it generates should do.</p></li></ul><h4>1.1<tt>&nbsp;</tt><a name="(part._.Concrete_.Syntax)"></a>Concrete Syntax</h4><p>The concrete syntax of Adder is:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Adder._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">NUMBER</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class="bnf-lit">let</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._bindings%29%29%29" data-pltdoc="x">&#8249;bindings&#8250;</a></span> <span class="bnf-lit">)</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class="bnf-lit">add1</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class="bnf-lit">sub1</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Adder._bindings)))"></a><span class="bnf-rule">&#8249;bindings&#8250;</span><span class="bnf-meta">:</span> 
                  <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
                  <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Adder._bindings%29%29%29" data-pltdoc="x">&#8249;bindings&#8250;</a></span></p></blockquote><p>Here, a <span title="Adder" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let</code></span> expression can have one <span style="font-style: italic">or more</span> bindings.  An
<span class="bnf-lit bnf-unknown">IDENTIFIER</span> is any non-empty sequence of
letters and digits (starting with a letter).  Any <span class="bnf-lit">highlighted</span> text is a literal token, meaning the programmer must
type exactly those characters or keywords.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Abstract_.Syntax)"></a>Abstract Syntax</h4><p>The abstract syntax of Adder is an OCaml datatype, and corresponds nearly
one-to-one with the concrete syntax.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type prim1 =
  | Add1
  | Sub1

type 'a expr =
  | Number of int64 * 'a
  | Prim1 of prim1 * 'a expr * 'a
  | Let of (string * 'a expr) list * 'a expr * 'a
  | Id of string * 'a</code></pre></div></div></p><h4>1.3<tt>&nbsp;</tt><a name="(part._.Semantics)"></a>Semantics</h4><p>An Adder program always evaluates to a single integer.  <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Number</code></span>s evaluate to
themselves (so a program just consisting of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Number(5L)</code></span> should evaluate to the
integer <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">5L</code></span>).  Primitive expressions perform addition or subtraction by one on
their argument.  Let bindings should evaluate all the binding expressions to
values one by one, and after each, store a mapping from the given name to the
corresponding value in both (a) the rest of the bindings, and (b) the body of
the let expression.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._16._assignmentadder%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">If you are familiar with Racket, this is the
<a href="https://docs.racket-lang.org/guide/let.html#%28part._.Sequential_.Binding__let_%29">semantics
of <span class="RktSym">let*</span></a>, although we are enforcing a constraint that the names be
unique.</span></span>  Identifiers evaluate to whatever their current stored
value is.  There are several examples further down to make this concrete.</p><p>The compiler should signal an error if:</p><ul><li><p>There is a binding list containing two or more bindings with the same name</p></li><li><p>An identifier is unbound (there is no surrounding let binding for it)</p></li></ul><p>Here are some examples of Adder programs:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Concrete Syntax</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Abstract Syntax</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Answer</p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Adder" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">5</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Number(5L)</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>5</code></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Adder" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(sub1 (add1 (sub1 5)))</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Prim1(Sub1, Prim1(Add1, Prim1(Sub1, Number(5L))))</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>4</code></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Adder" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(let ((x 5))
   (add1 x))</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Let([("x", Number(5L))],
    Prim1(Add1, Id("x")))</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>6</code></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Adder" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(let ((x 5)
      (y (sub1 x)))
  (sub1 y))</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Let([("x", Number(5L));
     ("y", Prim1(Sub1, Id("x")))],
    Prim1(Sub1, Id("y")))</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>3</code></p></td></tr></table></p><h3>2<tt>&nbsp;</tt><a name="(part._.Starter_code_for_this_assignment)"></a>Starter code for this assignment</h3><p>You&rsquo;ve been given a starter codebase that has several pieces of
infrastructure:</p><ul><li><p>A parser for s-expressions (<code>sexp.ml</code>), which takes concrete syntax
(text files) and turns it into instances of the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">sexp</code></span> datatype.  You
don&rsquo;t need to edit this, but you should compare it to your prior
homework, both to confirm that your homework was correct, and to
understand how it works.</p></li><li><p>A main program (<code>main.ml</code>) that uses the parser and compiler to produce
assembly code from an input Adder text file.  You don&rsquo;t need to edit this.</p></li><li><p>A <code>Makefile</code> that builds <code>main.ml</code>, builds a tester for Adder that you will
modify (<code>test.ml</code>), and manipulates assembly programs created by the Adder
compiler.  You don&rsquo;t need to edit the <code>Makefile</code>, but you will edit
<code>test.ml</code>.</p></li><li><p>An OCaml program (<code>runner.ml</code>) that works in concert with the <code>Makefile</code> to
allow you to compile and run an Adder program from within OCaml, which is
quite useful for testing.  You don&rsquo;t need to edit <code>runner.ml</code>.</p></li></ul><p>All of your edits &#8212;<wbr></wbr> which will be to write the compiler for Adder, and test
it &#8212;<wbr></wbr> will happen in <code>test.ml</code> and <code>compile.ml</code>.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Implementing_a_.Compiler_for_.Adder)"></a>Implementing a Compiler for Adder</h3><h4>3.1<tt>&nbsp;</tt><a name="(part._.Writing_the_.Compiler)"></a>Writing the Compiler</h4><p>The primary task of writing the Adder compiler is simple to state: take an
instance of the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">expr</code></span> datatype and turn it into a list of assembly
instructions.  The provided compiler skeleton is set up to do just this,
broken up over a few functions.</p><p>The first is</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">compile : pos expr -&gt; instruction list</code></pre></div></div></p><p>which takes a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">expr</code></span> value (abstract syntax, tagged with source location
information) and turns it into a list of assembly instructions, represented by
the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">instruction</code></span> type.  Use only the provided instruction types for this
assignment; we will be gradually expanding this set of instructions as the
semester progresses.  This function has an associated helper that takes some
extra arguments to track the variable environment and stack offset.</p><p>The other component you need to implement is:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">to_asm_string : instruction list -&gt; string</code></pre></div></div></p><p>which renders individual instances of the instruction datatype into a string
representation of the instruction (this is done for you for <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov</code></span>).
This second step is straightforward, but forces you to understand the syntax
of the assembly code you are generating.  Most of the compiler concepts happen
in the first step, where we are generating assembly instructions from abstract
syntax.  Do use <a href="http://www.cs.virginia.edu/~evans/cs216/guides/x86.html">this assembly
guide</a> &#8212;<wbr></wbr> or ask! &#8212;<wbr></wbr> if you have questions about the concrete syntax of an instruction.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Testing_the_.Compiler)"></a>Testing the Compiler</h4><p>The test file has two helper functions that will be useful to you:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">t : string -&gt; string -&gt; string -&gt; OUnit.test</code></pre></div></div></p><p>The first string given to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">t</code></span> (test) is a test name, followed by an adder
program (in concrete syntax) to compile and evaluate, followed by a string for
the expected output of the program (this will just be an integer in quotes).
This helper compiles, links, and runs the given program, and if the compiler
ends in error, it will report the error message as a string.  This includes
problems building at the assembler/linker level, as well as any explicit
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">failwith</code></span> statements in the compiler itself.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">te : string -&gt; string -&gt; string -&gt; OUnit.test</code></pre></div></div></p><p>The first string given to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">te</code></span> (test-error) is a test name, followed by a
program in concrete syntax to compile and evaluate, followed by a string that
is a <span style="font-style: italic">substring of the expected error message</span>.  For example, in the
starter code there is a test that fails with the substring <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">"not yet"</code></span>,
because the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Let</code></span> case fails with an exception that mentions it is
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">"not yet implemented"</code></span>.  You <span style="font-style: italic">should</span> use this helper to explicitly test for
the two error cases mentioned above.  Your compiler should generate such errors
by calling <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">raise</code></span><span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._17._assignmentadder%29%29" data-pltdoc="x">2</a></span></span><span class="FootnoteContent">Calling <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">failwith "some string"</code></span> function in
OCaml is equivalent to calling <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">raise (Failure "some string")</code></span> &ndash; that is,
it fails with a very generic <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Failure</code></span> type of exception.  You can define
your own exception types, allowing for more fine-grained error handling than if
everything were just a single, simple <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Failure</code></span> exception.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._18._assignmentadder%29%29" data-pltdoc="x">3</a></span></span><span class="FootnoteContent">If you stop
to think about it for a bit, this error type is rather weird: all other data
types in OCaml have a finite set of constructors that are enumerated in a
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type</code></span> definition, but these exceptions can be declared anywhere in your
program, and do not have an <span style="font-style: italic">a priori</span> known finite set... It takes
special work in OCaml&rsquo;s type system to support this, and the exception type is
the <span style="font-style: italic">only</span> type for which this is true.</span></span></span></span>  on some value of the
appropriate exception type (which we have provided for you) and with an
appropriately descriptive and distinctive message.</p><p>Both of these functions store the assembly file your compiler generated in the
<code>output/</code> directory, with the name of the test suffixed by <code>.s</code>, if
it was possible to generate.  So, for example, the starter tests generate a
file called <code>test1.s</code> in the <code>output/</code> directory, containing the
compiled code for that case (assuming the file parses and the compiler even
gets to run &ndash; right now, the starter code doesn&rsquo;t quite get that far).  This
can be useful for debugging.  If you hand-edit a generated assembly file (to
tweak it for an attempted fix), you can then run:</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ make output/test1.run</code></pre></div></div></p><p>to trigger the build from that assembly file.  This can be helpful if you
think you&rsquo;re generating mostly-correct code, but just want to try a small edit
to fix something up.  It&rsquo;s also helpful if you want to hand-write a small
assembly example: you can create <code>.s</code> files from scratch in the <code>output</code>
directory to experiment with, if you want to practice with assembly
instructions without the compiler in the way.</p><p>For files that built completely, the generated <code>*.run</code> executable is also
stored in <code>output/</code>.</p><p>To run all of your tests, run
<div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ make test
$ ./test</code></pre></div></div></p><h4>3.3<tt>&nbsp;</tt><a name="(part._.Running_main)"></a>Running main</h4><p>The <code>main</code> program built with <code>make main</code> takes a single file as its
command-line argument, and outputs the compiled assembly string on standard
out.  If you want to write files containing Adder code, you can write files in
the <code>input/</code> directory with the suffix <code>.adder</code>, and then run
<code>make output/yourfile.run</code>, which will trigger the same process that happens in
<code>test.ml</code> &#8212;<wbr></wbr> the compiler will run on your adder file, and it will attempt to
link it with <code>main.c</code> to create an executable.  The intermediate files will be
stored in <code>output/yourfile.s</code>, <code>output/yourfile.o</code>, and <code>output/yourfile.run</code>.</p><p>You can run the file by executing:</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ ./output/yourfile.run</code></pre></div></div></p><h3>4<tt>&nbsp;</tt><a name="(part._.List_of_.Deliverables)"></a>List of Deliverables</h3><p><p>At a minimum, you must provide
</p><ul><li><p>your <code>compile.ml</code></p></li><li><p>any additional modules you saw fit to write</p></li><li><p>tests in an OUnit test module (<code>test.ml</code>)</p></li><li><p>any test input programs (<code>input/*.adder</code> files)</p></li></ul></p><p>Preferably, provide a zip containing all the sources of your code (including
the <code>Makefile</code>, <code>runner.ml</code>, <code>sexp.ml</code> and <code>main.ml</code> files)
so that we can simply download your code and run it.  Please do <span style="font-style: italic">not</span>
provide your <code>.git/</code> or <code>_build/</code> directories, or any other extraneous
files!  (The easiest way to ensure this is to run <code>make clean</code> before
archiving your code directory.)</p><p><span style="font-weight: bold">Again, please ensure the makefile builds your code properly.
The black-box tests will give you an automatic 0 if they cannot compile your code!</span></p><h3>5<tt>&nbsp;</tt><a name="(part._.Grading_.Standards)"></a>Grading Standards</h3><p>We have provided you with several starter functions, and they have all been
fully annotated with types.  If you define any additional top-level functions,
please annotate them in the same way.  (Local definitions do not have to be
annotated, but they shouldn&rsquo;t be too hard to decipher, either.)  There are no
formal OCaml style guidelines, though
<a href="https://ocaml.org/learn/tutorials/guidelines.html">ocaml.org</a>
defines some good ones to follow.</p><p><p>For this assignment, you will be graded on
</p><ul><li><p>Whether your code implements the specification (functional correctness),</p></li><li><p>the clarity and cleanliness of your code, and</p></li><li><p>the comprehensiveness of your test coverage</p></li></ul></p><p>(We may attempt to run each of your tests against each of your classmates&rsquo;
compilers.  If so, part of grading your tests will be how well they trip up
bugs in your classmates, while still working properly with our reference
solution.  We don&rsquo;t have this infrastructure set up yet, so this may not happen.)</p><h3>6<tt>&nbsp;</tt><a name="(part._.Submission)"></a>Submission</h3><p><p><span style="font-weight: bold">Wait!</span> Please read the assignment again and verify that you have not forgotten anything!</p></p><p>Please submit your homework to <a href="https://handins.ccs.neu.edu/"><span class="url">https://handins.ccs.neu.edu/</span></a> by the above deadline.</p><a name="(part._(gentag._15._assignmentadder))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._16._assignmentadder))"></a>1</span></span>If you are familiar with Racket, this is the
<a href="https://docs.racket-lang.org/guide/let.html#%28part._.Sequential_.Binding__let_%29">semantics
of <span class="RktSym">let*</span></a>, although we are enforcing a constraint that the names be
unique.</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._17._assignmentadder))"></a>2</span></span>Calling <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">failwith "some string"</code></span> function in
OCaml is equivalent to calling <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">raise (Failure "some string")</code></span> &ndash; that is,
it fails with a very generic <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Failure</code></span> type of exception.  You can define
your own exception types, allowing for more fine-grained error handling than if
everything were just a single, simple <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Failure</code></span> exception.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._18._assignmentadder%29%29" data-pltdoc="x">3</a></span></span><span class="FootnoteContent">If you stop
to think about it for a bit, this error type is rather weird: all other data
types in OCaml have a finite set of constructors that are enumerated in a
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type</code></span> definition, but these exceptions can be declared anywhere in your
program, and do not have an <span style="font-style: italic">a priori</span> known finite set... It takes
special work in OCaml&rsquo;s type system to support this, and the exception type is
the <span style="font-style: italic">only</span> type for which this is true.</span></span></p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._18._assignmentadder))"></a>3</span></span>If you stop
to think about it for a bit, this error type is rather weird: all other data
types in OCaml have a finite set of constructors that are enumerated in a
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type</code></span> definition, but these exceptions can be declared anywhere in your
program, and do not have an <span style="font-style: italic">a priori</span> known finite set... It takes
special work in OCaml&rsquo;s type system to support this, and the exception type is
the <span style="font-style: italic">only</span> type for which this is true.</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>