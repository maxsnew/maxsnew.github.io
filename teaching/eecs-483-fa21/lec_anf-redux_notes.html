<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 8: Revisiting ANF: Encoding A-Normal Form with Types</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 8:</span> Revisiting ANF:<span class="mywbr"> &nbsp;</span> Encoding A-<wbr></wbr>Normal Form with Types</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Defining_.A.N.F_expressions%29" class="tocviewlink" data-pltdoc="x">Defining ANF expressions</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Defining_anf_using_these_types%29" class="tocviewlink" data-pltdoc="x">Defining <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf</code></span> using these types</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Benefits_of_these_types%29" class="tocviewlink" data-pltdoc="x">Benefits of these types</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 8:</span> Revisiting ANF:<span class="mywbr"> &nbsp;</span> Encoding A-<wbr></wbr>Normal Form with Types</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Defining_.A.N.F_expressions%29" class="tocsubseclink" data-pltdoc="x">Defining ANF expressions</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Defining_anf_using_these_types%29" class="tocsubseclink" data-pltdoc="x">Defining <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf</code></span> using these types</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._help.A__obtaining_full_expressions%29" class="tocsubseclink" data-pltdoc="x"><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">help<span class="mywbr"> &nbsp;</span>A</code></span>:<span class="mywbr"> &nbsp;</span> obtaining full expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._help.C__obtaining_compound_expressions%29" class="tocsubseclink" data-pltdoc="x"><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">help<span class="mywbr"> &nbsp;</span>C</code></span>:<span class="mywbr"> &nbsp;</span> obtaining compound expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._help.I__obtaining_immediate_expressions%29" class="tocsubseclink" data-pltdoc="x"><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">help<span class="mywbr"> &nbsp;</span>I</code></span>:<span class="mywbr"> &nbsp;</span> obtaining immediate expressions</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Benefits_of_these_types%29" class="tocsubseclink" data-pltdoc="x">Benefits of these types</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="LectureNum">Lecture 8:</span> Revisiting ANF: Encoding A-Normal Form with Types</h2><p>Our prior implementations of ANF conversion were functions of the form
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf : tag expr -&gt; unit expr</code></span>, that produced a value <span style="font-style: italic">of the same <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">expr</code></span>
data type</span>, but one that happened to satisfy the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">is_anf</code></span> predicate we
defined.  This was certainly expedient:</p><ul><li><p>We didn&rsquo;t need to define new data types,</p></li><li><p>Our intuitions about the semantics of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">expr</code></span> carried over to ANF&rsquo;ed
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">expr</code></span>s,</p></li><li><p>All our utility functions (like pretty-printing) just worked with ANF&rsquo;ed
expressions</p></li><li><p>etc.</p></li></ul><p>But it has downsides, primarily that we lose a lot of the power and guarantees
that ML&rsquo;s type system could provide us.  If we define our types correctly, ML
can assure us that</p><ul><li><p>The result of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf</code></span> is guaranteed to be an expression in A-normal
form,</p></li><li><p>Any functions that do further work on ANF&rsquo;ed expressions are not missing
any steps &#8212;<wbr></wbr> unlike our current ones, which have a catch-all case that throws
an exception claiming that any remaining expressions just aren&rsquo;t ANF.</p></li></ul><p>Let&rsquo;s try to define these types, then revisit the transformation functions.</p><h3>1<tt>&nbsp;</tt><a name="(part._.Defining_.A.N.F_expressions)"></a>Defining ANF expressions</h3><p>Recall our definition of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">is_anf</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec is_anf (e : 'a expr) : bool =
  match e with
  | EPrim1(_, e, _) -&gt; is_imm e
  | EPrim2(_, e1, e2, _) -&gt; is_imm e1 &amp;&amp; is_imm e2
  | ELet(binds, body, _) -&gt;
     List.for_all (fun (_, e, _) -&gt; is_anf e) binds
     &amp;&amp; is_anf body
  | EIf(cond, thn, els, _) -&gt; is_imm cond &amp;&amp; is_anf thn &amp;&amp; is_anf els
  | _ -&gt; is_imm e
and is_imm e =
  match e with
  | ENumber _ -&gt; true
  | EId _ -&gt; true
  | EBool _ -&gt; true
  | _ -&gt; false
;;</code></pre></div></div></p><p>The goal was to ensure that every primitive operation only received
<span style="font-style: italic">immediate</span> operands, which were anything whose value was available
without any further computation: namely, constants and identifiers.  Now, if we
try to define a new expression type for ANF expressions, we&rsquo;ll want to encode
that invariant in the types.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Try to define a new expression type, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a aexpr</code></span>, that describes
this ANF invariant.</p></blockquote><p>It&rsquo;s easiest to start from the immediate values:
<div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a immexpr = (* immediate expressions *)
  | ImmNum of int64 * 'a
  | ImmBool of bool * 'a
  | ImmId of string * 'a</code></pre></div></div></p><p>The next level up from immediate expressions are <span style="font-style: italic">compound</span> expressions,
which will include basically everything else:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(* Attempt #1 *)
type 'a comp_expr =
  | CImmExpr of 'a immexpr                          (* base cases *)
  | CPrim1 of prim1 * 'a immexpr * 'a               (* argument must be immediate *)
  | CPrim2 of prim2 * 'a immexpr * 'a immexpr * 'a  (* arguments must be immediate *)
  | CIf of 'a immexpr * 'a comp_expr * 'a comp_expr (* condition must be immediate *)
  | CLet of (string * 'a comp_expr) list * 'a comp_expr * 'a    (* ugh. *)</code></pre></div></div></p><p>This data definition correctly encodes our stated ANF property, but that
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">CLet</code></span> definition is still pretty unwieldy.  In particular, it permits
multiple bindings within a single <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">CLet</code></span> (because of the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">list</code></span>), and it
allows let-bindings to appear in the binding-expressions themselves.  This in
turn means that our binding expressions can be arbitrarily complex, which
would be nice to avoid, if possible.</p><p>We can correct the multiple bindings part just by removing the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">list</code></span>, but
correcting the other flaw requires a separation of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">comp_expr</code></span> into two
distinct, mutually recursive types:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a cexpr = (* compound expressions *)
  | CIf of 'a immexpr * 'a aexpr * 'a aexpr * 'a
  | CPrim1 of prim1 * 'a immexpr * 'a
  | CPrim2 of prim2 * 'a immexpr * 'a immexpr * 'a
  | CImmExpr of 'a immexpr
and 'a aexpr = (* anf expressions *)
  | ALet of string * 'a cexpr * 'a aexpr * 'a
  | ACExpr of 'a cexpr</code></pre></div></div></p><p>Note in particular that <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ALet</code></span> accepts binding expressions that are
restricted to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">cexpr</code></span>, which cannot itself be a let-binding.  Also notice
that <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">CIf</code></span> expressions contain branches that are <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">aexpr</code></span>s: the branches
might well need let-bindings, but we don&rsquo;t want to execute any of the code for
the branch that isn&rsquo;t taken.  So we can&rsquo;t lift all the let-bindings out of the
if-expressions; we need to permit them to remain inside its branches.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Defining_anf_using_these_types)"></a>Defining <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf</code></span> using these types</h3><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Translate your definition of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf</code></span> to produce values of type
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">unit aexpr</code></span>, instead of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">unit expr</code></span>.  Hint: one of the two versions will
be a much easier starting point than the other...</p></blockquote><p>From <a href="lec_anf_notes.html" data-pltdoc="x"><span class="LectureNum">Lecture 4:</span> Conditionals and A-Normal Form</a>, we have an attempted signature of</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let anf_without_types (e : tag expr) : unit expr =
  let rec help (e : tag expr) : (unit expr * (string * unit expr) list) =
    ...
  in ...</code></pre></div></div></p><p>The intuition behind the return value of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">help</code></span> was to return an answer
expression that was an immediate, followed by a binding-list of ANF&rsquo;ed
expressions that formed the context in which the answer made sense.  We can
translate this into our new types as</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let anf (e : tag expr) : unit aexpr =
  let rec help (e : tag expr) : (unit immexpr * (string * unit aexpr) list) =
    ...
  in ...</code></pre></div></div></p><p>But this type is overly strict.  Consider the <span style="font-style: italic">complete program</span>
<span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">3 + 5</code></span>.  In order to call <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">help</code></span> on this expression, we have to return
an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">unit immexpr</code></span>, which means we need to effectively produce a translated
program of <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let temp = 3 + 5 in temp</code></span>.  But nothing in our definition of
ANF requires that the final expression of our program be an immediate!  We
merely require that all operators have immediate operands.  So we need at least
one helper with a less-stringent signature, to allow us to return non-immediate
answers.  Fortunately, we now have an intermediate type, between &ldquo;all ANF
expressions&rdquo; (<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a aexpr</code></span>) and &ldquo;all immediate expressions&rdquo; (<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a immexpr</code></span>),
namely compound expressions (<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a cexpr</code></span>).</p><p><p>Note that similar analyses holds for the branches of a conditional, and the
right-hand side of a let-binding.  These inform our choices of where to use
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a aexpr</code></span> and where to use <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a cexpr</code></span> in our type definitions above.
</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Complete this analysis, and justify to yourself why the data
definitions above have the desired properties.</p></blockquote></p><p>So, now that we have three types for our ANF expressions instead of just one,
we&rsquo;ll need three mutually recursive functions:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let anf (e : tag expr) : unit aexpr =
  let rec helpA (e : tag expr) : unit aexpr = ...
  and     helpC (e : tag expr) : (unit cexpr * (string * unit cexpr) list) = ...
  and     helpI (e : tag expr) : (unit immexpr * (string * unit cexpr) list) = ...
  in
  helpA e
;;</code></pre></div></div>
Again, our transformation kept track of a <span style="font-style: italic">pair</span> of the &ldquo;answer&rdquo;
expression we wanted, and a list of &ldquo;setup bindings&rdquo; that were needed for the
answer to make sense.  Accordingly, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpC</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpI</code></span> will have similar
signatures, but their answers will be compound or immediate, respectively.  By
contrast, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpA</code></span> produces a complete ANF expression, so its return type has
no need for a setup context.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._help.A__obtaining_full_expressions)"></a><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpA</code></span>: obtaining full expressions</h4><p>The <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpA</code></span> function will be the only one that actually needs to collapse
the setup lists into nested <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ALet</code></span> expressions.  To obtain such a setup
list, it will need to call either <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpC</code></span> or <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpI</code></span> on its argument.  A
single example suffices to show which choice is better:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(* The highlighted expressions are pretty-printed exprs, not ML *)
helpI ~hl:1:s~(1 + 2)~hl:1:e~ ===&gt; ~hl:1:s~let temp = 1 + 2 in temp~hl:1:e~

helpC ~hl:1:s~(1 + 2)~hl:1:e~ ===&gt; ~hl:1:s~1 + 2~hl:1:e~</code></pre></div></div></p><p>Since any <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">cexpr</code></span> can be treated directly as an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">aexpr</code></span> (by using
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ACExpr</code></span>) without introducing any unnecessary temp variables, we&rsquo;d rather
have <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpA</code></span> call <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpC</code></span>. Once it has done so, it obtains an answer and
a setup list.  We need to choose an ordering on that list that we&rsquo;ll use to
define order of execution.  The easiest choice to read is to let the first item
in the list be the first binding to execute.  Accordingly, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpA</code></span> needs to
fold its setup list around the answer, starting from the <span style="font-style: italic">right</span>:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec anfA e : unit aexpr =
  let (ans, ans_setup) = helpC e in
  List.fold_right                                        (* from right to left, *)
    (fun (bind, exp) body -&gt; ALet(bind, exp, body, ()))  (* wrap each binding around the body *)
    ans_setup                                            (* from the list of setup bindings *)
    (ACExpr ans)                                         (* starting from the answer *)</code></pre></div></div></p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Confirm that this definition of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpA</code></span> will produce the claimed
answer above.  Confirm that using <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpI</code></span> instead would produce the other
answer above.</p></blockquote><h4>2.2<tt>&nbsp;</tt><a name="(part._help.C__obtaining_compound_expressions)"></a><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpC</code></span>: obtaining compound expressions</h4><p>We sketch just some of the cases for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpC</code></span>; complete the others as an
exercise.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">and helpC (e : tag expr) : (unit cexpr * (string * unit cexpr) list) =
  match e with
  | EPrim1(op, arg, _) -&gt;
     (* Convert the argument to an immediate *)
     let (arg_imm, arg_setup) = helpI arg in
     (* Produce the appropriate cexpr, along with its context *)
     (CPrim1(op, arg_imm, ()), arg_setup)
  | EPrim2 _
  | EIf _
  | ELet _ -&gt; (* complete these *)
  | _ -&gt; let (imm, setup) = helpI in (CImmExpr imm, setup) (* just wrap the immediate value *)</code></pre></div></div></p><h4>2.3<tt>&nbsp;</tt><a name="(part._help.I__obtaining_immediate_expressions)"></a><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpI</code></span>: obtaining immediate expressions</h4><p>We sketch just some of the cases for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpI</code></span>; complete the others as an
exercise.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">and helpI (e : tag expr) : (unit immexpr * (string * unit cexpr) list) =
  match e with
  | ENumber(n, _) -&gt; (ImmNum(n, ()), [])  (* Immediate values are immediate *)
  | EBool(b, _) -&gt; (ImmBool(b, ()), [])
  | EId(name, _) -&gt; (ImmId(name, ()), [])

  | EPrim1(op, arg, tag) -&gt;
     (* We can't just return CPrim, so create a temp variable *)
     let tmp = sprintf "unary_%d" tag in
     (* Convert the argument *)
     let (arg_imm, arg_setup) = helpI arg in
     (* Return the **temp variable**, but include the CPrim as a new setup binding *)
     (ImmId(tmp, ()), arg_setup @ [(tmp, CPrim1(op, arg_imm, ()))])
  | EPrim2 _
  | EIf _
  | ELet _ -&gt; (* complete these *)</code></pre></div></div></p><h3>3<tt>&nbsp;</tt><a name="(part._.Benefits_of_these_types)"></a>Benefits of these types</h3><p>Simply by compiling this code, ML&rsquo;s <span style="font-style: italic">totality checking</span> will
<span style="font-style: italic">guarantee</span> for us that we&rsquo;ve covered all the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">expr</code></span> cases, in each
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">match</code></span> expression of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpA</code></span>, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpC</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpI</code></span>, which means our
translation didn&rsquo;t miss any expression forms.  This was true of the simpler
transformation last time, too.  However, all subsequent compilation functions
that now work over <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">aexpr</code></span>s <span style="font-style: italic">also</span> get guarantees that we haven&rsquo;t
missed any cases.  With the previous code, our <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">compile</code></span> function would look
something like</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec compile (e : tag expr) si env : instruction list =
 match e with
 | ... (* various cases *)
 | _ -&gt; failwith "Not in ANF"</code></pre></div></div></p><p>This last catch-all case basically precludes ML from telling us we missed a
valid ANF expression, which means we must resort to a thorough test suite to
check whether we ever hit that case unexpectedly.  By contrast, <span style="font-style: italic">every</span>
expression of type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">aexpr</code></span> is, by definition, a valid ANF expression, so we
can avoid this catch-all, and get compile-time checking back.  For a language
as small as ours currently is, this benefit is admittedly small, but as
languages grow to dozens of expression forms or more, having this totality
checking is a very useful safety net.</p><a name="(part._(gentag._42._lectureanf-redux))"></a><p class="FootnoteBlock"></p></div></div><div id="contextindicator">&nbsp;</div></body></html>