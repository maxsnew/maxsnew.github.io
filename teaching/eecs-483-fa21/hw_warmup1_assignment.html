<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Assignment 0: OCaml warmup, part 1: basics</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 0:</span> OCaml warmup, part 1:<span class="mywbr"> &nbsp;</span> basics</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Setup%29" class="tocviewlink" data-pltdoc="x">Setup</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Programming_in_.O.Caml_---_.The_.Basics%29" class="tocviewlink" data-pltdoc="x">Programming in OCaml &#8212;<wbr></wbr> The Basics</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Programming_in_.O.Caml_---_.Datatypes%29" class="tocviewlink" data-pltdoc="x">Programming in OCaml &#8212;<wbr></wbr> Datatypes</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Programming_in_.O.Caml_---_.Lists_and_.Parametric_.Polymorphism%29" class="tocviewlink" data-pltdoc="x">Programming in OCaml &#8212;<wbr></wbr> Lists and Parametric Polymorphism</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Tuples%29" class="tocviewlink" data-pltdoc="x">Tuples</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.The_option_.Type%29" class="tocviewlink" data-pltdoc="x">The <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">option</code></span> Type</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#%28part._.Grading_standards%29" class="tocviewlink" data-pltdoc="x">Grading standards</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="#%28part._.Submission%29" class="tocviewlink" data-pltdoc="x">Submission</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="AssignmentNum">Assignment 0:</span> OCaml warmup, part 1:<span class="mywbr"> &nbsp;</span> basics</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Setup%29" class="tocsubseclink" data-pltdoc="x">Setup</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.O.S.X_.Instructions%29" class="tocsubseclink" data-pltdoc="x">OSX Instructions</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Programming_in_.O.Caml_---_.The_.Basics%29" class="tocsubseclink" data-pltdoc="x">Programming in OCaml &#8212;<wbr></wbr> The Basics</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Simplest_.Program%29" class="tocsubseclink" data-pltdoc="x">The Simplest Program</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Defining_and_.Calling_.Functions%29" class="tocsubseclink" data-pltdoc="x">Defining and Calling Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.Recursive_.Functions%29" class="tocsubseclink" data-pltdoc="x">Recursive Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#%28part._.Testing_with_.O.Unit%29" class="tocsubseclink" data-pltdoc="x">Testing with OUnit</a></td></tr><tr><td><span class="tocsublinknumber">2.5<tt>&nbsp;</tt></span><a href="#%28part._ex~3abasic%29" class="tocsubseclink" data-pltdoc="x">Exercises</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Programming_in_.O.Caml_---_.Datatypes%29" class="tocsubseclink" data-pltdoc="x">Programming in OCaml &#8212;<wbr></wbr> Datatypes</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Binary_.Trees_with_type%29" class="tocsubseclink" data-pltdoc="x">Binary Trees with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type</code></span></a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Manipulating_.Data_with_match%29" class="tocsubseclink" data-pltdoc="x">Manipulating Data with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">match</code></span></a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._e~3atrees%29" class="tocsubseclink" data-pltdoc="x">Exercises</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Programming_in_.O.Caml_---_.Lists_and_.Parametric_.Polymorphism%29" class="tocsubseclink" data-pltdoc="x">Programming in OCaml &#8212;<wbr></wbr> Lists and Parametric Polymorphism</a></td></tr><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.Linked_.Lists__.By_.Hand%29" class="tocsubseclink" data-pltdoc="x">Linked Lists, By Hand</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._.Linked_.Lists__.Built-in%29" class="tocsubseclink" data-pltdoc="x">Linked Lists, Built-<wbr></wbr>in</a></td></tr><tr><td><span class="tocsublinknumber">4.3<tt>&nbsp;</tt></span><a href="#%28part._e~3alists%29" class="tocsubseclink" data-pltdoc="x">Exercises</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Tuples%29" class="tocsubseclink" data-pltdoc="x">Tuples</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.The_option_.Type%29" class="tocsubseclink" data-pltdoc="x">The <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">option</code></span> Type</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._.Grading_standards%29" class="tocsubseclink" data-pltdoc="x">Grading standards</a></td></tr><tr><td><span class="tocsublinknumber">8<tt>&nbsp;</tt></span><a href="#%28part._.Submission%29" class="tocsubseclink" data-pltdoc="x">Submission</a></td></tr><tr><td><span class="tocsublinknumber">8.1<tt>&nbsp;</tt></span><a href="#%28part._.Deliverables%29" class="tocsubseclink" data-pltdoc="x">Deliverables</a></td></tr><tr><td><span class="tocsublinknumber">8.2<tt>&nbsp;</tt></span><a href="#%28part._.Instructions%29" class="tocsubseclink" data-pltdoc="x">Instructions</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="AssignmentNum">Assignment 0:</span> OCaml warmup, part 1: basics</h2><p><h4 class="due">Due: Fri 01/10 at 8:59pm</h4></p><p><p class="git-clone"><code><span class="kw">git clone </span><input onclick="this.select();" readonly="readonly" value="https://github.ccs.neu.edu/cs4410/starter-warmup1"/></code></p></p><p>We will use three programming languages in this course: OCaml, C (not C++), and
x86 assembly.  Depending on your experience so far, you should all have some
background in C and possibly x86, and the C we use won&rsquo;t be surprising.  You
may not have seen OCaml before, and warrants an introduction.</p><p>This writeup serves as both a reference for some of the OCaml topics we&rsquo;ll
need in the course, and your first assignment.  You should do all the numbered
<span style="font-weight: bold">Exercises</span> throughout the document for your first assignment.</p><h3>1<tt>&nbsp;</tt><a name="(part._.Setup)"></a>Setup</h3><p><span class="NoteBox"><span class="NoteContent"><a href="https://opam.ocaml.org/">OPAM</a> is a package manager for OCaml.
If you know of <code>pip</code> or <code>easy_install</code> for Python, it&rsquo;s the same idea.</span></span>
OCaml is installed on the department machines, but you need to do a small bit
of setup to use some libraries we&rsquo;ll need for the course.  Assuming you&rsquo;re
using Bash as your shell, open up the file
<code>.bashrc</code> in your home directory (with e.g. <code>emacs ~/.bashrc</code>), and add
these lines at the bottom:</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">eval `opam config env`
. /usr/local/opam/opam-init/init.sh</code></pre></div></div></p><p>Then run:</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ source ~/.bashrc</code></pre></div></div></p><p>(In this and all subsequent assignments, the <code>$</code> indicates the command
prompt; you do not type that character!) This makes it so each time you open a
terminal, the build commands you run for OCaml will be able to use some
libraries we need for the course.</p><p><span class="NoteBox"><span class="NoteContent"><a href="https://github.com/ocaml/opam/issues/2870#issuecomment-523172995">This
bug</a> will be <a href="https://github.com/ocaml/opam/pull/3886">fixed in
OPAM 2.0.6</a>, I hope.</span></span>  <span style="font-weight: bold">Warning!</span> If you are using the Fish shell with
OPAM versions 2.0.5 or lower, setting up OPAM will possibly clobber your
<code>MANPATH</code> environment variable, such that trying to run <code>man
&lt;anything&gt;</code> will fail.  Run <code>opam config var prefix</code> to find out the path
where OPAM has installed your current setup.  (On my machine, that gives
<code>/home/blerner/.opam/4.09.0</code>.)  Within that directory, edit the file
<code>.opam-switch/environment</code>, and comment out the line that sets
<code>MANPATH</code> with a <span title="Shell" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">#</code></span>.  You will need to redo this step every time
you run an <code>opam install</code> or <code>opam update</code> command.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._.O.S.X_.Instructions)"></a>OSX Instructions</h4><p>If you want to work on your OSX laptop, you can install OCaml and OPAM
via <a href="http://brew.sh/">Homebrew</a> first, then install the necessary
packages manually:</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ brew install ocaml opam
$ opam init
# this takes a while
$ opam install extlib ounit
# follow the directions for setting up your environment for opam, then
# the Makefile should work for you</code></pre></div></div></p><p><span class="NoteBox"><span class="NoteContent">Sorry, it&rsquo;s not feasible for me to support Windows, BSD, or any other
more exotic platforms.  You&rsquo;re free to try building things on those platforms,
but make sure your assignments run on the department machines before
submitting.</span></span> The assignments should work on either OSX or on the department
machines; I&rsquo;ll do my best to support both and note any exceptions as time goes
on.  When in doubt, use a department machine.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Programming_in_.O.Caml_---_.The_.Basics)"></a>Programming in OCaml &#8212;<wbr></wbr> The Basics</h3><p>This section covers some basics first, and then gives a structured
introduction to how we&rsquo;ll program in OCaml in this course.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._.The_.Simplest_.Program)"></a>The Simplest Program</h4><p>OCaml files are written with a <code>.ml</code> extension.  An OCaml file is somewhat
similar to a Python file: when run, it evaluates the file directly (unlike,
for example, C++, which designates a special <code>main</code> function).
An OCaml file consists of</p><ul><li><p>(Optionally) a series of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">open</code></span> statements for including other modules</p></li><li><p>A series of declarations for defining datatypes, functions, and
constants</p></li><li><p>A series of (though often just one) toplevel expressions to evaluate.</p></li></ul><p>For example:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">open Printf

let message = "Hello world";;
(printf "%s\n" message)</code></pre></div></div></p><p>The first line includes the built-in library for printing, which provides
functions similar to <code>fprintf</code> and <code>printf</code> from <code>stdlib</code> in C.  The
next two lines define a constant named <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">message</code></span>, and then call the
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">printf</code></span> function with a format string (where <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">%s</code></span> means &#8220;format as
string&#8221;), and the constant <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">message</code></span> we defined on the line before.</p><p>Put this in a file called <code>hello.ml</code> and run it with:</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ ocaml hello.ml
Hello world</code></pre></div></div></p><p>Most of our programs will be more complex than this, and much of the
infrastructure for the &#8220;main&#8221; function will be provided, but it&rsquo;s useful to
see the simplest case first.</p><h4>2.2<tt>&nbsp;</tt><a name="(part._.Defining_and_.Calling_.Functions)"></a>Defining and Calling Functions</h4><p>One thing that we&rsquo;ll do over and over again is define functions.  Here&rsquo;s an
example of a function definition in OCaml:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let max (n : int) (m : int) : int =
  if n &gt; m then n else m;;</code></pre></div></div></p><p>It uses the keyword <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let</code></span> followed by the name of the function (here,
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">max</code></span>).  Next comes the parameter list.  Each parameter is enclosed in
parentheses, and has the parameter&rsquo;s name, then a colon, then its type.  So
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">n</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">m</code></span> are the parameters of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">max</code></span>, and they are both type
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">int</code></span>.  The final colon followed by <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">int</code></span> describes the return type of
the function.  Then there is an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">=</code></span> sign, followed by the function body.</p><p>This declaration is similar to the following in C/C++/Java:</p><p><div class="sourceCodeWrapper"><span data-label="Java" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">int max(int n, int m) {
  if(n &gt; m) { return n; }
  else { return m; }
}</code></pre></div></div></p><p>One notable difference is that the OCaml function does not have any
<span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">return</code></span> statements.  We&rsquo;ll talk about how to think about the &#8220;return&#8221;
value of a function without <span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">return</code></span> statements next.  It&rsquo;s also important
to note that the declaration in OCaml ends in <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">;;</code></span>.  This is a required
syntactic convention for all top-level declarations in OCaml.</p><p><span class="NoteBox"><span class="NoteContent">We&rsquo;ll get to a more robust notion of testing in a little bit.</span></span>
We can check that <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">max</code></span> works by defining a useful top-level call with
print statements:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">open Printf

let max (n : int) (m : int) : int =
  if n &gt; m then n else m;;

(printf "Should be 5: %d\n" (max 5 4));
(printf "Should be 4: %d\n" (max 3 4));
(printf "Should be 4: %d\n" (max 4 4));</code></pre></div></div></p><p>You can copy this program into a file called <code>max.ml</code> and run it with
<code>ocaml max.ml</code>.</p><p>There are a few things to explain here.  First, the syntax for function calls
in OCaml is different than you may be used to.  Instead of writing</p><p><div class="sourceCodeWrapper"><span data-label="Java" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">some_function(arg1, arg2, ...)

// for example

max(4, 5)</code></pre></div></div></p><p><span class="NoteBox"><span class="NoteContent">The surrounding parentheses can be omitted in some cases, but it&rsquo;s
always safe to include them to be clear.</span></span>
as we would in C++ or Python, in OCaml we write</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(some_function arg1 arg2 ...)

(* for example *)

(max 4 5)</code></pre></div></div></p><p><span class="NoteBox"><span class="NoteContent">This is just a useful model; everything you know about stacks and memory
diagrams is still true (and in fact, we&rsquo;ll talk about stacks in quite a bit of
detail this semester).  But substitution is a very helpful model for reasoning
in the style of programming we&rsquo;ll do.</span></span>
That&rsquo;s just a syntactic difference.  There&rsquo;s also a useful distinction in how
I prefer to think about what happens when we call a function in OCaml.  Rather
than thinking about a call to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">max</code></span> creating a new stack frame, let&rsquo;s think
about what happens if we <span style="font-style: italic">substitute</span> the provided argument values for
the parameters in the body of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">max</code></span>, and continue by evaluating the
function body.</p><p>So, for example, the call to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">max</code></span> below <span style="font-style: italic">takes a step</span> to the
substituted form:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">   (max 4 5)

=&gt; if 4 &gt; 5 then 4 else 5</code></pre></div></div></p><p>Then we can think about how the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">if</code></span> expression takes steps.  First, it
evaluates the conditional part, and based on that value being <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">true</code></span> or
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">false</code></span>, it evaluates one or the other branch:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">   if 4 &gt; 5 then 4 else 5

=&gt; if false then 4 else 5

=&gt; 5</code></pre></div></div></p><p>From this sequence of steps, we say that <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(max 4 5)</code></span> <span style="font-style: italic">evaluates to</span>
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">5</code></span>.  This gives us a way to think about evaluation that doesn&rsquo;t require a
notion of a <span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">return</code></span> statement.</p><p>With this idea of substitution in mind, we can think about how the sequence of
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">printf</code></span> expressions we wrote will evaluate:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">  (printf "Should be 5: %d\n" (max 5 4));
  (printf "Should be 4: %d\n" (max 3 4));
  (printf "Should be 4: %d\n" (max 4 4));

=&gt; (printf "Should be 5: %d\n" (if 5 &gt; 4 then 5 else 4));
   (printf "Should be 4: %d\n" (max 3 4));
   (printf "Should be 4: %d\n" (max 4 4));

=&gt; (printf "Should be 5: %d\n" (if true then 5 else 4));
   (printf "Should be 4: %d\n" (max 3 4));
   (printf "Should be 4: %d\n" (max 4 4));

=&gt; (printf "Should be 5: %d\n" 5);
   (printf "Should be 4: %d\n" (max 3 4));
   (printf "Should be 4: %d\n" (max 4 4));</code></pre></div></div></p><p><span class="NoteBox"><span class="NoteContent">The rule for semicolon-separated sequences is that they are evaluated in
order, and the value resulting from each expression is ignored once it is
done.</span></span>
<div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">=&gt; &lt;internal-to-OCaml-printing of "Should be 5: 5\n"&gt;;
   (printf "Should be 4: %d\n" (max 3 4));
   (printf "Should be 4: %d\n" (max 4 4));

=&gt; (printf "Should be 4: %d\n" (max 3 4));
   (printf "Should be 4: %d\n" (max 4 4));

=&gt; (printf "Should be 4: %d\n" (if 3 &gt; 4 then 3 else 4));
   (printf "Should be 4: %d\n" (max 4 4));

=&gt; (printf "Should be 4: %d\n" (if false then 3 else 4));
   (printf "Should be 4: %d\n" (max 4 4));

=&gt; (printf "Should be 4: %d\n" 4);
   (printf "Should be 4: %d\n" (max 4 4));

=&gt; &lt;internal-to-OCaml-printing of "Should be 4: 4\n"&gt;;
   (printf "Should be 4: %d\n" (max 4 4));

... and so on</code></pre></div></div></p><h4>2.3<tt>&nbsp;</tt><a name="(part._.Recursive_.Functions)"></a>Recursive Functions</h4><p><span class="NoteBox"><span class="NoteContent">This is because, as we&rsquo;ll see, there are lots of trees to process in a
compiler, and trees have a fundamentally recursive structure.</span></span>
A lot of the code we write this semester will be recursive
functions.  OCaml distinguishes between functions that can contain recursive
calls and functions that cannot.  We saw the latter kind above in <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">max</code></span>
which simply used the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let</code></span> keyword.  We can define a recursive function by
using <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec factorial (n : int) : int =
  if n &lt;= 1 then 1
  else n * (factorial (n - 1));;</code></pre></div></div></p><p>The substitution-based rules are a little more interesting when thinking about
evaluating a call to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">factorial</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">  (factorial 3)

=&gt; (if 3 &lt;= 1 then 1 else 3 * (factorial (3 - 1)))

=&gt; (if false then 1 else 3 * (factorial (3 - 1)))

=&gt; (3 * (factorial (3 - 1)))

=&gt; (3 * (factorial 2))

=&gt; (3 * (if 2 &lt;= 1 then 1 else 2 * (factorial (2 - 1)))

...

=&gt; (3 * (2 * (factorial (2 - 1))))

...

=&gt; (3 * (2 * 1))

=&gt; 6</code></pre></div></div></p><p>Here, we can see the chained multiplications &#8220;stack up&#8221; during the recursive
calls.  Writing this in a substitution-based style makes it easy to track
where the return values of function calls end up.</p><h4>2.4<tt>&nbsp;</tt><a name="(part._.Testing_with_.O.Unit)"></a>Testing with OUnit</h4><p>Testing by printing values becomes pretty onerous when we want to write more
than a few examples.  In this course, we&rsquo;ll use a library called
<a href="http://ounit.forge.ocamlcore.org/api-ounit/index.html">OUnit</a> to write
tests.</p><p>With OUnit, we will write declarations in one file, and test them in another.
The code provided in your checkout has two files: <code>functions.ml</code>, which
you&rsquo;ll fill in with some implementations in the rest of the exercises, and
<code>test.ml</code>, which will contain tests.  This will become a common layout for
how we write our programs in this course.</p><p><span class="NoteBox"><span class="NoteContent">The weird-looking <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">&gt;::</code></span> operator is described
<a href="http://ounit.forge.ocamlcore.org/api-ounit/OUnit2.html#VAL(&gt;::)">here</a>
in terms of more basic concepts, if you&rsquo;re interested.  It&rsquo;s just a shorthand
for constructing a test value with a name.</span></span>
A test in OUnit is a name paired with a function of one argument.  The
function uses one of several different test predicates to check a
computation; the one we&rsquo;ll use most commonly is <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">assert_equal</code></span>.  The syntax
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">&gt;::</code></span> is used to combine the name and the function together into a test.
Here&rsquo;s an example:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">open OUnit2
let check_fun _ = (* a function of one argument *)
  assert_equal (2 + 2) 4;;

let my_first_test = "my_first_test"&gt;::check_fun;;</code></pre></div></div></p><p><span class="NoteBox"><span class="NoteContent">Most of this is just boilerplate that you won&rsquo;t have to think much, if
at all, about.  But it&rsquo;s useful to explain it once.</span></span> Now <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">my_first_test</code></span> is
a named test value.  <span style="font-weight: bold">Please be careful</span> not to use spaces in test names,
because running the test suite will produce one log file per test, and those files
will have spaces in their names, which may cause some headaches.</p><p>Note that we used an underscore when defining the
parameter of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">check_fun</code></span>; we can use an underscore to indicate to OCaml
that we don&rsquo;t care about the argument (there needs to be a parameter because
of how the testing library works, even though we won&rsquo;t use the parameter).  We
can run our test by creating a suite out of a list of tests,<span class="NoteBox"><span class="NoteContent">Again, please
avoid spaces in the suite name.</span></span> and running the suite:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let suite = "suite"&gt;:::[my_first_test];;
run_test_tt_main suite</code></pre></div></div></p><p><span class="NoteBox"><span class="NoteContent">The command used is not <code>ocaml</code> in this case,
but a wrapper around <code>ocaml</code> called <code>ocamlfind</code> that knows how to search
your system for packages installed with e.g. OPAM. Candidly, OCaml&rsquo;s build
system can be a little onerous, so I&rsquo;m not teaching it explicitly.  If you
want to use OCaml for a large project outside this course, I recommend
learning about the <code>corebuild</code> tool that comes with Real World OCaml.</span></span>
To build and run the given skeleton, use the provided Makefile that does the
work of building for you.  In this case, you just need to run</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ make test
$ ./test</code></pre></div></div></p><p>in order to run the tests.</p><p>We can also add tests that fail to see what happens:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let check_fun2 _ = (* a failing test *)
  assert_equal (2 + 2) 5;;

let my_second_test = "my_second_test"&gt;::check_fun2;;</code></pre></div></div></p><p>If we add this test to the suite and run, we get a failure:</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ ./test
.F
==============================================================================
Error: suite:1:my_second_test.

File "/Users/joe/.../oUnit-suite-prob#02.log", line 2, characters 1-1:
Error: suite:1:my_second_test (in the log).

Raised at file "src/oUnitAssert.ml", line 45, characters 8-27
Called from file "src/oUnitRunner.ml", line 46, characters 13-26

not equal
------------------------------------------------------------------------------
Ran: 2 tests in: 0.14 seconds.
FAILED: Cases: 2 Tried: 2 Errors: 0 Failures: 1 Skip:  0 Todo: 0 Timeouts: 0.</code></pre></div></div></p><p>This output identifies the failing test by name (my_second_test), though it
doesn&rsquo;t tell us much more than that.  Another annoying thing about the way we
wrote those tests is that defining a new function for every test causes
significant extra typing.  To get a little more information out, we can pass
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">assert_equal</code></span> an optional argument that specifies how to turn the values
under test into a string for printing.  We can bundle that up inside a
function that creates the test with its name.  So, for example, we can define
a function that creates tests comparing integers to integers:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let t_int name value expected = name&gt;::
  (fun _ -&gt; assert_equal expected value ~printer:string_of_int);;

let my_third_test = t_int "my_third_test" (2 + 2) 7;;
let my_fourth_test = t_int "my_fourth_test" (2 + 2) 4;;</code></pre></div></div></p><p>If we add these two tests to the suite, we see a much more useful failure
report that says <code>expected: 7 but got: 4</code>.  I&rsquo;ll often provide useful
helper functions for testing with examples, but you may also decide to write
your own for different kinds of tests as the semester goes on.</p><p>(<span style="font-weight: bold">Note:</span> the funny <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">~printer:</code></span> syntax is a
<a href="https://caml.inria.fr/pub/docs/u3-ocaml/ocaml051.html#toc23"><span style="font-style: italic">labeled
argument</span></a>, and is a mechanism for passing arguments by <span style="font-style: italic">name</span> rather than
just by <span style="font-style: italic">position</span>.  Functions must be defined to expect labeled
arguments; you can&rsquo;t simply assume that an arbitrary argument happens to have a
name.  Additionally, labeled arguments might be <span style="font-style: italic">optional</span>, and there
might be a default value supplied for them.  Labeled, optional arguments are
prohibited from being the <span style="font-style: italic">final</span> argument for a function (why?)  If you
want to supply a different value-to-string converter for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">assert_equal</code></span>,
you&rsquo;d need to write <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">~printer:your_function_here</code></span>.)</p><h4>2.5<tt>&nbsp;</tt><a name="(part._ex~3abasic)"></a>Exercises</h4><div class="hw"><ol><li><p>Implement <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">fibonacci</code></span> as an OCaml function that takes an integer
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">n</code></span> and returns the <span type="math/tex" style="white-space: pre;" class="math-tex">\(n^{th}\)</span> Fibonacci number.  Write out the evaluation of
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(fibonacci 3)</code></span> in substitution style.</p></li><li><p>Write tests for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">max</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">fibonacci</code></span> using <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">t_int</code></span>.</p></li></ol></div><h3>3<tt>&nbsp;</tt><a name="(part._.Programming_in_.O.Caml_---_.Datatypes)"></a>Programming in OCaml &#8212;<wbr></wbr> Datatypes</h3><p>Programming with only integers, we wouldn&rsquo;t make much progress on building a
compiler.  The next thing we need to do is understand how to create new
<span style="font-style: italic">datatypes</span> in OCaml, and program with them.</p><h4>3.1<tt>&nbsp;</tt><a name="(part._.Binary_.Trees_with_type)"></a>Binary Trees with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type</code></span></h4><p>Let&rsquo;s start with a datatype we all ought to know well: binary trees.  We
know we&rsquo;ll need to represent a binary tree node somehow, which has a value and
two children.  For now, let&rsquo;s say the value has to be a string.  In OCaml, we
can define such a node using the keyword <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type btnode =
  | Leaf
  | Node of string * btnode * btnode</code></pre></div></div></p><p>Translated into English, this reads:</p><blockquote><p> A binary tree node is either a <span style="font-style: italic">leaf</span> of the
tree, which has no fields, or a <span style="font-style: italic">node</span>, which has three fields: a string,
a binary tree node, and another binary tree node.  </p></blockquote><p>This defines what we call <span style="font-style: italic">constructors</span> for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Leaf</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Node</code></span>,
which we can use to construct trees.  Here are a few examples of trees and
their corresponding <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">btnode</code></span> value:</p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"a"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Node("a",</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">/</span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">\</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Node("b", Leaf, Leaf), Node("c", Leaf, Leaf))</span></p></td></tr><tr><td><p><span class="stt">"b"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"c"</span></p></td></tr></table></p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"a"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Node("a",</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">/</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Node("b", Leaf, Leaf), Leaf)</span></p></td></tr><tr><td><p><span class="stt">"b"</span></p></td></tr></table></p><p><table cellspacing="0" cellpadding="0" class="SVerbatim"><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"a"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Node("a",</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">/</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Node("b",</span></p></td></tr><tr><td><p><span class="stt">"b"</span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">Leaf, Node("c", Leaf, Leaf)), Leaf)</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;</span><span class="stt">\</span></p></td></tr><tr><td><p><span class="stt"></span><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="stt">"c"</span></p></td></tr></table></p><p><span class="NoteBox"><span class="NoteContent">In C++ implementation of binary trees, we would commonly use <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">NULL</code></span> to
represent a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Leaf</code></span>; in Fundies 2 or OOD, we would likely use a dedicated
<span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">Leaf</code></span> class instead.  Unlike <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">NULL</code></span> in C++, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Leaf</code></span> can only be a
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">btnode</code></span> and can never be confused for a value of some other type.</span></span>  Each
position with no child corresponds to a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Leaf</code></span>, and the others correspond to
uses of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Node</code></span>.  We call <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Leaf</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Node</code></span> <span style="font-style: italic">variants</span> of the
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">btnode</code></span> <span style="font-style: italic">type</span>.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Manipulating_.Data_with_match)"></a>Manipulating Data with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">match</code></span></h4><p>The next question is how to work with these values.  For example, how can we
construct an in-order concatenation of the strings in a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">btnode</code></span> as we&rsquo;ve
defined it?  That is, how do we fill in this function:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec inorder_str (btn : btnode) : string =
  ...</code></pre></div></div></p><p>The next feature we need to introduce is <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">match</code></span>, which allows us to
examine which variant of a type a particular value has, and extract the values
of its fields.  Here are some examples:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let m1 = match Leaf with
  | Leaf -&gt; true
  | Node(s, left, right) -&gt; false;;

(* m1 is true *)

let m2 = match Leaf with
  | Leaf -&gt; 44
  | Node(s, left, right) -&gt; 99;;

(* m2 is 44 *)

let m3 = match Node("a", Leaf, Leaf) with
  | Leaf -&gt; "z"
  | Node(s, left, right) -&gt; s;;

(* m3 is "a" *)

let m4 = match Node("a", Node("b", Leaf, Leaf), Leaf) with
  | Leaf -&gt; "z"
  | Node(s, left, right) -&gt;
    match left with
      | Leaf -&gt; "y"
      | Node(s2, left2, right2) -&gt; s2;;

(* m4 is "b" *)</code></pre></div></div></p><p>From these examples, we can see how <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">match</code></span> must work.  It inspects the
value after the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">match</code></span> keyword, and selects the branch that corresponds to
the variant of that value.  Then it extracts the fields from the value, and
substitutes them for the names given in the branch.  Let&rsquo;s use the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">m4</code></span>
example to make that concrete:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">  match Node("a", Node("b", Leaf, Leaf), Leaf) with
    | Leaf -&gt; "z"
    | Node(s, left, right) -&gt;
      match left with
        | Leaf -&gt; "y"
        | Node(s2, left2, right2) -&gt; s2

(* substitute Node("b", Leaf, Leaf) for left *)

=&gt; match Node("b", Leaf, Leaf) with
     | Leaf -&gt; "y"
     | Node(s2, left2, right2) -&gt; s2

(* substitute "b" for s2 *)

=&gt; "b"</code></pre></div></div></p><p>With <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">match</code></span> available, we can now fill in the body for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">inorder_str</code></span>.
We can start by writing out a skeleton of the match structure for a
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">btnode</code></span>, as most functions over <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">btnode</code></span>s will need to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">match</code></span> on
the node to decide what to do.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec inorder_str (bt : btnode) : string =
  match bt with
    | Leaf -&gt; ...
    | Node(s, left, right) -&gt; ...</code></pre></div></div></p><p>Now we can ask what the preorder traversal should yield in the case of a leaf
of the tree (or an empty tree altogether).  In this case, that ought to be an
empty string.  So the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Leaf</code></span> case should be filled in with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">""</code></span>.  How
about for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Node</code></span>s?  We know an inorder traversal should have the elements
to the left in order, then the current node, then the elements to the right.
We can get the elements to either side via a recursive call, and then we just
need one more piece of information, which is that <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">^</code></span> is the operator for
concatenating strings in OCaml:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec inorder_str (bt : btnode) : string =
  match bt with
    | Leaf -&gt; ""
    | Node(s, left, right) -&gt;
      (inorder_str left) ^ s ^ (inorder_str right)</code></pre></div></div></p><h4>3.3<tt>&nbsp;</tt><a name="(part._e~3atrees)"></a>Exercises</h4><div class="hw"><ol start="3"><li><p><span class="NoteBox"><span class="NoteContent">This is a trick question.</span></span>Write a test function <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">t_string</code></span>
that&rsquo;s like <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">t_int</code></span>, but tests for equality of strings.  Can you write a
function that produces a string form of the results like <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">t_int</code></span> did for
integers?</p></li><li><p>Write at least five interesting tests for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">inorder_str</code></span>.</p></li><li><p>Write out the substitution-based evaluation of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">inorder_str</code></span> on a
tree with at least 3 nodes.</p></li><li><p>Write a function <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">size</code></span> that takes a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">btnode</code></span> and produces an
integer that is the number of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Node</code></span>s in the tree.</p></li><li><p>Write a function <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">height</code></span> that takes a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">btnode</code></span> and produces an
integer that is the height of the tree.</p></li><li><p>Make sure to test the above two functions.</p></li></ol></div><h3>4<tt>&nbsp;</tt><a name="(part._.Programming_in_.O.Caml_---_.Lists_and_.Parametric_.Polymorphism)"></a>Programming in OCaml &#8212;<wbr></wbr> Lists and Parametric Polymorphism</h3><h4>4.1<tt>&nbsp;</tt><a name="(part._.Linked_.Lists__.By_.Hand)"></a>Linked Lists, By Hand</h4><p>Since we&rsquo;ve seen binary trees, it&rsquo;s natural to think about a similar
definition for the nodes of a linked list.  One OCaml datatype we could write
is:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type llist =
  | Empty
  | Link of string * llist</code></pre></div></div></p><p>That is, a list is either <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Empty</code></span> (the end of the list), or a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Link</code></span> of
a string onto another list.  Of course, this would require that we write
additional datatype declarations for lists of numbers, lists of booleans,
lists of binary trees, and so on, if we needed those shapes of data.  The
natural solution is to make the datatype generic over the kind of data it
uses.  OCaml lets us do this by defining datatypes with <span style="font-style: italic">type variables</span>
that can be filled with any type.  Type variables are written with a leading
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'</code></span> character:</p><p><span class="NoteBox"><span class="NoteContent">This idea corresponds to the use of templates in C++, or generic types in
Java.</span></span>
<div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a llist =
  | Empty
  | Link of 'a * 'a llist</code></pre></div></div></p><p>The types of the fields in <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Link</code></span> have changed with this addition.  The
first field can now hold a value of the list&rsquo;s type, and the second must hold
a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">llist</code></span> that contains elements of that type as well.  That is, this
describes a <span style="font-style: italic">homogeneous</span> linked list, where all elements will have the
same type.
<span class="NoteBox"><span class="NoteContent">We won&rsquo;t have much use for heterogeneous lists, which would introduce
different complications.</span></span></p><p>Lets say we want to write a function <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">sum</code></span> that takes a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">llist</code></span> of
numbers and adds them up.  We now need to describe its type in terms of the
contents, which will be an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">int</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec sum (l : int llist) : int =
  match l with
    | Empty -&gt; 0
    | Link(first, rest) -&gt; first + (sum rest)</code></pre></div></div></p><p>When we construct <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">llist</code></span>s, we do <span style="font-style: italic">not</span> need to provide any extra type
information &#8212;<wbr></wbr> OCaml figures it out for us.  For example, we can write:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let l1 = Link(1, Empty);;
let l2 = Link("a", Empty);;</code></pre></div></div></p><p>Here, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">l1</code></span> will have type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">int llist</code></span>, and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">l2</code></span> will have type
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">string llist</code></span>.</p><h4>4.2<tt>&nbsp;</tt><a name="(part._.Linked_.Lists__.Built-in)"></a>Linked Lists, Built-in</h4><p>It turns out that our definition of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">llist</code></span> above is important enough that a
version of it is built into OCaml, just with slightly different names and
syntax.  The built-in equivalent of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Empty</code></span> is written <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">[]</code></span>, and
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Link(first, rest)</code></span> is written <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">first :: rest</code></span>.  The syntax <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">[a; b; c]</code></span>
is shorthand for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">a::b::c::[]</code></span>.  (Whitespace is not required before or
after the colons and semicolons here, but is useful for readability.)  The type
of built-in lists is <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a list</code></span>, which can be specialized for any list
contents.  For example, we could rewrite <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">sum</code></span> above as:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec sum2 (l : int list) : int =
  match l with
    | [] -&gt; 0
    | first::rest -&gt; first + (sum2 rest)</code></pre></div></div></p><p>And we could test it by creating tests with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">t_int</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(* these would go in the suite list *)
t_int "sum2_empty" (sum2 []) 0;
t_int "sum2_single" (sum2 [5]) 5;
t_int "sum2_longer" (sum2 [3; 4; 5]);
t_int "sum2_longer2" (sum2 3::4::5::[]);</code></pre></div></div></p><p>Note that the last two tests mean the same thing; they are just different ways
of writing the same list containing 3, 4, and 5.</p><p>Since lists are quite a fundamental structure, we will end up using them
frequently; handy functions to use with lists are
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/List.html">here</a>,
and we&rsquo;ll talk about them more as we build up more experience with OCaml.
I&rsquo;ll mention here, since it&rsquo;s slightly tricky to search for, that OCaml
provides two ways to append lists:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(* This function ... *)
List.append [1;2;3] [4;5;6] ====&gt; [1;2;3;4;5;6]

(* ... is synonymous with this infix operator *)
[1;2;3] @ [4;5;6] ====&gt; [1;2;3;4;5;6]</code></pre></div></div></p><h4>4.3<tt>&nbsp;</tt><a name="(part._e~3alists)"></a>Exercises</h4><div class="hw"><ol start="9"><li><p>Write and test a function <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">increment_all</code></span> that takes an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">int list</code></span>
and produces a new <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">int list</code></span> with all the elements increased by
1.</p></li><li><p>Write and test a function <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">long_strings</code></span> that takes a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">string list</code></span>
and an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">int</code></span> and produces a new <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">string list</code></span> that contains all
the strings that had length greater than the given <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">int</code></span>.  You can get
the length of a string with the function <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">String.length</code></span>.  Other string
functions are documented
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/String.html">here</a>.</p></li><li><p>Write and test a function <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">every_other</code></span> that takes a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a list</code></span>
(a list with elements of any one type), and produces a new list that
contains every other element from the given list, starting with the first
element.</p></li><li><p>Write and test a function <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">sum_all</code></span> that takes an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">int list list</code></span>
(that is, a list of lists of integers), and returns an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">int list</code></span>
that contains the sums of the sub-lists.</p></li></ol></div><h3>5<tt>&nbsp;</tt><a name="(part._.Tuples)"></a>Tuples</h3><p>There are many times in programs where we wish to return more than one value.
For example, when returning a pair of key and value from a hash-table data
structure, when returning an average and its standard deviation, or when
representing a two (or three)-dimensional point, to name a few.</p><p>OCaml has a built-in way of handling these cases called <span style="font-style: italic">tuples</span>.  To
create a tuple, we enclose two or more values in parentheses:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let tup = (1, "a", []);;</code></pre></div></div></p><p>To access the values in a tuple, we can use a special kind of let binding,
where we give names to the positions of a tuple value:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let tup = (1, "a", []);;
let (one, a, empty_list) = tup;
(*
  one is 1
  a is "a"
  empty_list is []
*)</code></pre></div></div></p><p>Since pairs &#8212;<wbr></wbr> tuples of exactly two elements &#8212;<wbr></wbr> are quite common, there are also
two built-in functions, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">fst</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">snd</code></span>, that get the first and second
component of a two-element tuple, respectively.</p><p>The <span style="font-style: italic">type</span> of a tuple is written with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">*</code></span> characters separating the
components&rsquo; types, and surrounded by parentheses.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let increment_snd (t : (string * int)) : (string * int) =
  (fst t, 1 + (snd t));;

(increment_snd ("a", 5)) (* returns the pair ("a", 6) *)</code></pre></div></div></p><p>In this assigment, you will use tuples to represent source locations of tokens,
when parsing S-expressions (and of course, tuples will be useful for many other
things, later!).</p><h3>6<tt>&nbsp;</tt><a name="(part._.The_option_.Type)"></a>The <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">option</code></span> Type</h3><p>A common way of handling failure that we&rsquo;ve already seen is raising exceptions
with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">failwith</code></span>.  This works well when an operation is truly nonsensical.
However, it forces programs to use a different class of features &#8212;<wbr></wbr> exceptions
and exception handlers &#8212;<wbr></wbr> to handle failing behaviors.  Sometimes, the failure
of an operation is a reasonable outcome, and having a way to report a failure,
or the absence of an answer, with a normal value rather than an exception is
quite useful.</p><p>Consider the problem of finding and returning the first element in a list that
matches a particular predicate:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec find (l : 'a list) (pred : 'a -&gt; bool) : 'a =
  match l with
    | [] -&gt; failwith "Not found"
    | x::xs -&gt; if pred x then x else find xs pred;;

(find [1;2;3] (fun n -&gt; n &gt; 4);; (* raises an error *)
(find [1;2;3] (fun n -&gt; n &gt; 2);; (* returns 3 *)</code></pre></div></div></p><p>When the element isn&rsquo;t found, we cannot return a value of type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a</code></span>,
because the algorithm hasn&rsquo;t found one.  It seems we have to throw an error,
as there is nothing left for us to do.  This certainly limits the utility of
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">find</code></span>, which now needs a companion <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">contains</code></span> if is to be useful on
lists that aren&rsquo;t already known to have a matching element.</p><p>It would be convenient if we had a value that represented that there is
<span style="font-style: italic">no</span> appropriate value to return in the empty case.  Similarly, it would
be useful to have the counterpart, a representation of being able to provide
<span style="font-style: italic">some</span> appropriate value.  OCaml provides just such a datatype, called
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">option</code></span>, which is built-in.  If we wrote the definition ourselves, it
would look like:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a option =
  | None
  | Some of 'a</code></pre></div></div></p><p>That is, an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">option</code></span> is either <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">None</code></span>, which we can use to indicate
failure or the lack of an appropriate value, or <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Some</code></span>, which contains a
single field that is a value of the option&rsquo;s type.  To write <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">find</code></span> using
option, we would write:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec find2 (l : 'a list) (pred : 'a -&gt; bool) : 'a option =
  match l with
    | [] -&gt; None
    | x::xs -&gt; if pred x then Some(x) else find2 xs pred;;

(find2 [1;2;3] (fun n -&gt; n &gt; 4);; (* returns None *)
(find2 [1;2;3] (fun n -&gt; n &gt; 2);; (* returns Some(3) *)</code></pre></div></div></p><p>Now a program that calls <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">find</code></span>, rather than using an exception handler to
manage the not found case, can simply <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">match</code></span> on the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">option</code></span> that is
returned to decide what to do.</p><p>Note that <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">option</code></span>s aren&rsquo;t always better than exceptions, as sometimes it&rsquo;s
difficult for the caller to know what to do when <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">None</code></span> is returned.  But
in many cases, when &ldquo;failure&rdquo; is something that the caller can reasonably
react to, returning an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">option</code></span> is a much more natural choice.</p><p>(For those coming from C/C++ backgrounds, note that an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a option</code></span> is very
different from a &ldquo;pointer that might be <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">NULL</code></span>&rdquo;.  Because of ML&rsquo;s type
system, you can&rsquo;t simply &ldquo;dereference the pointer&rdquo;: the only thing you can do
with a value of a datatype is <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">match</code></span> on it, which means you can never
forget to check if the value is actually <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">None</code></span>.)</p><h3>7<tt>&nbsp;</tt><a name="(part._.Grading_standards)"></a>Grading standards</h3><p>For this assignment, you will be graded on</p><ul><li><p>whether your code compiles,</p></li><li><p>whether your code implements the specification (functional
correctness),</p></li><li><p>whether you thoroughly test every method that you write, and</p></li><li><p>how readable your code is (indented well, commented well, etc).</p></li></ul><h3>8<tt>&nbsp;</tt><a name="(part._.Submission)"></a>Submission</h3><h4>8.1<tt>&nbsp;</tt><a name="(part._.Deliverables)"></a>Deliverables</h4><p>Your submission should include the three files provided: <code>Makefile</code>, <code>functions.ml</code>, and <code>test.ml</code>.</p><p>Please ensure that your code compiles! On this assignment, half of your grade
is for correctness as determined by automated testing, so code that doesn&rsquo;t
compile is subject to a 50% penalty up front.  Zip the files together:</p><p><div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ zip submission.zip Makefile functions.ml test.ml</code></pre></div></div></p><p>and submit that zip.  (Note: we may or may not wind up using automated unit tests on the handin server itself, but we will run the unit tests ourselves offline.)</p><h4>8.2<tt>&nbsp;</tt><a name="(part._.Instructions)"></a>Instructions</h4><p>You will submit your homework at <a href="https://handins.ccs.neu.edu"><span class="url">https://handins.ccs.neu.edu</span></a>.  Follow the instructions <a href="http://www.ccs.neu.edu/home/blerner/handin-server/handin-server-guide.html">here</a> on how to use the server.
]</p></div></div><div id="contextindicator">&nbsp;</div></body></html>