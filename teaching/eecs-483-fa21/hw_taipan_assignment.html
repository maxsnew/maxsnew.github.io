<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Assignment 6: Taipan: Checking and inferring types</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 6:</span> Taipan:<span class="mywbr"> &nbsp;</span> Checking and inferring types</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.The_.Taipan_.Language%29" class="tocviewlink" data-pltdoc="x">The Taipan Language</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Requirements_for_both_.C.S4410_and_.C.S6410%29" class="tocviewlink" data-pltdoc="x">Requirements for both CS4410 and CS6410</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Requirements_for_.C.S4410_and_.C.S6410%29" class="tocviewlink" data-pltdoc="x">Requirements for CS4410 and CS6410</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Additional_.Requirements_for_.C.S6410%29" class="tocviewlink" data-pltdoc="x">Additional Requirements for CS6410</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Testing_notes%29" class="tocviewlink" data-pltdoc="x">Testing notes</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.List_of_.Deliverables%29" class="tocviewlink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#%28part._.Grading_.Standards%29" class="tocviewlink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="#%28part._.Submission%29" class="tocviewlink" data-pltdoc="x">Submission</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="AssignmentNum">Assignment 6:</span> Taipan:<span class="mywbr"> &nbsp;</span> Checking and inferring types</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Taipan_.Language%29" class="tocsubseclink" data-pltdoc="x">The Taipan Language</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Concrete_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Concrete Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Abstract_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Abstract Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Annotating_variable_bindings_and_programs%29" class="tocsubseclink" data-pltdoc="x">Annotating variable bindings and programs</a></td></tr><tr><td><span class="tocsublinknumber">1.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Annotating_function_calls%29" class="tocsubseclink" data-pltdoc="x">Annotating function calls</a></td></tr><tr><td><span class="tocsublinknumber">1.2.3<tt>&nbsp;</tt></span><a href="#%28part._.Annotating_variable_uses__or_expressions_in_general%29" class="tocsubseclink" data-pltdoc="x">Annotating variable uses, or expressions in general</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Semantics%29" class="tocsubseclink" data-pltdoc="x">Semantics</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Requirements_for_both_.C.S4410_and_.C.S6410%29" class="tocsubseclink" data-pltdoc="x">Requirements for both CS4410 and CS6410</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Requirements_for_.C.S4410_and_.C.S6410%29" class="tocsubseclink" data-pltdoc="x">Requirements for CS4410 and CS6410</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Additional_.Requirements_for_.C.S6410%29" class="tocsubseclink" data-pltdoc="x">Additional Requirements for CS6410</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Testing_notes%29" class="tocsubseclink" data-pltdoc="x">Testing notes</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.List_of_.Deliverables%29" class="tocsubseclink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._.Grading_.Standards%29" class="tocsubseclink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td><span class="tocsublinknumber">8<tt>&nbsp;</tt></span><a href="#%28part._.Submission%29" class="tocsubseclink" data-pltdoc="x">Submission</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="AssignmentNum">Assignment 6:</span> Taipan: Checking and inferring types</h2><p><h4 class="due">Due: Fri 02/28 at 9:00pm</h4></p><p><p class="git-clone"><code><span class="kw">git clone </span><input onclick="this.select();" readonly="readonly" value="https://github.ccs.neu.edu/cs4410/starter-taipan"/></code></p></p><p><span style="font-style: italic">In this assignment, you&rsquo;ll be statically checking and/or inferring the
types of expressions and functions in input programs.  In other words, you&rsquo;ll
be dealing with TYPE ANnotations.</span>
<p style="text-align: center"><img class="titleimage" src="https://upload.wikimedia.org/wikipedia/commons/5/5f/Coastal-Taipan.jpg"/></p></p><h3>1<tt>&nbsp;</tt><a name="(part._.The_.Taipan_.Language)"></a>The Taipan Language</h3><h4>1.1<tt>&nbsp;</tt><a name="(part._.Concrete_.Syntax)"></a>Concrete Syntax</h4><p>The only changes made to the concrete syntax of
<a href="hw_diamondback_assignment.html" data-pltdoc="x">Diamondback</a> have to do with handling types.  First,
we will optionally group multiple function definitions together, analogous to
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec ... and ...</code></span>, to support mutually recursive functions.  Second, we
will allow type annotations on the arguments and return types of function
definitions.  Third, we will allow type annotations on let-bindings.  Fourth,
we allow specifying the type arguments to functions and primitive operations
that are polymorphic.  These new expression forms are hilighted below.
Finally, we define syntax for types.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Taipan._program)))"></a><span class="bnf-rule">&#8249;program&#8250;</span><span class="bnf-meta">:</span> 
                <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._declgroups%29%29%29" data-pltdoc="x">&#8249;declgroups&#8250;</a></span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._programbody%29%29%29" data-pltdoc="x">&#8249;programbody&#8250;</a></span>
                <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._programbody%29%29%29" data-pltdoc="x">&#8249;programbody&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Taipan._programbody)))"></a><span class="bnf-rule">&#8249;programbody&#8250;</span><span class="bnf-meta">:</span> 
                        <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
                        <span class="bnf-meta"> | </span><span class="text-hilite-3"><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span></span>
<a name="(elem._(bnf-prod._(.Taipan._declgroups)))"></a><span class="bnf-rule">&#8249;declgroups&#8250;</span><span class="bnf-meta">:</span> 
                      <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._declgroup%29%29%29" data-pltdoc="x">&#8249;declgroup&#8250;</a></span>
                      <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._declgroup%29%29%29" data-pltdoc="x">&#8249;declgroup&#8250;</a></span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._declgroups%29%29%29" data-pltdoc="x">&#8249;declgroups&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Taipan._declgroup)))"></a><span class="bnf-rule">&#8249;declgroup&#8250;</span><span class="bnf-meta">:</span> 
                    <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._decl%29%29%29" data-pltdoc="x">&#8249;decl&#8250;</a></span>
                    <span class="bnf-meta"> | </span><span class="text-hilite-3"><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._decl%29%29%29" data-pltdoc="x">&#8249;decl&#8250;</a></span> <span class="bnf-lit">and</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._declgroup%29%29%29" data-pltdoc="x">&#8249;declgroup&#8250;</a></span></span>
<a name="(elem._(bnf-prod._(.Taipan._decl)))"></a><span class="bnf-rule">&#8249;decl&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class="text-hilite-3"><span class="bnf-lit">def</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">&lt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._tyids%29%29%29" data-pltdoc="x">&#8249;tyids&#8250;</a></span> <span class="bnf-lit">&gt;</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._ids%29%29%29" data-pltdoc="x">&#8249;ids&#8250;</a></span> <span class="bnf-lit">)</span> <span class="bnf-lit">-&gt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span></span>
          <span class="bnf-meta"> | </span><span class="text-hilite-3"><span class="bnf-lit">def</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._ids%29%29%29" data-pltdoc="x">&#8249;ids&#8250;</a></span> <span class="bnf-lit">)</span> <span class="bnf-lit">-&gt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span></span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">def</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._ids%29%29%29" data-pltdoc="x">&#8249;ids&#8250;</a></span> <span class="bnf-lit">)</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Taipan._ids)))"></a><span class="bnf-rule">&#8249;ids&#8250;</span><span class="bnf-meta">:</span> 
        <span class="bnf-meta"> | </span><span class="bnf-eps">&#949;</span>
        <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._bind%29%29%29" data-pltdoc="x">&#8249;bind&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._ids%29%29%29" data-pltdoc="x">&#8249;ids&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Taipan._bind)))"></a><span class="bnf-rule">&#8249;bind&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span>
          <span class="bnf-meta"> | </span><span class="text-hilite-3"><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span></span>
<a name="(elem._(bnf-prod._(.Taipan._typ)))"></a><span class="bnf-rule">&#8249;typ&#8250;</span><span class="bnf-meta">:</span> 
        <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span>
        <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._tyid%29%29%29" data-pltdoc="x">&#8249;tyid&#8250;</a></span>
        <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typs%29%29%29" data-pltdoc="x">&#8249;typs&#8250;</a></span> <span class="bnf-lit">-&gt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Taipan._typs)))"></a><span class="bnf-rule">&#8249;typs&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typs%29%29%29" data-pltdoc="x">&#8249;typs&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Taipan._tyid)))"></a><span class="bnf-rule">&#8249;tyid&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit">&rsquo;</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span>
<a name="(elem._(bnf-prod._(.Taipan._tyids)))"></a><span class="bnf-rule">&#8249;tyids&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class="bnf-eps">&#949;</span>
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._tyid%29%29%29" data-pltdoc="x">&#8249;tyid&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._tyids%29%29%29" data-pltdoc="x">&#8249;tyids&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Taipan._exprs)))"></a><span class="bnf-rule">&#8249;exprs&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Taipan._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class="text-hilite-3"><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">&lt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typs%29%29%29" data-pltdoc="x">&#8249;typs&#8250;</a></span> <span class="bnf-lit">&gt;</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span> <span class="bnf-lit">)</span></span>
          <span class="bnf-meta"> | </span><span class="text-hilite-3"><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">&lt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typs%29%29%29" data-pltdoc="x">&#8249;typs&#8250;</a></span> <span class="bnf-lit">&gt;</span> <span class="bnf-lit">(</span> <span class="bnf-lit">)</span></span>
          <span class="bnf-meta"> | </span><span class="text-hilite-3"><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._prim1%29%29%29" data-pltdoc="x">&#8249;prim1&#8250;</a></span> <span class="bnf-lit">&lt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typs%29%29%29" data-pltdoc="x">&#8249;typs&#8250;</a></span> <span class="bnf-lit">&gt;</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span></span>
          <span class="bnf-meta"> | </span><span class="text-hilite-3"><span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._prim2%29%29%29" data-pltdoc="x">&#8249;prim2&#8250;</a></span> <span class="bnf-lit">&lt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typs%29%29%29" data-pltdoc="x">&#8249;typs&#8250;</a></span> <span class="bnf-lit">&gt;</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span></span>
          <span class="bnf-meta"> | </span><span class="text-hilite-3"><span class="bnf-lit">(</span> <span class="bnf-lit bnf-unknown">ID</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Taipan._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span> <span class="bnf-lit">)</span></span>
<a name="(elem._(bnf-prod._(.Taipan._prim1)))"></a><span class="bnf-rule">&#8249;prim1&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
<a name="(elem._(bnf-prod._(.Taipan._prim2)))"></a><span class="bnf-rule">&#8249;prim2&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span></p></blockquote><p>The first and second <a href="#%28elem._%28bnf-prod._%28.Taipan._decl%29%29%29" data-pltdoc="x">&#8249;decl&#8250;</a> definitions annotates the
function with a return type; the other leaves the return type blank.  The
angle-brackets delimit type variables; you may only specify type variables if
you bother to specify a return type.  When calling these functions, you may
specify the type variables using the first two <a href="#%28elem._%28bnf-prod._%28.Taipan._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a> forms.
(The next two forms are analogous, and provide type annotations for unary and
binary primitives.)
The <a href="#%28elem._%28bnf-prod._%28.Taipan._bind%29%29%29" data-pltdoc="x">&#8249;bind&#8250;</a> definitions optionally annotate a binding with a
type.  Note that there must be no spaces before the <span class="bnf-lit">&lt;</span> or
<span class="bnf-lit">(</span> tokens.</p><p>The <a href="#%28elem._%28bnf-prod._%28.Taipan._declgroup%29%29%29" data-pltdoc="x">&#8249;declgroup&#8250;</a> construction corresponds to the ML
definition <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec ... and ...</code></span> form.  The functions within a
<a href="#%28elem._%28bnf-prod._%28.Taipan._declgroup%29%29%29" data-pltdoc="x">&#8249;declgroup&#8250;</a> can refer to each other, or to any
<span style="font-style: italic">earlier</span> definitions; unlike Diamondback, we will declare that not all
definitions are mutually in scope, and so we prohibit forward-references to
functions that have not yet been defined.  (This will be needed for inferring
polymorphic types for functions.)</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Abstract_.Syntax)"></a>Abstract Syntax</h4><p>The abstract syntax is not much changed from Diamondback, other than the four
changes described above.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a typ =
  | TyBlank of 'a (* nothing was specified *)
  | TyCon of string * 'a (* type constants like Int or Bool *)
  | TyVar of string * 'a (* type variables, like 'a *)
  | TyArr of 'a typ list * 'a typ * 'a (* function types, ('a, 'b, 'c -&gt; 'd) etc. *)
  | TyApp of 'a typ * 'a typ list * 'a (* type application, like 'a list *)

type 'a scheme =
  | SForall of string list * 'a typ * 'a (* e.g. Forall 'a, 'b, (some type using 'a, 'b) *)

type 'a decl =
  | DFun of string * (string * 'a) list * 'a scheme * 'a expr * 'a
         (* name,    args,                poly.type,  body,     tag *)
type 'a program =
  | Program of 'a decl list list * 'a expr * 'a (* one 'a decl list = one declgroup *)</code></pre></div></div></p><p>We use <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">TyBlank</code></span> to indicate the source program did not specify a type.  If
a function had no type annotations at all, then it would have a scheme
involving a lot of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">TyBlank</code></span>s, e.g.
<div class="sourceCodeWrapper"><span data-label="Taipan" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode"># Has scheme SForall([], TyArr([TyBlank, TyBlank], TyBlank))
def whatever(x, y): x</code></pre></div></div></p><h5>1.2.1<tt>&nbsp;</tt><a name="(part._.Annotating_variable_bindings_and_programs)"></a>Annotating variable bindings and programs</h5><p>In addition to the expressions you are familiar with from Diamondback, we have
added the ability for a programmer to annotate program bodies and variable uses
with type annotations, written as</p><p><div class="sourceCodeWrapper"><span data-label="Taipan" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def whatever(x):
  let y : Int = x + 5 in # type-annotations on let-bindings do not need parens
  (x : Int) + y # type-annotated variables must be surrounded by parens

# parameters to function definitions do not need parens
def plus(x : Int, y : Int) -&gt; Int: x + y

# A type-annotated program body does not need parens
5 + whatever(3) : Int</code></pre></div></div></p><p>The parens around variable uses are annoying but grammatically necessary to
avoid parsing ambiguity.</p><h5>1.2.2<tt>&nbsp;</tt><a name="(part._.Annotating_function_calls)"></a>Annotating function calls</h5><p>Supplying type arguments to function calls or to primitive operations is done
via angle-brackets, similar to Java&rsquo;s generics syntax:</p><p><div class="sourceCodeWrapper"><span data-label="Taipan" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def whatever&lt;'a&gt;(anything : 'a) -&gt; 'a:
  print&lt;'a&gt;(anything)

3 ==&lt;Int&gt; print&lt;Int&gt;(whatever&lt;Int&gt;(5)) : Bool</code></pre></div></div></p><p>We represent these annotations slightly differently from each other.
Primitives gain an extra optional <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">typ list</code></span>, such that when the value is
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">None</code></span> there were no annotations specified; when the value is <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Some</code></span> list
then the user entered those types.  Function applications, on the other hand,
get a new constructor that contains the user-provided list of types.
(<span style="font-weight: bold">Note:</span> this mostly ought to be uniform, but since I specified
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EGenApp</code></span> on Piazza already, I don&rsquo;t want to needlessly change it.)</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a expr =
    ...
  | EPrim1 of prim1 * 'a typ list option * 'a expr * 'a
  | EPrim2 of prim2 * 'a typ list option * 'a expr * 'a expr * 'a
  | EGenApp of string * 'a typ list * 'a expr list * 'a
            (* funname, type args,     arguments,     tag *)</code></pre></div></div></p><h5>1.2.3<tt>&nbsp;</tt><a name="(part._.Annotating_variable_uses__or_expressions_in_general)"></a>Annotating variable uses, or expressions in general</h5><p>The syntax <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(var : typ)</code></span> is represented by an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EAnnot</code></span> expression constructor:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a expr =
    ...
  | EAnnot of 'a expr * 'a typ * 'a</code></pre></div></div></p><p>Note from the parameters here that <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EAnnot</code></span> allows you to decorate
<span style="font-style: italic">any</span> expression and ascribe it a type, not just variables.  The parser
will insert <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EAnnot</code></span> constructors around the entire body of the Taipan
program being compiled, if it was annotated.  There is no concrete syntax for
annotating other expressions (and the programmer shouldn&rsquo;t need to, anyway).
This expression form has at least four potential uses:</p><ul><li><p>At code-generation time, this <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EAnnot</code></span> expression should simply compile to
its nested expression &#8212;<wbr></wbr> though perhaps you may want to optimize your
generated code by eliding tag checks, if you are certain that the types can&rsquo;t
possibly go wrong.</p></li><li><p>At type-checking time, you should check that the nested
expression indeed has the desired annotated type.  You can also use this
expression form to insert type descriptions into your program.  For example,</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec decorate (e : 'a expr) : 'a expr =
  match e with
  | ENumber(_, a) -&gt; EAnnot(e, TyCon("Int", a))
  | EBool(_, a) -&gt; EAnnot(e, TyCon("Bool", a))
  | EPrim1(Add1, opt_typs, e, a) -&gt;
      EAnnot(EPrim1(Add1, opt_typs, decorate e, a), TyCon("Int", a))
  | ...</code></pre></div></div></p></li><li><p>At type-inference time, you may want to insert <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EAnnot</code></span> expressions to
make it easier to type-<span style="font-style: italic">check</span> the code.</p></li><li><p>In general for <span style="font-style: italic">debugging</span> your code, you may want to print out
a transformed AST that includes all the type-checks you think should be
there...</p></li></ul><h4>1.3<tt>&nbsp;</tt><a name="(part._.Semantics)"></a>Semantics</h4><p>Only functions and operators can have polymorphic types, which we separate out
and refer to as <span style="font-style: italic">type schemes</span>.  An individual let-binding shall always
have a monomorphic type.  (Note that it could have a type that is variable,
e.g.</p><p><div class="sourceCodeWrapper"><span data-label="Taipan" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode"># Should have type scheme, Forall 'a, 'a -&gt; 'a
def identity(x):
  let y = x in y # y should have type 'a</code></pre></div></div></p><p>Within the body of the function, the variable <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">y</code></span> has a single generic
type, namely <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">'a</code></span>.  This is different from saying the variable is
polymorphic within the body of the function: that would signify that the
variable could have multiple types within a single invocation of the function.)</p><h3>2<tt>&nbsp;</tt><a name="(part._.Requirements_for_both_.C.S4410_and_.C.S6410)"></a>Requirements for both CS4410 and CS6410</h3><p>You must change your scoping rules for functions, such that forward references
to functions not in your current <a href="#%28elem._%28bnf-prod._%28.Taipan._declgroup%29%29%29" data-pltdoc="x">&#8249;declgroup&#8250;</a> are not in scope.</p><p>You should add the new phases to your compiler pipeline as needed, and extend
the <code>phases.ml</code> file accordingly.</p><p><p>We have provided you with a few new errors to report:
</p><ul><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">NoType(name, loc)</code></span> indicates that the given name wasn&rsquo;t annotated
with a type, at the given location</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ShouldBeFunction(name, loc, typ)</code></span> indicates that the given name was
defined at the given location, and had the given type which somehow was not a
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">TyArr</code></span> function-type.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">DeclArity</code></span> indicates that a function&rsquo;s <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">TyArr</code></span> arrow had a
different arity from the actual number of arguments in the function
declaration.  This is pretty certain to be rare, and indicates some internal
inconsistency in your compiler.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">TypeMismatch(loc, expected, actual, why)</code></span> indicates a type mismatch
at the given location, with the expected and actual types as given.  The
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">why</code></span> parameter is a list of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">reason</code></span>s, which we encourage you to use
to debug your code.  We have provided you with four reasons, and you may add
more if you want to:</p><ul><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">InferExp(e)</code></span> means you were trying to infer the type for this
expression</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Message(str)</code></span> just prints out whatever message you like</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Unify(msg, t1, t2)</code></span> indicates that you were attempting to unify two
types, and you may supply a diagnostic message</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Instantiate(name, scheme)</code></span> indicates that you were instantiating the
polymorphic type-scheme for the given named function.</p></li></ul><p>For example, my type-inferencer currently produces the following diagnostic output:</p><p><div class="sourceCodeWrapper"><div class="sourceCode"><pre data-lang="" class="sourceCode"><code data-lang="" class="sourceCode">Source:
(3 == true)

Type error at input/simple.taipan, 1:0-1:9: expected Bool but got Int, because
   Different base types
   trying to unify 'X_2 and Bool (because arguments of arrows)
   trying to unify ('X_2, 'X_2 -&gt; Bool) and (Int, Bool -&gt; 'prim2ret_1) (because use of operator)
   trying to infer type for (3 == true) at input/simple.taipan, 1:0-1:9</code></pre></div></div></p><p>Adding these diagnostics was invaluable in debugging some odd corner cases of
my type-inference code.  If you choose not to use them, you can just supply
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">[]</code></span> as the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">why</code></span> argument.</p></li></ul></p><p>We have also given you a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">debug_printf</code></span> function that behaves just like
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">printf</code></span>, except it&rsquo;s controlled by the <code>-d</code> command-line flag for
<code>./main</code>.  You can use this to print out additional diagnostic messages
while compilation is running, separately from using the <code>-t</code> flag to print
out the trace of compilation.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Requirements_for_.C.S4410_and_.C.S6410)"></a>Requirements for CS4410 and CS6410</h3><p>You must implement a type-<span style="font-style: italic">checking</span> algorithm.  A program is
type-checkable if all function definitions have fully annotated their arguments
and return types, and if all let-bindings have annotated their expected types.
(In other words, you should never have to &ldquo;guess&rdquo; at the type of an
expression.)</p><p>Design a function</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let type_check (p : sourcespan program) : sourcespan program fallible = ...</code></pre></div></div></p><p>that returns the first type error it encounters, or returns the program if it
successfully type checks.  You do not have to produce multiple type errors.</p><p>Test thoroughly.  You can manually run the compiler via
<code>./main -check yourProgram.taipan</code> to perform type-checking; leaving out
the <code>-check</code> flag should skip checking.  As before, you can use the
<code>-t</code> flag to print out the trace of all your compilation phases.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Additional_.Requirements_for_.C.S6410)"></a>Additional Requirements for CS6410</h3><p>You must implement a type-<span style="font-style: italic">inference</span> algorithm.  This is intricate, and
involves many substeps.  <a href="lec_type-inference_notes.html" data-pltdoc="x"><span class="LectureNum">Lecture 12:</span> Type Inference</a> lays out the outline of the
functions you&rsquo;ll need to implement, and what they all do.
<a href="http://dev.stephendiehl.com/fun/006_hindley_milner.html">This
webpage</a> provides a good writeup of the type-inference algorithm, though it is
marginally different than the one we will implement, and their code is written in
Haskell rather than OCaml.</p><p>Design a function</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let type_synth (p : sourcespan program) : sourcespan program fallible = ...</code></pre></div></div></p><p>that returns the program itself if the program can infer a type successfully,
or the first error it encounters otherwise.  You do not have to produce
mutliple type errors.</p><p>I recommend you use the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EAnnot</code></span> expression form, so that instead of
returning the original input program, you return a version of the program where
all expressions have been wrapped in <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EAnnot</code></span> expressions whose types
contain the inferred types you&rsquo;ve deduced during inference.  This
fully-annotated program can then be passed through your type-checker, as
implemented above.</p><p>Note that the skeleton code given to you has slightly different signatures than
the lecture notes; in particular, it contains additional &ldquo;bookkeeping&rdquo;
parameters to carry along as needed:</p><ul><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">unify</code></span> carries around a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(loc : sourcespan)</code></span> that is the original source
location of the expression whose type you are trying to infer, and a
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(reasons : reason list)</code></span> of why your inference has proceeded to state that
it has.  You should use both of these parameters when you <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">raise</code></span> a
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">TypeMismatch</code></span> exception, and you should accumulate additional reasons as
you recur through unification.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">infer_exp</code></span> also takes in a list of reasons, for the same purpose as
above.  Additionally, it produces a <span style="font-style: italic">triple</span> of a type substitution, an
inferred type, and an annotated expression.  The first two results are as
described in the lecture notes; the third can use the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EAnnot</code></span> form as
described above.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">infer_decl</code></span> has the same signature as <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">infer_exp</code></span>, except it
applies to individual function declarations.</p></li><li><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">infer_group</code></span> applies to a group of mutually recursive functions.  It
produces the inferred type scheme and an annotated declaration group, but does
<span style="font-style: italic">not</span> need to return the type substitution.  (Why not?)</p></li></ul><p>Test thoroughly.  You can manually run the compiler via
<code>./main -infer yourProgram.taipan</code> to perform type-inference; leaving out
the <code>-infer</code> flag should skip inference.  You can and should use this flag
in combination with <code>-check</code> to run both As before, you can use the
<code>-t</code> flag to print out the trace of all your compilation phases.</p><h3>5<tt>&nbsp;</tt><a name="(part._.Testing_notes)"></a>Testing notes</h3><p>In the last assignment, when you created any <code>input/*/*.diamond</code> files,
you could create a <code>*.valgrind</code> file to indicate that the test should be
run using valgrind.  Now that we have multiple options for customizing
compilation, I&rsquo;ve generalized that mechanism to a <code>*.options</code> file.  Each
line of the file is an individual compilation option, and can be one of
"valgrind", "infer" or "check".</p><h3>6<tt>&nbsp;</tt><a name="(part._.List_of_.Deliverables)"></a>List of Deliverables</h3><ul><li><p>your <code>compile.ml</code></p></li><li><p>any additional modules you saw fit to write</p></li><li><p>any starter modules that you modifed</p></li><li><p>tests in an OUnit test module (<code>test.ml</code>)</p></li><li><p>any test input programs (<code>input/*.taipan</code> files or <code>input/*/*</code> subdirectories)</p></li><li><p>any additional files that are needed to build your tests (e.g. <code>main.c</code>, etc)</p></li></ul><p><span style="font-weight: bold">Again, please ensure the makefile builds your code properly.
The black-box tests will give you an automatic 0 if they cannot compile your code!</span></p><p><span style="font-weight: bold">DO NOT SUBMIT YOUR <code>.git</code> DIRECTORY!</span>  For that matter, don&rsquo;t submit
your <code>output</code> or <code>_build</code> directories.</p><h3>7<tt>&nbsp;</tt><a name="(part._.Grading_.Standards)"></a>Grading Standards</h3><p><p>For this assignment, you will be graded on
</p><ul><li><p>Whether your code implements the specification (functional correctness),</p></li><li><p>the clarity and cleanliness of your code, and</p></li><li><p>the comprehensiveness of your test coverage</p></li></ul></p><h3>8<tt>&nbsp;</tt><a name="(part._.Submission)"></a>Submission</h3><p><p><span style="font-weight: bold">Wait!</span> Please read the assignment again and verify that you have not forgotten anything!</p></p><p>Please submit your homework to <a href="https://handins.ccs.neu.edu/"><span class="url">https://handins.ccs.neu.edu/</span></a> by the above deadline.</p><a name="(part._(gentag._8._assignmenttaipan))"></a><p class="FootnoteBlock"></p></div></div><div id="contextindicator">&nbsp;</div></body></html>