<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 12: Type Inference</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 12:</span> Type Inference</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Type_inference__guessing_correctly__every_time%29" class="tocviewlink" data-pltdoc="x">Type inference:<span class="mywbr"> &nbsp;</span> guessing correctly, every time</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Type_inference_implementation%29" class="tocviewlink" data-pltdoc="x">Type inference implementation</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Putting_it_all_together%29" class="tocviewlink" data-pltdoc="x">Putting it all together</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 12:</span> Type Inference</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Type_inference__guessing_correctly__every_time%29" class="tocsubseclink" data-pltdoc="x">Type inference:<span class="mywbr"> &nbsp;</span> guessing correctly, every time</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Example_1%29" class="tocsubseclink" data-pltdoc="x">Example 1</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Example_2%29" class="tocsubseclink" data-pltdoc="x">Example 2</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Type_inference_implementation%29" class="tocsubseclink" data-pltdoc="x">Type inference implementation</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Preparation%29" class="tocsubseclink" data-pltdoc="x">Preparation</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Unification%29" class="tocsubseclink" data-pltdoc="x">Unification</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.Inference_and_.Instantiation%29" class="tocsubseclink" data-pltdoc="x">Inference and Instantiation</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#%28part._.Inference_and_.Generalization%29" class="tocsubseclink" data-pltdoc="x">Inference and Generalization</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Putting_it_all_together%29" class="tocsubseclink" data-pltdoc="x">Putting it all together</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Challenges_and_hints%29" class="tocsubseclink" data-pltdoc="x">Challenges and hints</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="LectureNum">Lecture 12:</span> Type Inference</h2><p>In the <a href="lec_type-checking_notes.html" data-pltdoc="x">last lecture</a>, we designed a system for
categorizing the expressions in our programs with <span style="font-style: italic">types</span>, and created an
algorithm for <span style="font-style: italic">checking</span> whether our programs had a self-consistent type.
However, that system ran aground in terms of usability, when it came to
primitives like <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">isbool</code></span> or <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">==</code></span>, which accepted arguments of
&ldquo;any type&rdquo; and produced boolean answers, or worse yet, <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span>, which
took arguments of &ldquo;any type&rdquo; and produced answers of <span style="font-style: italic">that</span> type.  In
order to handle this polymorphism, we had to resort to hacks: either explicitly
annotating the program everywhere there was ambiguity, or splitting the
primitives into separate, monomorphic versions that all behaved the same way.
Can we do better?</p><h3>1<tt>&nbsp;</tt><a name="(part._.Type_inference__guessing_correctly__every_time)"></a>Type inference: guessing correctly, every time</h3><p>The key observation we made last time was that our type checker must be
<span style="font-style: italic">syntax-directed</span>, meaning at every expression of our program, we had
enough local information to know how to recur on each subexpression, and we
never had to &ldquo;guess and check&rdquo; our results.  However, when we write down a
polymorphic type and <span style="font-style: italic">informally</span> use it, we walk through a reasoning
process that says &ldquo;In this case, assume that this type variable means this
particular type, then check that everything is self-consistent.&rdquo;  In other
words, we mentally perform a kind of <span style="font-style: italic">substitution</span> of types for
type-variables, then continue with the same type-checking algorithm as before.</p><p>But this is in fact overkill.  The self-consistency requirement alone is enough
to type-check our program, if we exploit it correctly.  The key is to reframe
the question from &ldquo;Does this program have this particular type?&rdquo; to &ldquo;Does
there exist a type for this program such that the program is self-consistent?&rdquo;  We
may not know what that type is, yet, but we can deduce certain facts about it.
This process is called <span style="font-style: italic">type-inference</span>, and we will follow the classic
Hindley-Milner algorithm to deduce types for our programs.</p><p>The trick to getting started is to say, &ldquo;Sure!  Every expression can have a
type &ndash; let&rsquo;s just make up a fresh type variable <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'X</code></span> and claim that as
the type.&rdquo;  Of course, there may be constraints on <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'X</code></span> based on how we
use the value in our program; these are called <span style="font-style: italic">type constraints</span>, and
type inference is simply the process of collecting and solving these
constraints.  The easiest way to see this is by example.</p><p>In order to make our type inference tractable, we are going to <span style="font-style: italic">split</span> our
notion of types and type <span style="font-style: italic">schemes</span>.  Intuitively, a type is a single thing,
while a type scheme can quantify over type variables.  Our goal will be to
infer a type scheme for each function in our program, and a type for each
expression.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._35._lecturetype-inference%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">When we get to higher-order languages, this split is not
quite so straightforward, and we&rsquo;ll need to revisit it slightly.</span></span></p><h4>1.1<tt>&nbsp;</tt><a name="(part._.Example_1)"></a>Example 1</h4><p>Suppose we have the program</p><p><div class="sourceCodeWrapper"><span data-label="Taipan" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def f(x):
  x + 6

f(38)</code></pre></div></div></p><p>Let&rsquo;s start by inferring a type for <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span>.  We have no annotations, so we
simply create new type variables as needed, and assert that <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span> has type
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T1 -&gt; 'T2</code></span>, for two unknown type variables <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T1</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T2</code></span>.  We begin to
infer a type for the body of <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span> by binding the arguments to their types
in our type environment &ndash; here, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">x : 'T1</code></span>.</p><p>We recur into the body of <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span>, and examine <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x + 6</code></span>.  This is an
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPrim2</code></span> expression, so we look up the type scheme for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Plus</code></span>, and see
that it is <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Forall [], (Int, Int -&gt; Int)</code></span>.  We look at the arguments to the
operator, and infer their types.  We look up <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> in the environment and
obtain <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T1</code></span>, and determine that all numbers have type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Int</code></span>.  We know
that this operation will produce some result type, so we make up a new type
variable <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'prim2result</code></span>.  We can now construct a type
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">('T1, Int -&gt; 'prim2result)</code></span>, and unify it with the type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(Int, Int -&gt; Int)</code></span>.  This
produces a substitution <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['T1 = Int, 'prim2result = Int]</code></span> We apply that
substitution, and deduce that <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">x : Int</code></span>.  The result of our expression
has type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'prim2result</code></span>, and since it is the entirety of the body of
<span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span>, we unify that with the result type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T2</code></span>, making sure to preserve
the substitution where <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['prim2result = Int]</code></span>.  Our net result is
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">f : Int -&gt; Int</code></span>, which we can generalize to the type scheme
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Forall [], Int -&gt; Int</code></span>, and update our function environment accordingly.</p><p>We next need to infer types for <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f(38)</code></span>.  We repeat a similar process:
we lookup the type scheme for <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span>, we infer a type for <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">38</code></span>, and
make up a new result type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'app_result</code></span>, and unify <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Int -&gt; Int</code></span> (which is
the type of <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span>) with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Int -&gt; 'app_result</code></span>.  We deduce that
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['app_result = Int]</code></span>, and this is the final type of our program.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Example_2)"></a>Example 2</h4><p>Suppose we have the following trickier program:
<div class="sourceCodeWrapper"><span data-label="Taipan" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def f(x, y):
  isnum(print(x)) &amp;&amp; isbool(y)

def g(z):
  f(z, 5)

g(7)</code></pre></div></div></p><p><p>Since our functions are not mutually recursive, we can handle them independently.
</p><ul><li><p>Start by guessing type variables for <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span>, namely <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">('T1, 'T2 -&gt; 'T3)</code></span>.</p></li><li><p>Next, we bind the arguments in our environment,</p><p><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">[x : 'T1, y : 'T2]</code></span>, and recur into the body.
</p><ul><li><p>Again we encounter a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPrim2</code></span>, so we lookup the type scheme for the
operator and get <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">&amp;&amp; : Forall [], (Bool, Bool -&gt; Bool)</code></span>.  We then infer
types for both arguments:</p><ul><li><p>Our first argument is a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPrim1</code></span>, so we look up the type scheme for
the operator and find <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">isnum : Forall ['X], ('X -&gt; Bool)</code></span>.  We cannot use
this directly, so we <span style="font-style: italic">instantiate</span> the type by creating new type variables
and substituting them: <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">isnum : ('T4 -&gt; Bool)</code></span>.  We recur on the argument:</p><ul><li><p>Our argument is another <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPrim1</code></span>, so we look up the type scheme for
the operator and find <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">print : Forall ['X], ('X -&gt; 'X)</code></span>.  Again we
instantiate the type to get <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">print : ('T5 -&gt; 'T5)</code></span>.  Then we recur on the
argument, and look it up to find <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">x : 'T1</code></span>.  We create a return type
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'prim1result1</code></span>, and unify <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T1 -&gt; 'prim1result1</code></span> with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T5 -&gt; 'T5</code></span>,
to obtain the substitution <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['T1 = 'T5, 'prim1result1 = 'T5]</code></span>.  Our result
type is <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'prim1result1</code></span>.</p></li><li><p>We create a new result type for this primitive, and unify
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'prim1result1 -&gt; 'prim1result2</code></span> with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T4 -&gt; Bool</code></span>, to obtain the
substitution <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['prim1result1 = 'T4, 'prim1result2 = Bool]</code></span>.  We combine that
with the existing substitution to get
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['T1 = 'T5, 'prim1result1 = 'T5, 'T4 = 'T5, 'prim1result2 = Bool]</code></span>, and
return a result of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'prim1result2</code></span>.</p></li></ul></li><li><p>Our second argument is another <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPrim1</code></span>, and the type inference for
this is analogous to that for <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">isnum</code></span>.  We look up the type scheme,
instantiate it to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">isbool : 'T6 -&gt; Bool</code></span>, and infer a type for the nested
expression.  We look that expression up to obtain <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">y : 'T2</code></span>, generate a new
result type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'prim1result3</code></span>, and unify <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T2 -&gt; 'prim1result3</code></span> with
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T6 -&gt; Bool</code></span>, to obtain <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['T2 = 'T6, 'prim1result3 = Bool]</code></span>.</p></li><li><p>We instantiate the type of the operator to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(Bool, Bool -&gt; Bool)</code></span>.  We
create  a result type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'prim2result1</code></span>, and unify the inferred type
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">('prim1result1, 'prim1result3 -&gt; 'prim2result1)</code></span> with
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(Bool, Bool -&gt; Bool)</code></span>, to get
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['prim1result1 = Bool, 'prim1result3 = Bool, 'prim2result1 = Bool]</code></span>.  We
combine this with all our prior substitutions, and return the result type
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'prim2result1</code></span>.</p></li></ul></li></ul></p></li><li><p>We unify <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'prim2result1</code></span> with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T3</code></span>, then apply our overall
substitution, and we obtain <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['T1 = 'T5, 'T2 = 'T6, 'T3 = Bool]</code></span> (along with
other substitutions).  Finally, we generalize this type, to get the final type
scheme <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">f : Forall ['T5, 'T6], ('T5, 'T6 -&gt; Bool)</code></span>.</p></li></ul></p><p>We can repeat the process for <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">g</code></span>, guessing an initial type of
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'T7 -&gt; 'T8</code></span>.  When we get to the function call, we
instantiate the type for <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span> to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">f : ('T9, 'T10 -&gt; Bool)</code></span>, and
proceed.  We wind up unifying <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['T7 = 'T9, 'T10 = Int, 'T8 = Bool]</code></span>, and
generalizing, we get a final type scheme of
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">g : Forall ['T9], ('T9 -&gt; Bool)</code></span>.</p><p>Finally we proceed to <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">g(7)</code></span>.  Again we instantiate the scheme for
<span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">g</code></span>, unify the result with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Int</code></span>, and obtain a final type of
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Bool</code></span>.  Our progam is self-consistent.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Type_inference_implementation)"></a>Type inference implementation</h3><h4>2.1<tt>&nbsp;</tt><a name="(part._.Preparation)"></a>Preparation</h4><p>To implement type inference ourselves, we&rsquo;ll need lots of preparatory definitions:</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Do these.</p></blockquote><ul><li><p>Define a <span style="font-style: italic">type environment</span> as a mapping from names to types, and a
<span style="font-style: italic">type scheme environment</span> as a mapping from names to type schemes.  Our
initial type scheme environment will contain type schemes for all our
primitives.  Our initial type environment will be empty.  We will use ML&rsquo;s
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.S.html">Map</a>s,
rather than association lists, because they are more efficient and our
environments are unordered.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a envt = 'a StringMap.t</code></pre></div></div></p></li><li><p>Define the notion of <span style="font-style: italic">substituting a type for a type variable, within
another type</span>.  This converts each occurrence of the given type variable
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">tyvar</code></span> into the desired type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">to_typ</code></span> in the target type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">in_typ</code></span>.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec subst_var_typ ((tyvar : string), (to_typ : 'a typ)) (in_typ : 'a typ) : 'a typ = ...</code></pre></div></div></p></li><li><p>Define the notion of <span style="font-style: italic">substituting a type for a type variable, within a
type scheme.</span>  This is the same idea as above, except that if the type variable
is quantified by the scheme, we do not substitute.  (This is exactly analogous
to capture-avoiding substitution of expressions for variables, underneath
lambda or let bindings.)</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec subst_var_scheme ((tyvar : string), (to_typ : 'a typ))
                         (in_scheme : 'a scheme) : 'a scheme = ...</code></pre></div></div></p></li><li><p>Define a <span style="font-style: italic">type substitution</span> as an ordered mapping from names to types.
(We use lists here to ensure an ordering, if it is needed.)</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a subst = (string * 'a) list</code></pre></div></div></p></li><li><p>Define a related set of functions that apply a substitution to a type, a type
scheme, or environments, by applying each individual substitution from
left-to-right.  You may not need all of these functions, but they&rsquo;re good to
have available.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let apply_subst_typ    (subst : 'a typ subst) (t : 'a typ) : 'a typ = ...
let apply_subst_scheme (subst : 'a typ subst) (s : 'a scheme) : 'a scheme = ...
let apply_subst_typenv (subst : 'a typ subst) (env : 'a typ envt) : 'a typ envt = ...
let apply_subst_schenv (subst : 'a typ subst) (env : 'a scheme envt) : 'a scheme envt = ...
let apply_subst_substs (subst : 'a typ subst) (sub : 'a typ subst) : 'a typ subst = ...</code></pre></div></div></p></li><li><p>Define a function to combine two substitutions, by first applying one to the
other, then concatenating the two.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let compose_subst (sub1 : 'a typ subst) (sub2 : 'a typ subst) : 'a typ subst =
  sub1 @ (apply_subst_subst sub1 sub2)</code></pre></div></div></p></li><li><p>Define the <span style="font-style: italic">free type variables of a type</span> as the
<a href="http://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.S.html">set</a>
of any type variables that appear within it.  Define the free type variables
<span style="font-style: italic">of a type scheme</span> as the type variables that appear un-quantified within
the scheme.  Finally, define the free type variables of a type environment as
simply the union of all the type variables in all the types within it.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec ftv_type (t : 'a typ) : StringSet.t =
  match t with
  | TyCon _ -&gt; StringSet.empty
  | TyVar(name, _) -&gt; StringSet.singleton name
  | TyArr(args, ret, _) -&gt;
    List.fold_right (fun t ftvs -&gt; StringSet.union (ftv_type t) ftvs)
                    args
                    (ftv_type ret)
  | TyApp(typ, args, _) -&gt;
    List.fold_right (fun t ftvs -&gt; StringSet.union (ftv_type t) ftvs)
                    args
                    (ftv_type typ)
;;
let ftv_scheme (s : 'a scheme) : StringSet.t =
  match s with
  | SForall(args, typ, _) -&gt;
     StringSet.diff (ftv_typ typ) (StringSet.of_list args)
let ftv_env (e : 'a typ envt) : StringSet.t = ...</code></pre></div></div></p></li></ul><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>You are welcome to clean this up and make it more efficient, by
passing along a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">StringSet.t</code></span> as an accumulator parameter, of all the free
type variables seen so far.</p></blockquote><h4>2.2<tt>&nbsp;</tt><a name="(part._.Unification)"></a>Unification</h4><p>The central operation of type inference is <span style="font-style: italic">unification</span>, which requests
that we make two types become equal by computing a substitution for their
free type variables under which the types really become identical:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec unify (t1 : 'a typ) (t2 : 'a typ) (* other bookkeeping *) : 'a typ subst = ...</code></pre></div></div></p><p>For example, we can unify <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'X -&gt; Int</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Bool -&gt; 'Y</code></span> under the
substitution <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['X = Bool, 'Y = Int]</code></span>.  If we apply this substitution to both
types, they both become <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Bool -&gt; Int</code></span> and are identical.</p><p>However, there is no substitution that can unify <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Int -&gt; 'X</code></span> with
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Bool -&gt; 'Y</code></span>.  Even if we set <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['X = 'Y]</code></span>, we cannot unify
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Bool</code></span> with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Int</code></span>.  We get a unification error, which we report
as a type error.</p><p>Our goal is to
produce as many substitutions as necessary: each substitution asserts that a
particular type <span style="font-style: italic">variable</span> must be equal to a particular <span style="font-style: italic">type</span>.
This is the key behind Hindley-Milner type inference.  We can <span style="font-style: italic">always</span>
guess a new type variable, and unification will steadily constrain that guess
with more and more equality constraints until we have a final answer, or a contradiction.</p><p>Note that we have to be careful in unifying too recklessly.  We cannot unify
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'A</code></span> with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'A -&gt; 'B</code></span>, because we would get the absurd
substitution <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">['A = 'A -&gt; 'B]</code></span>.  It is immediately clear that these two
types cannot be equal: the left side has &ldquo;one fewer arrows&rdquo; than the right
side.  To rule this out, we must perform an <span style="font-style: italic">occurs check</span>, to see whether
the variable we&rsquo;re trying to constrain appears within its constraint:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let occurs (name : string) (t : 'a typ) =
  StringSet.mem name (ftv_type t)</code></pre></div></div></p><p><p>Our unification proceeds by cases:
</p><ul><li><p>If either <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">t1</code></span> or <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">t2</code></span> is a type variable, and it does not occur in
the other type, then produce the substitution that binds it to the other type.</p></li><li><p>If we have two type constants (like <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">Int</code></span> or <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">Bool</code></span>) that
are equal, produce the empty substitution.  Otherwise, unification fails.</p></li><li><p>If we have two arrow types of the same arity, then unify the
corresponding arguments, and unify the return types.  The overall substitution
that unifies the two arrows is just the composition of all the resulting
substitutions together.</p></li><li><p>If we have two type applications of the same arity, then unify the
types and the corresponding type arguments.  The overall substitution that
unifies the two applications is just the composition of all the resulting
substitutions together.</p></li><li><p>All other cases result in a unification failure.</p></li></ul></p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>In the implementation of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">unify</code></span>, it is quite helpful to pass around
diagnostic information, such as a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">sourcespan</code></span> of the expression that
triggered the unification request (and possibly more information) so that your
error message can direct the programmer to where the problem occurred.
Consider what information might be useful, and extend the signature and
implementation of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">unify</code></span> accordingly.</p></blockquote><h4>2.3<tt>&nbsp;</tt><a name="(part._.Inference_and_.Instantiation)"></a>Inference and Instantiation</h4><p>Our goal in inferring types for our program is to compute a type for all
subexpressions, for which the program is entirely self-consistent.  To do this,
our signature will benefit from returning not only the computed type, but also
the substitution that we&rsquo;ve accumulated so far.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._36._lecturetype-inference%29%29" data-pltdoc="x">2</a></span></span><span class="FootnoteContent">If we had monadic
notation, as in Haskell, this syntactic overhead could be avoided.</span></span>  Our
primary function for type-inference of expressions will be</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec infer_exp (funenv : sourcespan scheme envt) (* environment for functions *)
                  (env : sourcespan typ envt) (* environment for variables *)
                  (e : sourcespan expr)
                  (* ... some bookkeeping ... *)
                  : ( sourcespan typ subst (* the resulting substitution *)
                    * sourcespan typ)      (* the resulting type *) =
  match e with
  ...</code></pre></div></div></p><p>Suppose we construct two base types,</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let tInt = TyCon("Int", dummy_sourcespan)
let tBool = TyCon("Bool", dummy_sourcespan)</code></pre></div></div></p><p>Then the first two cases of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">infer_exp</code></span> are easy:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec infer_exp funenv env e ... =
 match e with
  | ENumber _ -&gt; ([], tInt)
  | EBool _ -&gt; ([], tBool)
  ...</code></pre></div></div></p><p>Variables can be handled by looking them up in <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">env</code></span>.  But how should we
handle things like <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPrim1(Print, e, _)</code></span>?  After all, polymorphic operators
like these were why we built this whole new infrastructure!</p><p>The key observation is that <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> has the type scheme
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Forall 'X, ('X -&gt; 'X)</code></span>.  Therefore, it has the type
<span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">foo -&gt; foo</code></span>, <span style="font-style: italic">for any type</span> <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">foo</code></span> we want.  So our key step
is simply to <span style="font-style: italic">create</span> a fresh new type variable, one that&rsquo;s never been
used before in our program, and substitute it into the type scheme.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let gensym =
  let count = ref 0 in
  let next () =
    count := !count + 1;
    !count
  in fun str -&gt; sprintf "%s_%d" str (next ());;
let instantiate (s : 'a scheme) : 'a typ = ...</code></pre></div></div></p><p>Define a function <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">instantiate</code></span> that accomplishes this specialization step.
It will use the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">gensym</code></span> function to create any necessary new type
variables.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._37._lecturetype-inference%29%29" data-pltdoc="x">3</a></span></span><span class="FootnoteContent">Yes, we&rsquo;re using a stateful <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">gensym</code></span> instead of pure tags.
Since we don&rsquo;t know <span style="font-style: italic">a priori</span> how many times we&rsquo;ll instantiate a type
scheme, it&rsquo;s hard to know in advance what tags to even use.</span></span></p><p>We can now use this function to infer types for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">prim1</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">prim2</code></span>
constructs.  Populate the initial <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">funenv</code></span> with type schemes for all the
primitives by giving them unique names.  Each primitive should have some arrow
type, to record its argument type(s) and return type.  Then, in the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPrim1</code></span>
case:</p><ul><li><p>Lookup the relevant type scheme</p></li><li><p>Instantiate it to a type.</p></li><li><p>Infer a type for the argument(s) of the primitive.</p></li><li><p>Make up a brand-new type variable for the return type of the operation.</p></li><li><p>Construct a new arrow type using the inferred types of the argument(s)
and the made-up return type variable.</p></li><li><p>Recursively unify the looked-up arrow type of the operator, with the
constructed arrow type.</p></li><li><p>If all goes well, return the newly-constructed return type variable, and
the substitution obtained from the recursive unification call.</p></li></ul><p>A similar process applies for function-application expressions.</p><p>For conditionals, recursively infer types for the condition and the two
branches.  Then unify the condition&rsquo;s type with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">tBool</code></span>, and unify the two
branches&rsquo; types with each other.  The resulting type is the type of a branch,
and the resulting substitution is the composition of five smaller
substitutions: the three subexpressions, plus the two unifcation calls:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec infer_exp funenv env e ... =
 match e with
   ...
 | EIf(c, t, f, _) -&gt;
   (* After each inference, update the type environment *)
   let (c_subst, c_typ) = infer_exp funenv env c ... in
   let env = apply_subst_env c_subst env in
   let (t_subst, t_typ) = infer_exp funenv env t ... in
   let env = apply_subst_env t_subst env in
   let (f_subst, f_typ) = infer_exp funenv env f ... in
   let env = apply_subst_env f_subst env in
   (* Compose the substitutions together *)
   let subst_so_far = compose_subst (compose_subst c_subst t_subst) f_subst in
   (* rewrite the types *)
   let c_typ = apply_subst_typ subst_so_far c_typ in
   let t_typ = apply_subst_typ subst_so_far t_typ in
   let f_typ = apply_subst_typ subst_so_far f_typ in
   (* unify condition with Bool *)
   let unif_subst1 = unify c_typ tBool ... in
   (* unify two branches *)
   let unif_subst2 = unify t_typ f_typ ... in
   (* compose all substitutions *)
   let final_subst = compose_subst (compose_subst subst_so_far unif_subst1) unif_subst2 in
   let final_typ = apply_subst_typ final_subst t_typ in
   (final_subst, final_typ)
 | ...</code></pre></div></div></p><p>Handling let-bindings requires careful management of the environment.  Infer a
type for the first binding.  Add the variable and that type to the environment,
and recursively process the remaining bindings.  When no bindings remain,
process the body.  The resulting type is the type of the body, and the
resulting substitution is the composition of all the intermediate substitutions.</p><h4>2.4<tt>&nbsp;</tt><a name="(part._.Inference_and_.Generalization)"></a>Inference and Generalization</h4><p>It stands to reason that if <span style="font-style: italic">using</span> a function (in a function call)
instantiates its type scheme, then <span style="font-style: italic">defining</span> a function must somehow
generalize the type of the body into a type scheme.  This process is
straightforward: collect all the free type variables in the type of the
function body, subtract away any type variables that appear free in the type
environment, and whatever is leftover can be generalized into a type scheme.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Define a function</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let generalize (env : 'a typ envt) (t : 'a typ) : 'a scheme = ...</code></pre></div></div></p><p>that accomplishes this task.</p></blockquote><p>The challenges here mostly have to do with <span style="font-style: italic">when</span> to generalize which
function bodies.  To handle this, we will collect function definitions into
groups of mutually-recursive definitions.  To infer type schemes for a
definition group, instantiate the type schemes for the functions all at once.
Infer types for each function body, and accumulate the substitutions that
result.  Finally, generalize all the remaining types all at once.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Define two functions</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let infer_decl funenv env (decl : sourcespan decl) (* ... bookkeeping ... *)
    : (sourcespan scheme envt * sourcespan typ) = ...

let infer_group funenv env (group : sourcespan decl list) (* ... bookkeeping ...*)
    : sourcespan scheme envt =</code></pre></div></div></p><p>to accomplish this.  In <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">infer_decl</code></span>, you should assume that the function
you&rsquo;re inferring has already been instantiated to a (potentially unknown)
monomorphic type, while in <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">infer_group</code></span>, you should do the instantiation
and generalization.</p></blockquote><p>Consider the following two programs:
<div class="sourceCodeWrapper"><span data-label="Taipan" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def f(x): # should have scheme Forall 'X, ('X -&gt; 'X)
  print(x)

def ab_bool(a, b): # should have scheme Forall 'A, 'B, ('A, 'B -&gt; Bool)
  isnum(f(a)) &amp;&amp; f(b)

ab_bool(3, true) &amp;&amp; ab_bool(true, false)</code></pre></div></div></p><p>versus</p><p><div class="sourceCodeWrapper"><span data-label="Taipan" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def f(x):
  print(x)

and def ab_bool(a, b):
  isnum(f(a)) &amp;&amp; f(b) # ???

ab_bool(3, true) &amp;&amp; ab_bool(true, false)</code></pre></div></div></p><p>In this version of the program, since <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span> and <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">ab_bool</code></span> are
mutually recursive, <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f</code></span> can only have one type within the body of
<span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">ab_bool</code></span>, and so the line with the question marks cannot typecheck.</p><p>On the other hand, consider a simple pair of mutually recursive functions:
<div class="sourceCodeWrapper"><span data-label="Taipan" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def even(n):
  not(odd(n))

and def odd(n):
  if n == 0: false
  else: if n == 1: true
  else:
    even(n - 1)

odd(5)</code></pre></div></div></p><p>If these two functions were not mutually recursive (marked by the <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">and</code></span>
keyword), then <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">even</code></span> would have type <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Forall 'X, 'X -&gt; Bool</code></span>,
since it never uses <span title="Taipan" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">n</code></span> in any particular way.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Putting_it_all_together)"></a>Putting it all together</h3><p>We&rsquo;re nearly finished.  Define a function</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let infer_prog (funenv : sourcespan scheme envt) (env : sourcespan typ envt)
               (p : sourcespan program) : sourcespan program = ...</code></pre></div></div></p><p>that either returns the program if it successfully infers a type, or raises an
exception if it fails.  Finally, define</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let type_synth (p : sourcespan program) : sourcespan program fallible =
  try
    Ok(infer_prog initial_env StringMap.empty p)
  with e -&gt; Error([e])
;;</code></pre></div></div></p><p>And we&rsquo;re done!</p><h4>3.1<tt>&nbsp;</tt><a name="(part._.Challenges_and_hints)"></a>Challenges and hints</h4><p>At the end of every inference call, be sure to apply the resulting substitution
to the resulting type, to ensure that the types are as fully-rewritten as
possible.  This helps ensure that we only need to apply each substitution once
to get the correct results.</p><p>Also be sure never to reuse type variables.  When in doubt, gensym an extra one
and unify it wherever needed.  But be sure never to discard the resulting
substitutions!</p><p>Be careful with the occurs check.  Right now it won&rsquo;t impact us, because we
don&rsquo;t have higher-order functions or other type constructors, but once we do,
this can be the source of some very subtle bugs.</p><p>Test thoroughly!  You will need to write larger programs than before, to test
how unification constraints are propagated throughout your inference process.</p><p>Avail yourself of debug-printing output, at many stages of the process.  You
will always want more information than you have, in order to debug why
something went wrong during inference.  Once you&rsquo;ve implemented this inference
process, you should have a much greater sympathy for compiler authors who
provide inscrutable unification error messages!  Try to record as many bits of
debugging information as possible.</p><a name="(part._(gentag._34._lecturetype-inference))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._35._lecturetype-inference))"></a>1</span></span>When we get to higher-order languages, this split is not
quite so straightforward, and we&rsquo;ll need to revisit it slightly.</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._36._lecturetype-inference))"></a>2</span></span>If we had monadic
notation, as in Haskell, this syntactic overhead could be avoided.</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._37._lecturetype-inference))"></a>3</span></span>Yes, we&rsquo;re using a stateful <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">gensym</code></span> instead of pure tags.
Since we don&rsquo;t know <span style="font-style: italic">a priori</span> how many times we&rsquo;ll instantiate a type
scheme, it&rsquo;s hard to know in advance what tags to even use.</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>