<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 16: Supporting Object-Oriented Programming</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 16:</span> Supporting Object-<wbr></wbr>Oriented Programming</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Supporting_.Object-.Oriented_.Programming%29" class="tocviewlink" data-pltdoc="x">Supporting Object-<wbr></wbr>Oriented Programming</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Static_type_system_issues%29" class="tocviewlink" data-pltdoc="x">Static type system issues</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Representing_objects_in_memory%29" class="tocviewlink" data-pltdoc="x">Representing objects in memory</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Compilation_of_methods%29" class="tocviewlink" data-pltdoc="x">Compilation of methods</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Supporting_instanceof%29" class="tocviewlink" data-pltdoc="x">Supporting <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">instanceof</code></span></a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 16:</span> Supporting Object-<wbr></wbr>Oriented Programming</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Supporting_.Object-.Oriented_.Programming%29" class="tocsubseclink" data-pltdoc="x">Supporting Object-<wbr></wbr>Oriented Programming</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Static_type_system_issues%29" class="tocsubseclink" data-pltdoc="x">Static type system issues</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Representing_objects_in_memory%29" class="tocsubseclink" data-pltdoc="x">Representing objects in memory</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Simple_objects%29" class="tocsubseclink" data-pltdoc="x">Simple objects</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Inheritance_of_fields%29" class="tocsubseclink" data-pltdoc="x">Inheritance of fields</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Compilation_of_methods%29" class="tocsubseclink" data-pltdoc="x">Compilation of methods</a></td></tr><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.Simple_methods_and_this%29" class="tocsubseclink" data-pltdoc="x">Simple methods and <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">this</code></span></a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._.Inheritance_of_methods%29" class="tocsubseclink" data-pltdoc="x">Inheritance of methods</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Supporting_instanceof%29" class="tocsubseclink" data-pltdoc="x">Supporting <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">instanceof</code></span></a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="LectureNum">Lecture 16:</span> Supporting Object-Oriented Programming</h2><h3>1<tt>&nbsp;</tt><a name="(part._.Supporting_.Object-.Oriented_.Programming)"></a>Supporting Object-Oriented Programming</h3><p>So far our language is mostly-pure, functional and expression-based.  There are
obviously many other styles of languages and many other language features to
consider supporting; one of the most salient is object-oriented programming.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What language features would you consider to be essential for
supporting object-oriented programming?  Why?</p></blockquote><p>The primary feature of an object-oriented language is the eponymous
<span style="font-style: italic">object</span>: a new kind of value that contains both local state and local
computation.  To support objects, we potentially need a bunch of related
features:</p><ul><li><p><span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">this</code></span></p></li><li><p>Methods</p></li><li><p>Fields</p></li><li><p>Dynamic dispatch</p></li><li><p>Inheritance</p></li><li><p>Overriding</p></li><li><p>Overloading</p></li><li><p><span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">instanceof</code></span></p></li><li><p>Classes and constructors</p></li></ul><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Which of these features are intrinsically <span style="font-style: italic">statically-typed</span>,
and which ones might apply in a dynamically-typed language also?</p></blockquote><p>Looking just at dynamically-typed languages: JavaScript gets by without classes
or overloading, while Python has classes but no overloading.  Both languages
have a notion of <span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">instanceof</code></span> and inheritance, whether or not they have
classes.  Both languages fields, <span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">this</code></span>, methods, dynamic
dispatch and overriding.  Evidently, these features aren&rsquo;t a all-or-nothing
design choice.</p><p>Classes, in particular, have two roles: they <span style="font-style: italic">dynamically</span> provide a way
to construct new objects and determine <span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">instanceof</code></span> relationships and
method implementations, and they <span style="font-style: italic">statically</span> can define inheritance
relationships and static type system choices.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Static_type_system_issues)"></a>Static type system issues</h3><p>Let&rsquo;s just consider constructing objects for now; field accesses and method
accesses add even more static complexity.  To a crude first approximation,
every class definition creates a new type, distinct from all other types.  The
constructor for a class is simply a function that returns an instance of that
type.  Ignoring syntactic details, we might model this as saying,
<span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">class Foo { Foo(int x) { ... } ... }</code></span> defines a function <span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">new-Foo</code></span>
of type <span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">Int -&gt; Foo</code></span>.  Since <span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">Foo</code></span> is a brand-new type, and
<span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">new-Foo</code></span> is the only function that creates such a type, we are guaranteed
that this constructor function is the only way to construct an instance of
<span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">Foo</code></span>.</p><p>Or is it?  Consider two classes in a Java-like language:
<div class="sourceCodeWrapper"><span data-label="Java" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">class Base {
  ...
}
class Derived extends Base {
  ...
}

// Elsewhere in the program
Base b = new Derived(); // Why is this legal?</code></pre></div></div></p><p>The intent behind subclassing is two-fold: to assert that every instance of the
derived class is also an instance of the base class, and for every instance of
the derived class to inherit all the behaviors and state of the base class.  To
handle this scenario, we need a new <span style="font-style: italic">subtyping relation</span> as part of our
type system, to model when values of one type can safely be considered values
of another type.  For example, we might define the rule</p><p><p type="math/tex" style="white-space: pre;" class="math-tex">\begin{equation*}\dfrac{\texttt{class D extends B}}{D &lt;: B}\end{equation*}</p></p><p>Read this rule as, &ldquo;D is a subtype of B when we have a declaration
<span title="Java" class="sourceCode"><code data-lang="text/x-java" class="sourceCode">class D extends B</code></span>.&rdquo;  We use the symbol <span type="math/tex" style="white-space: pre;" class="math-tex">\(&lt;:\)</span> as a visual
contraction of both &ldquo;less-than&rdquo; and &ldquo;has-type&rdquo;.</p><p>(Note that this is different from saying that one particular
type might be an instantiation of some other polymorphic type scheme.
Instantiating a type scheme allows us to say, &ldquo;there exists a way for me to
make these two types <span style="font-style: italic">equal</span>.&rdquo;  Subtyping, on the other hand, lets us say
&ldquo;this type is less-than-or-equal, or more-specific-than, this other type.&rdquo;
It is a qualitatively different kind of relationship.)  Adding a subtyping
relation fits in neatly to type systems, at least in terms of judgement rules:</p><p><p type="math/tex" style="white-space: pre;" class="math-tex">\begin{equation*}\dfrac{e : \mathsf{\tau_1} \quad \tau_1 &lt;: \tau2}{e : \mathsf{\tau_2}}\end{equation*}</p></p><p>The challenge is when and how to apply this subtyping rule: we don&rsquo;t know what
<span type="math/tex" style="white-space: pre;" class="math-tex">\(\tau_1\)</span> is!  Worse, subtyping obeys a <span style="font-style: italic">transitivity rule</span>,
analogous to transitivity for less-than, that says</p><p><p type="math/tex" style="white-space: pre;" class="math-tex">\begin{equation*}\dfrac{\tau_1 &lt;: \tau2 \quad \tau_2 &lt;: \tau_3}{\tau_1 &lt;: \tau_3}\end{equation*}</p></p><p>In words, if one type is a subtype of a second, and that second is a subtype of
a third type, then the first type is a subtype of the third.  Once again, this
rule is difficult to use well, because we have to guess the middle type (or
types, if we use the rule repeatedly!).</p><p>These difficulties make both type checking and type inference difficult: unless
the input programs are sufficiently annotated, we can&rsquo;t guess what type
derivations are needed.  Since designing a sufficiently powerful type system is
not our goal right now, we&rsquo;ll abandon the static typing implications of
classes, and focus on the dynamic implications.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Representing_objects_in_memory)"></a>Representing objects in memory</h3><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What well-formedness errors might we want to enforce on class
definitions, to ensure that any field declarations make sense?  How might that
change (or be refined) in the presence of inheritance?</p></blockquote><h4>3.1<tt>&nbsp;</tt><a name="(part._.Simple_objects)"></a>Simple objects</h4><p>Reasoning by similarity, a class is &ldquo;like a tuple, but with named fields&rdquo;.
Accordingly we might choose a representation similar to tuples for our objects:
some header information (perhaps indicating the size of the object), followed
by a bunch of words, one per field.  Of course, we&rsquo;d need to tag our values as
objects, and we&rsquo;ve run out of tags...  We have a few options:</p><ul><li><p>We could remove tuples from our language, and reuse that tag for
objects.</p></li><li><p>We could force a 16-byte alignment policy, and gain one more tag bit.</p></li><li><p>We could change our tagging strategy entirely, such that a tag indicates
Boolean, Int, or On-the-heap, and the first word of every heap-allocated value
contains another tag indicating which sort of value it is.</p></li></ul><p>This last strategy seems the most invasive (and it substantially complicates
our tag-checking code), but is likely the most flexible.  For now though, we&rsquo;ll
assume the first strategy, and just focus on objects while excluding tuples.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Brainstorm the upcoming challenges here: how do we lay out fields
within the object?  What other OO features complicate matters?</p></blockquote><p>To determine which field offset corresponds to which named field, our
compiler can build a table mapping class names and field names to indices &#8212;<wbr></wbr>
preserving the declaration order of the fields in a class.  For example, given</p><p><div class="sourceCodeWrapper"><span data-label="Viper" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">class Point2d:
  fields x, y
  ...
end
class Foo:
  fields a, b, x
  ...
end</code></pre></div></div>
we would record that <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> is found at offset 0 in <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">Point</code></span> objects,
and at offset 8 in <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">Foo</code></span> objects (ignoring for a moment however many
header words we need).  We would carry this environment around into
compilation.  When we encounter a field-lookup expression, we know the field
name at compile time,<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._20._lectureobjects%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">Contrast this with languages like JavaScript, where
field names can be dynamically constructed, and objects are nothing more than
dictionaries.</span></span> so we can look the name up in the map and obtain the necessary
offset to use.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Inheritance_of_fields)"></a>Inheritance of fields</h4><p>Suppose we declared a class</p><p><div class="sourceCodeWrapper"><span data-label="Viper" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">class Point3d extends Point2d:
  fields z
  ...
end</code></pre></div></div></p><p>How many fields should we have in each <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">Point3d</code></span> object, and at what
offsets?  Because we know at compile time which classes extend which others, we
can compute that <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">Point3d</code></span> contains three fields.  Moreover, we want
every <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">Point3d</code></span> instance to &ldquo;look like&rdquo; a <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">Point2d</code></span> instance:</p><p><div class="sourceCodeWrapper"><span data-label="Viper" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def xyDist(p : Point2d):
  p.y - p.x

xyDist(new Point3d(3, 4, 5)) # should produce 1, rather than crash</code></pre></div></div></p><p>Therefore, we must lay out all the base class&rsquo;s fields in order,
<span style="font-style: italic">followed</span> by any new fields from the derived class.  This proceeds
recursively up the class hierarchy: if we have a class <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">C3</code></span> that extends another
class <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">C2</code></span> that itself extends a base class <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">C1</code></span>, we would lay out
<span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">C1</code></span>&rsquo;s fields first (in order), followed by <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">C2</code></span>&rsquo;s fields, followed
finally by <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">C3</code></span>&rsquo;s fields.  This way, even in functions like
<span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">xyDist</code></span>, which expect a base-class object, the field accesses will use
the correct offsets in derived-class objects, because the two classes agree on
locations for fields they share in common.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Given this layout description, explain why multiple inheritance is
remarkably difficult to do well.</p></blockquote><h3>4<tt>&nbsp;</tt><a name="(part._.Compilation_of_methods)"></a>Compilation of methods</h3><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What new well-formedness errors might we want to enforce on class
definitions, now that they have both fields and methods?</p></blockquote><h4>4.1<tt>&nbsp;</tt><a name="(part._.Simple_methods_and_this)"></a>Simple methods and <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">this</code></span></h4><p>The crucial distinction between <span style="font-style: italic">methods</span> and mere <span style="font-style: italic">functions</span> is the
presence of <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">this</code></span>: the ability for each method to know what object it
was invoked on, so that it can access the object&rsquo;s fields.  However we compile
method invocations, we must somehow supply this extra parameter.</p><p>Consider the expression <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">o.m(a)</code></span>.  Assuming that we ensure that field
names and method names are mutually unique (such that we prohibit having a
field and a method of the same name), then we can always tell whether <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">m</code></span>
is a method, or a field that happens to contain a function.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Is this assumption easy to enforce?  Consider the cases where
<span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">o</code></span> is declared to have a type that is any class, a base class, or a
derived class, and whether <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">m</code></span> is declared in that class, a base class,
or a derived class.  Are there any cases where we cannot know what <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">m</code></span>
is?  Could such cases be compile-time errors?</p></blockquote><h4>4.2<tt>&nbsp;</tt><a name="(part._.Inheritance_of_methods)"></a>Inheritance of methods</h4><h3>5<tt>&nbsp;</tt><a name="(part._.Supporting_instanceof)"></a>Supporting <span title="Viper" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">instanceof</code></span></h3><a name="(part._(gentag._19._lectureobjects))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._20._lectureobjects))"></a>1</span></span>Contrast this with languages like JavaScript, where
field names can be dynamically constructed, and objects are nothing more than
dictionaries.</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>