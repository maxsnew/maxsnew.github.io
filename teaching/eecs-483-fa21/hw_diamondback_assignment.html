<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Assignment 5: Diamondback: Defining functions</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="rust.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 5:</span> Diamondback:<span class="mywbr"> &nbsp;</span> Defining functions</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.The_.Diamondback_.Language%29" class="tocviewlink" data-pltdoc="x">The Diamondback Language</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Running_main%29" class="tocviewlink" data-pltdoc="x">Running main</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.List_of_.Deliverables%29" class="tocviewlink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Grading_.Standards%29" class="tocviewlink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Submission%29" class="tocviewlink" data-pltdoc="x">Submission</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="AssignmentNum">Assignment 5:</span> Diamondback:<span class="mywbr"> &nbsp;</span> Defining functions</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.The_.Diamondback_.Language%29" class="tocsubseclink" data-pltdoc="x">The Diamondback Language</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._.Concrete_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Concrete Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._.Abstract_.Syntax%29" class="tocsubseclink" data-pltdoc="x">Abstract Syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._.Semantics%29" class="tocsubseclink" data-pltdoc="x">Semantics</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part._.Implementation%29" class="tocsubseclink" data-pltdoc="x">Implementation</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#%28part._.Tail_calls%29" class="tocsubseclink" data-pltdoc="x">Tail calls</a></td></tr><tr><td><span class="tocsublinknumber">1.6<tt>&nbsp;</tt></span><a href="#%28part._.Extra_credit__.Printing_stack_traces%29" class="tocsubseclink" data-pltdoc="x">Extra credit:<span class="mywbr"> &nbsp;</span> Printing stack traces</a></td></tr><tr><td><span class="tocsublinknumber">1.7<tt>&nbsp;</tt></span><a href="#%28part._.Testing%29" class="tocsubseclink" data-pltdoc="x">Testing</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Running_main%29" class="tocsubseclink" data-pltdoc="x">Running main</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.List_of_.Deliverables%29" class="tocsubseclink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Grading_.Standards%29" class="tocsubseclink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Submission%29" class="tocsubseclink" data-pltdoc="x">Submission</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.2</span></div><h2><a name="(part._)"></a><span class="AssignmentNum">Assignment 5:</span> Diamondback: Defining functions</h2><p><h4 class="due">Due: Tue 10/26 at 8:59pm</h4></p><p><p class="git-clone"><code><span class="kw">git clone </span><input onclick="this.select();" readonly="readonly" value="https://gitlab.com/eecs-483/starter-code/diamondback"/></code></p></p><p><span class="emph">In this assignment, you&rsquo;ll implement a compiler for a small
language with functions declarations and function calls, that can
communicate with functions written in Rust.  You&rsquo;ll also add some
static well-formedness checks to the compiler.</span></p><p><span class="emph">As for the project acronym, so far our greatest minds have come up with</span></p><ul><li><p><span style="font-weight: bold">D</span>esigning an</p></li><li><p><span style="font-weight: bold">I</span>ntel <span style="font-weight: bold">A</span>rchitecture</p></li><li><p><span style="font-weight: bold">MO</span>stly dynamic</p></li><li><p><span style="font-weight: bold">N</span>ested-expression</p></li><li><p>(<span style="font-weight: bold">D</span>iamondback supports recursion)</p></li><li><p><span style="font-weight: bold">B</span>oolean-tagged</p></li><li><p><span style="font-weight: bold">A</span>rithmetic-supporting</p></li><li><p><span style="font-weight: bold">C</span>ompiler.</p></li><li><p>...<span style="font-weight: bold">K</span>?</p></li></ul><p><a href="https://upload.wikimedia.org/wikipedia/commons/d/d4/Crotalus_ruber_02.jpg">Click here for scary snake picture!</a></p><h3>1<tt>&nbsp;</tt><a name="(part._.The_.Diamondback_.Language)"></a>The Diamondback Language</h3><p>As usual, we have concrete and abstract syntaxes, along with a specification
of semantics.</p><h4>1.1<tt>&nbsp;</tt><a name="(part._.Concrete_.Syntax)"></a>Concrete Syntax</h4><p>The major addition to Diamondback are <span class="emph">function declarations</span>.  Our programs
are now a sequence of zero or more function declarations, followed by a single
<span class="emph">main expression</span>.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Diamondback._program)))"></a><span class="bnf-rule">&#8249;program&#8250;</span><span class="bnf-meta">:</span> 
                <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._decls%29%29%29" data-pltdoc="x">&#8249;decls&#8250;</a></span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
                <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Diamondback._binop-expr)))"></a><span class="bnf-rule">&#8249;binop-expr&#8250;</span><span class="bnf-meta">:</span> 
                      <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">NUMBER</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">true</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">false</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">!</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></span>
                      <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._prim1%29%29%29" data-pltdoc="x">&#8249;prim1&#8250;</a></span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
                      <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._prim2%29%29%29" data-pltdoc="x">&#8249;prim2&#8250;</a></span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span> <span class="bnf-lit">)</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class="bnf-lit">)</span>
                      <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Diamondback._prim1)))"></a><span class="bnf-rule">&#8249;prim1&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class="bnf-lit">add1</span><span class="bnf-meta"> | </span><span class="bnf-lit">sub1</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">print</span><span class="bnf-meta"> | </span><span class="bnf-lit">printStack</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">isbool</span><span class="bnf-meta"> | </span><span class="bnf-lit">isnum</span>
<a name="(elem._(bnf-prod._(.Diamondback._prim2)))"></a><span class="bnf-rule">&#8249;prim2&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class="bnf-lit">+</span><span class="bnf-meta"> | </span><span class="bnf-lit">-</span><span class="bnf-meta"> | </span><span class="bnf-lit">*</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">&lt;</span><span class="bnf-meta"> | </span><span class="bnf-lit">&gt;</span><span class="bnf-meta"> | </span><span class="bnf-lit">&lt;=</span><span class="bnf-meta"> | </span><span class="bnf-lit">&gt;=</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">==</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">&amp;&amp;</span><span class="bnf-meta"> | </span><span class="bnf-lit">||</span>
<a name="(elem._(bnf-prod._(.Diamondback._decls)))"></a><span class="bnf-rule">&#8249;decls&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._decl%29%29%29" data-pltdoc="x">&#8249;decl&#8250;</a></span>
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._decl%29%29%29" data-pltdoc="x">&#8249;decl&#8250;</a></span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._decls%29%29%29" data-pltdoc="x">&#8249;decls&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Diamondback._decl)))"></a><span class="bnf-rule">&#8249;decl&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class="bnf-lit">def</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._ids%29%29%29" data-pltdoc="x">&#8249;ids&#8250;</a></span> <span class="bnf-lit">)</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">end</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">def</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class="bnf-lit">)</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Diamondback._ids)))"></a><span class="bnf-rule">&#8249;ids&#8250;</span><span class="bnf-meta">:</span> 
        <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span>
        <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._ids%29%29%29" data-pltdoc="x">&#8249;ids&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Diamondback._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class="bnf-lit">let</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._bindings%29%29%29" data-pltdoc="x">&#8249;bindings&#8250;</a></span> <span class="bnf-lit">in</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">if</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">else:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._binop-expr%29%29%29" data-pltdoc="x">&#8249;binop-expr&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Diamondback._exprs)))"></a><span class="bnf-rule">&#8249;exprs&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Diamondback._bindings)))"></a><span class="bnf-rule">&#8249;bindings&#8250;</span><span class="bnf-meta">:</span> 
                  <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">=</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
                  <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">=</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Diamondback._bindings%29%29%29" data-pltdoc="x">&#8249;bindings&#8250;</a></span></p></blockquote><p>The other addition is <span class="emph">function applications</span>, which are written
<code><span class="bnf-lit bnf-unknown">IDENTIFIER</span>(<a href="#%28elem._%28bnf-prod._%28.Diamondback._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a>)</code>, for
example <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f(1, 2, 3)</code></span>.  This is the syntax for a <span class="emph">call</span> to a function.</p><h4>1.2<tt>&nbsp;</tt><a name="(part._.Abstract_.Syntax)"></a>Abstract Syntax</h4><p>In this assignment, we add two new AST types: <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Prog</code></span> for
representing programs and <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">FunDecl</code></span> for representing function
declarations:
<div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">struct Prog&lt;E, Ann&gt; {
    funs: Vec&lt;FunDecl&lt;E, Ann&gt;&gt;,
    main: E,
    ann: Ann,
}

struct FunDecl&lt;E, Ann&gt; {
    name: String,
    parameters: Vec&lt;String&gt;,
    body: E,
    ann: Ann,
}</code></pre></div></div></p><p>These types are parameterized by a type of annotations <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Ann</code></span> as
well as a type of expressions <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">E</code></span>. This way we can abstract over
programs containing arbitrary expressions versus and programs
containing only sequential expressions. We define "Surface language"
programs and function declarations versus "sequential" programs and
declarations as type aliases:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">type SurfProg&lt;Ann&gt; = Prog&lt;Exp&lt;Ann&gt;, Ann&gt;;
type SurfFunDecl&lt;Ann&gt; = FunDecl&lt;Exp&lt;Ann&gt;, Ann&gt;;

type SeqProg&lt;Ann&gt; = Prog&lt;SeqExp&lt;Ann&gt;, Ann&gt;;
type SeqFunDecl&lt;Ann&gt; = FunDecl&lt;SeqExp&lt;Ann&gt;, Ann&gt;;</code></pre></div></div></p><p>Additionally we add forms for function calls to expressions and
sequential expressions.</p><h4>1.3<tt>&nbsp;</tt><a name="(part._.Semantics)"></a>Semantics</h4><p>There are several distinguishing features of Diamondback.  The first is
function applications.  A function application should give the answer we&rsquo;d get
if we followed the rules for substituting argument values for parameter names.
So, for example:</p><p><div class="sourceCodeWrapper"><span data-label="Diamondback" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def f(x, y):
  x + y

f(1, 2)</code></pre></div></div></p><p>should produce 3.</p><p>Logical operators <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">&amp;&amp;</code></span> and <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">||</code></span> do not need to
short-circuit; they should have the same behavior as you gave them in <a href="hw_cobra_assignment.html" data-pltdoc="x">Assignment 4</a>.</p><p>Since our Diamondback functions only call other Diamondback functions, rather
than arbitrary functions in C, you can use a simpler calling convention than the
full x64 calling convention: you can simply push all the arguments onto the
stack and pop them all back off again.  For primitives like
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span>, obviously, you&rsquo;ll need to follow the proper
<a href="https://eli.thegreenplace.net/2011/09/06/stack-frame-layout-on-x86-64">x64
stack layout</a>.  (If you&rsquo;d like to use the x64 calling convention everywhere,
you may do so, but it is more complicated for functions of more than 6 arguments. Test thoroughly.)</p><p>There are a number of new <span class="emph">errors</span> that can occur now that we have function
declarations and calls.  Your implementation should catch all of these cases
<span class="emph">statically</span>; that is, at compile time before the program runs:</p><ul><li><p>A function application with the wrong number of arguments should signal an
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">FunctionCalledWrongArity</code></span> error</p></li><li><p>If you apply a function <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">f</code></span> but there is a local variable
named <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">f</code></span>, you should signal a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">ValueUsedAsFunction</code></span></p></li><li><p>A function application of a non-existent function <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">f</code></span> that
is not a locally defined variable should signal an
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">UndefinedFunction</code></span> error.</p></li><li><p>An identifier <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">x</code></span> used in a value position with no corresponding let declaration and no function declaration should report an <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">UnboundVariable</code></span> error</p></li><li><p>An identifier <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">x</code></span> used in a value position with no corresponding let declaration but where there is a function declaration defining <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">x</code></span> should report a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">FunctionUsedAsValue</code></span> error</p></li><li><p>A let binding with duplicate names should report a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">DuplicateBinding</code></span> error</p></li><li><p>A function declaration with duplicate names in the argument list should
report a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">DuplicateArgName</code></span> error</p></li><li><p>If there are multiple function definitions with the same name
and arity, report a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">DuplicateFunName</code></span> error. You can support
overloading if you wish, but it might not be allowed in future
assignments</p></li><li><p>If a numeric constant is too large, report an <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Overflow</code></span> error</p></li></ul><p>Again, these errors should stop the program from compiling, in your
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">check_prog</code></span> function, <span class="emph">not</span> happen at runtime.</p><h4>1.4<tt>&nbsp;</tt><a name="(part._.Implementation)"></a>Implementation</h4><p>The file <code>asm.rs</code> gives you all the assembly instructions you should
need, though you&rsquo;re free to add your own new instructions if you want.</p><p>There are a few new pieces to the implementation:</p><ul><li><p>A new <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">check_prog</code></span> function which should be an extension of
your previous <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">check</code></span> function to account for the additional
errors above.</p></li><li><p>The <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Prog</code></span> structure, which contains both function declarations and the
  expression for <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">start_here</code></span>.  You will probably want to generate
  an assembly structure that looks like:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ;; extern and global stuff
section .text
...
fun_decl1:
  ;; code for fun_decl1, including stack management
fun_decl2:
  ;; code for fun_decl2, including stack management
...
start_here:
  ;; main entrypoint, as before, with stack management

  ;; errors, as before
internal_error_non_number:
...</code></pre></div></div></p><p>(Hint: while the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Prog</code></span> construct is not quite uniform, since the body
is treated separately from the function definitions, a relatively
simple observation makes generating the output assembly of the entire program
very uniform...)</p></li></ul><h4>1.5<tt>&nbsp;</tt><a name="(part._.Tail_calls)"></a>Tail calls</h4><p>Refine your compilation of function
applications to support tail-calls.  There are three levels of complexity here:</p><ul><li><p><span style="font-weight: bold">required</span> Support arbitrary tail-calls where the caller
and callee have the same number of arguments</p></li><li><p><span style="font-weight: bold">optional, for bonus points</span> Support arbtirary tail-calls where the callee has fewer arguments than the caller.</p></li><li><p><span style="font-weight: bold">optional, for bonus points</span> Support arbitrary tail-calls, where the callee can have more arguments than the caller.</p></li></ul><p>To support the last one, you&rsquo;ll need to be creative with the calling
convention.  The only truly essential feature of a stack frame is knowing where
the saved <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span>, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> and return addresses must be, and all other
variables&rsquo; locations can be calculated from knowing those.  In particular,
you&rsquo;ll need to change the ordering of values in your stack frame, where
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> points between parameters and locals.  Instead, both parameters and
locals will need to be above <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span>: change your compilation
of function calls &#8212;<wbr></wbr> and anything else that is affected! &#8212;<wbr></wbr> to support this
new convention.  This change will prevent you from using the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span>
instruction (why?), so you&rsquo;ll need to come up with something clever to save
the desired return address.  Come see me if you try this, for a hint.</p><p>To detect that you&rsquo;ve implemented tail calls correctly, you may want to attempt
the following extra credit.</p><h4>1.6<tt>&nbsp;</tt><a name="(part._.Extra_credit__.Printing_stack_traces)"></a>Extra credit: Printing stack traces</h4><p>Implement a new <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">prim1</code></span> operator, <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">printStack</code></span>, that takes a
single argument and returns it, just like <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> does.  What makes
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">printStack</code></span> special is its output: it will print out a stack trace
of all the call frames from wherever it&rsquo;s called, down to wherever
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">our_code_starts_here</code></span> began.  For example, given the following program:
<div class="sourceCodeWrapper"><span data-label="Diamondback" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def fact(acc, n):
  if n &lt; 1: printStack(acc)
  else: fact(acc * n, n - 1) + 0
  # NOTE: This + 0 is to prevent tail-recursion in this example
end

fact(1, 3)</code></pre></div></div>
Here is a potential stack trace:</p><p><div class="sourceCodeWrapper"><div class="sourceCode"><pre data-lang="" class="sourceCode"><code data-lang="" class="sourceCode">RSP: 0x00007ffc352b1bb0	==&gt;  0
RBP: 0x00007ffc352b1bd0	==&gt;  70360600251912
(difference: -4)
Requested return val: 0x000000000000000c	==&gt; 6
Num args: 2
    0x00007ffc352b1bb0: 000000000000000000	==&gt;  old rbp
    0x00007ffc352b1bb8: 000000000000000000	==&gt;  0
    0x00007ffc352b1bc0: 000000000000000000	==&gt;  0
    0x00007ffc352b1bc8: 0xffffffffffffffff	==&gt;  true
RBP 0x00007ffc352b1bd0: 0x00007ffc352b1c10	==&gt;  old rbp
    0x00007ffc352b1bd8: 0x0000000000401077	==&gt;  saved ret
    0x00007ffc352b1be0: 0x000000000000000c	==&gt;  6
    0x00007ffc352b1be8: 000000000000000000	==&gt;  0
    0x00007ffc352b1bf0: 000000000000000000	==&gt;  0
    0x00007ffc352b1bf8: 000000000000000000	==&gt;  0
    0x00007ffc352b1c00: 0x000000000000000c	==&gt;  6
    0x00007ffc352b1c08: 0x7fffffffffffffff	==&gt;  false
RBP 0x00007ffc352b1c10: 0x00007ffc352b1c50	==&gt;  old rbp
    0x00007ffc352b1c18: 0x0000000000401077	==&gt;  saved ret
    0x00007ffc352b1c20: 0x000000000000000c	==&gt;  6
    0x00007ffc352b1c28: 0x0000000000000002	==&gt;  1
    0x00007ffc352b1c30: 000000000000000000	==&gt;  0
    0x00007ffc352b1c38: 0x0000000000000002	==&gt;  1
    0x00007ffc352b1c40: 0x000000000000000c	==&gt;  6
    0x00007ffc352b1c48: 0x7fffffffffffffff	==&gt;  false
RBP 0x00007ffc352b1c50: 0x00007ffc352b1c90	==&gt;  old rbp
    0x00007ffc352b1c58: 0x0000000000401077	==&gt;  saved ret
    0x00007ffc352b1c60: 0x0000000000000006	==&gt;  3
    0x00007ffc352b1c68: 0x0000000000000004	==&gt;  2
    0x00007ffc352b1c70: 000000000000000000	==&gt;  0
    0x00007ffc352b1c78: 0x0000000000000004	==&gt;  2
    0x00007ffc352b1c80: 0x0000000000000006	==&gt;  3
    0x00007ffc352b1c88: 0x7fffffffffffffff	==&gt;  false
RBP 0x00007ffc352b1c90: 0x00007ffc352b1cb0	==&gt;  old rbp
    0x00007ffc352b1c98: 0x00000000004010c1	==&gt;  saved ret
    0x00007ffc352b1ca0: 0x0000000000000002	==&gt;  1
    0x00007ffc352b1ca8: 0x0000000000000006	==&gt;  3
BOT 0x00007ffc352b1cb0: 0x00007ffc352b1cf0	==&gt;  old rbp
    0x00007ffc352b1cb8: 0x0000000000400f37	==&gt;  saved ret
6</code></pre></div></div></p><p><p>The output shows:
</p><ul><li><p>The current values of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> at the moment of the the
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">printStack</code></span> call.  The difference between them should be the size
of the current stack frame.</p></li><li><p>The requested return value is the argument given to
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">printStack</code></span>.</p></li><li><p><code>Num args</code> shows the number of arguments passed to the current
function &ndash; i.e., the two arguments given to <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">fact</code></span>.</p></li><li><p>The next bunch of segments show individual stack frames.  The three
columns show the memory address, the value at that address, and then the result
of <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span>ing that address as a Diamondback value, or identifying
it as the saved <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> and return address.  Each line labelled <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span>
indicates the beginning of a new stack frame: the value at each of those lines
contains the address of the <span class="emph">next</span> <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> line.</p><p>Looking at these stack frames, from bottom to top, you can see: the boolean
result of <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">n &lt; 1</code></span>, local values <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">acc * n</code></span> and
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">n - 1</code></span>, a slot for the return value of the <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">fact(...)</code></span>
call (which is still zero because the call hasn&rsquo;t finished yet), then the
arguments <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">n</code></span> and <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">acc</code></span> for the next call.</p></li><li><p>The final segment, marked <code>BOT</code>, is the stack frame of our <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">main</code></span>
expression.</p></li><li><p>The last line of output is the final output of the entire
program, and comes from the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">println</code></span> in <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">main</code></span>.</p></li></ul></p><p><span class="emph">Hint:</span> To identify where to stop printing the stack, I used a
trick: declare a global mutable variable in Rust, <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">static mut
BOTTOM: u64 = 0;</code></span> and extend <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">start_here</code></span> to take an argument
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">fn start_here(bottom: *mut 64) -&gt; SnakeVal</code></span> and pass a pointer
to BOTTOM: <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">let output = unsafe { start_here(&amp;mut BOTTOM) }; </code></span>.</p><p>Then at the beginning of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">start_here</code></span>, initialize that value with
the current value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span>, and then you&rsquo;re guaranteed to know
where your stack ends, dynamically.</p><p><span style="font-weight: bold">Note:</span> if you&rsquo;ve properly implemented tail calls, then eliminating the
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">+ 0</code></span> from the program above, and rerunning it, should produce a
<span class="emph">much</span> shorter stack trace...</p><p><span style="font-weight: bold">Note:</span> If you implement this extra credit, provide a brief, written
explanation (in a comment in <code>stub.rs</code>, near whatever new functions you
define) of why this must be implemented as a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Prim1</code></span> and not as a
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Call</code></span> expression.</p><h4>1.7<tt>&nbsp;</tt><a name="(part._.Testing)"></a>Testing</h4><p>Include integration test examples in <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">examples/test.rs</code></span>. These
include a new testing macro <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">mk_any_test!</code></span> that takes 2
arguments: the test name and the input file name and tests that
compiling and running the example works without error, but doesn&rsquo;t
check for a particular output. This should be useful in testing your
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">printStack</code></span> function.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Running_main)"></a>Running main</h3><p>Running your own programs is the same as with Cobra, except you&rsquo;ll
give them the <code>.diamond</code> file extension. Examples from previous
assignments will still work since they will simply be interpreted as
programs with 0 function declarations.</p><h3>3<tt>&nbsp;</tt><a name="(part._.List_of_.Deliverables)"></a>List of Deliverables</h3><ul><li><p>your <code>compile.rs</code> and <code>asm.rs</code></p></li><li><p>the other src/*.rs files in the starter code</p></li><li><p>any additional modules you saw fit to write</p></li><li><p>your <code>runtime/stub.rs</code></p></li><li><p>the Cargo.toml</p></li><li><p>integration tests (<code>tests/examples.rs</code>)</p></li><li><p>your test input programs (<code>examples/*.cobra</code> files)</p></li></ul><p><span style="font-weight: bold">Again, please ensure the makefile builds your code properly.
The black-box tests will give you an automatic 0 if they cannot compile your code!</span></p><p><span style="font-weight: bold">Please ensure the your code builds properly. The autograder
will give you a 0 on that portion of the graade if it cannot compile
your code.</span></p><h3>4<tt>&nbsp;</tt><a name="(part._.Grading_.Standards)"></a>Grading Standards</h3><p><p>For this assignment, you will be graded on
</p><ul><li><p>Whether your code implements the specification (functional correctness),</p></li><li><p>the clarity and cleanliness of your code, and</p></li><li><p>the comprehensiveness of your test coverage</p></li></ul></p><h3>5<tt>&nbsp;</tt><a name="(part._.Submission)"></a>Submission</h3><p><p><span style="font-weight: bold">Wait!</span> Please read the assignment again and verify that you have not forgotten anything!</p></p><p>Please submit your homework to gradescope by the above deadline.</p><a name="(part._(gentag._4._assignmentdiamondback))"></a><p class="FootnoteBlock"></p></div></div><div id="contextindicator">&nbsp;</div></body></html>