<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 14: Tuples and Memory Allocation</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 14:</span> Tuples and Memory Allocation</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Computing_with_mutable_data%29" class="tocviewlink" data-pltdoc="x">Computing with mutable data</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Mutating_pairs_in_our_language%29" class="tocviewlink" data-pltdoc="x">Mutating pairs in our language</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Generalizing_to_tuples%29" class="tocviewlink" data-pltdoc="x">Generalizing to tuples</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Sequencing%29" class="tocviewlink" data-pltdoc="x">Sequencing</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Recursive_types__nil__and__real__programs%29" class="tocviewlink" data-pltdoc="x">Recursive types, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>, and &ldquo;real&rdquo; programs</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 14:</span> Tuples and Memory Allocation</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Computing_with_mutable_data%29" class="tocsubseclink" data-pltdoc="x">Computing with mutable data</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Mutating_pairs_in_our_language%29" class="tocsubseclink" data-pltdoc="x">Mutating pairs in our language</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Syntax_and_examples%29" class="tocsubseclink" data-pltdoc="x">Syntax and examples</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Compilation%29" class="tocsubseclink" data-pltdoc="x">Compilation</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.Type_checking_mutation%29" class="tocsubseclink" data-pltdoc="x">Type checking mutation</a></td></tr><tr><td><span class="tocsublinknumber">2.3.1<tt>&nbsp;</tt></span><a href="#%28part._.Hazards%29" class="tocsubseclink" data-pltdoc="x">Hazards</a></td></tr><tr><td><span class="tocsublinknumber">2.3.2<tt>&nbsp;</tt></span><a href="#%28part._.Type-checking_.Approach%29" class="tocsubseclink" data-pltdoc="x">Type-<wbr></wbr>checking Approach</a></td></tr><tr><td><span class="tocsublinknumber">2.3.3<tt>&nbsp;</tt></span><a href="#%28part._.Type-inference_.Approach%29" class="tocsubseclink" data-pltdoc="x">Type-<wbr></wbr>inference Approach</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Generalizing_to_tuples%29" class="tocsubseclink" data-pltdoc="x">Generalizing to tuples</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Sequencing%29" class="tocsubseclink" data-pltdoc="x">Sequencing</a></td></tr><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.Approach_1__explicit_support%29" class="tocsubseclink" data-pltdoc="x">Approach 1:<span class="mywbr"> &nbsp;</span> explicit support</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._.Approach_2__desugaring%29" class="tocsubseclink" data-pltdoc="x">Approach 2:<span class="mywbr"> &nbsp;</span> desugaring</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Recursive_types__nil__and__real__programs%29" class="tocsubseclink" data-pltdoc="x">Recursive types, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>, and &ldquo;real&rdquo; programs</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="LectureNum">Lecture 14:</span> Tuples and Memory Allocation</h2><h3>1<tt>&nbsp;</tt><a name="(part._.Computing_with_mutable_data)"></a>Computing with mutable data</h3><p><p>Standard reminder: Every time we enhance our source language, we need to
consider several things:
</p><ol><li><p>Its impact on the <span style="font-style: italic">concrete syntax</span> of the language</p></li><li><p>Examples using the new enhancements, so we build intuition of them</p></li><li><p>Its impact on the <span style="font-style: italic">abstract syntax</span> and <span style="font-style: italic">semantics</span> of the language</p></li><li><p>Any new or changed <span style="font-style: italic">transformations</span> needed to process the new
forms</p></li><li><p>Executable <span style="font-style: italic">tests</span> to confirm the enhancement works as intended</p></li></ol></p><h3>2<tt>&nbsp;</tt><a name="(part._.Mutating_pairs_in_our_language)"></a>Mutating pairs in our language</h3><h4>2.1<tt>&nbsp;</tt><a name="(part._.Syntax_and_examples)"></a>Syntax and examples</h4><p>We&rsquo;ll write pairs as</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(mut-pair-intro._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28mut-pair-intro._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28mut-pair-intro._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">fst</span> <span class=""><a href="#%28elem._%28bnf-prod._%28mut-pair-intro._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span><span class="bnf-meta"> | </span><span class="bnf-lit">snd</span> <span class=""><a href="#%28elem._%28bnf-prod._%28mut-pair-intro._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">set-fst</span> <span class=""><a href="#%28elem._%28bnf-prod._%28mut-pair-intro._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class=""><a href="#%28elem._%28bnf-prod._%28mut-pair-intro._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span><span class="bnf-meta"> | </span><span class="bnf-lit">set-snd</span> <span class=""><a href="#%28elem._%28bnf-prod._%28mut-pair-intro._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class=""><a href="#%28elem._%28bnf-prod._%28mut-pair-intro._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span></p></blockquote><p><a href="lec_tuples_notes.html" data-pltdoc="x">As before</a>, the first expression creates a pair, and the
next two access the first or second elements of that pair.  The two new
expression forms allow us to modify the first or second item of the pair given
by the first subexpression, and set it to the value of the second
subexpression.  We need to decide on what these expressions will return; let&rsquo;s
choose to make them return the tuple itself.</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = (4, 5) in set-fst x 10             # ==&gt; (10, 5)
let y = (3, 2) in set-fst (set-snd y 8) 6  # ==&gt; (6, 8)</code></pre></div></div></p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Flesh out the semantics of these two new expressions.  What new
error conditions might there be?</p></blockquote><p>We can add these expression forms to our AST easily enough.  This time, the new
expressions will be binary primitives:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type expr = ...
  | EPair of expr * expr
type prim1 = ... | Fst | Snd
type prim2 = ... | Setfst | Setsnd</code></pre></div></div></p><h4>2.2<tt>&nbsp;</tt><a name="(part._.Compilation)"></a>Compilation</h4><p>Given our representation of pairs (from <a href="lec_tuples_notes.html#%28part._pairs._pairs%29" data-pltdoc="x">Adding pairs to our language</a>), it&rsquo;s
relatively straightforward to compile these two new primitives.  We&rsquo;ll focus on
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">set-fst</code></span>; the other is nearly identical.  We first compile both
subexpressions, and load them into two registers <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RDX</code></span>.  We
ensure that the first argument is a pair by checking its tag, and if so then we
untag the value by subtracting the tag.  Now the content of the pair begins at
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">[RAX]</code></span>, and the first item of the pair is located at offset zero from
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>: we simply move the second value into that location.  However, our
intended semantics is to return the pair value, which means we need to restore
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> to point to the pair: we must tag the value again.</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RAX, &lt;the pair&gt;
mov RDX, &lt;the new first value&gt;
mov RCX, RAX           ;; \
and RCX, 0x7           ;; | check to ensure
cmp RCX, 0x1           ;; | RAX is a pair
jne not_a_pair         ;; /
sub RAX, 0x1           ;; untag the value into a raw pointer
mov [RAX + 8 * 0], RDX ;; perform the mutation
add RAX, 0x1           ;; tag the pointer back into a value</code></pre></div></div></p><p>To compile <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">set-snd</code></span>, we do the same thing except use an offset
address of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">[RAX + 8 * 1]</code></span>.</p><h4>2.3<tt>&nbsp;</tt><a name="(part._.Type_checking_mutation)"></a>Type checking mutation</h4><h5>2.3.1<tt>&nbsp;</tt><a name="(part._.Hazards)"></a>Hazards</h5><p>To ensure that our programs continue to make sense even in the presence of
mutation, we need to make sure that our updates do not modify the <span style="font-style: italic">types</span>
of any components of pairs.  Permitting this would lead to glaring type safety
failures, as in the following simple example:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = (1, 2), # x : (Int * Int)
    y = x,      # y : (Int * Int)
    also_x = set-fst x true in
(fst y) + (snd y) # fine -- after all, y : Int * Int, right??</code></pre></div></div></p><p>Even if we kept track of the fact that we&rsquo;ve modified the type of
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span>, it&rsquo;s pretty challenging to perfectly keep track of the fact that
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">y</code></span> is aliased to <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> and therefore that its type should
have changed as well.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._29._lecturemutable-tuples%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">This is known as a <span style="font-style: italic">may-alias</span> problem, and
aliasing analyses of various precision are at the core of most optimizing
compilers.</span></span>  (Some languages, such as Rust, track this aliasing information as
part of their type system; programming in such languages is necessarily
trickier&#8212;<wbr></wbr>because the compiler demands more from the programmer&#8212;<wbr></wbr>but provides
benefits as well.)  If we <span style="font-style: italic">could</span> somehow keep track of the fact that
no-one currently aliases our value, we might be able to perform a <span style="font-style: italic">strong
update</span> that changes the type of our pair, but for now, the effort simply isn&rsquo;t
worth it.</p><p>Another complication arises in languages with relationships between types.
Consider declaring a variable at some interface type in Java, and then mutating
that variable to hold an object of some class that implements the interface,
and then mutating it again to hold an object of some other class.  Java&rsquo;s type
system ensures that we can only access the methods declared on the interface,
and so the mutations do not break type soundness.  These <span style="font-style: italic">subtyping
relationships</span> between types can be added to our type system, but we do not
currently have any types that could be related in this way.</p><p>We <span style="font-style: italic">do</span> however have polymorphic types; as soon as we have higher-order
functions, this becomes a point worth revisiting...  Unsurprisingly,
polymorphism and mutation do not play nicely together either; this has led to
common compromises such as the
<a href="http://mlton.org/ValueRestriction">value restriction</a> to prevent
references from unsafely being made polymorphic.  (Note that in ML, tuples are
considered values, but <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ref</code></span> cells are not: in our language, now that pairs
are mutable, we cannot consider them to be values either.)</p><h5>2.3.2<tt>&nbsp;</tt><a name="(part._.Type-checking_.Approach)"></a>Type-checking Approach</h5><p>Our type checker has enough information to type-check this <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">set-fst</code></span>
expression.  Since the result of <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">set-fst e1 e2</code></span> is the result of
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e1</code></span>, we simply type-check that expression with our current desired
type.  If it passes, we double-check that it is indeed a pair type, and then
check <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e2</code></span> with the first component of that type.  Type-checking
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">set-snd</code></span> is analogous:</p><p><p type="math/tex" style="white-space: pre;" class="math-tex">\begin{equation*}\dfrac{\Gamma \vdash e_1 : \mathsf{\tau} \quad \tau = \alpha * \beta \quad \Gamma \vdash e_2 : \mathsf{\alpha}}{\Gamma \vdash (\operatorname{set-fst} e_1 e_2) : \mathsf{\tau}}
\qquad\qquad
\dfrac{\Gamma \vdash e_1 : \mathsf{\tau} \quad \tau = \alpha * \beta \quad \Gamma \vdash e_2 : \mathsf{\beta}}{\Gamma \vdash (\operatorname{set-snd} e_1 e_2) : \mathsf{\tau}}\end{equation*}</p></p><h5>2.3.3<tt>&nbsp;</tt><a name="(part._.Type-inference_.Approach)"></a>Type-inference Approach</h5><p>The last two typing rules above work directly for our inference algorithm.  To
infer a type for <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">set-fst e1 e2</code></span>, we infer some type <span type="math/tex" style="white-space: pre;" class="math-tex">\(\tau\)</span> for the
pair <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e1</code></span> and unify it with the pair type <span type="math/tex" style="white-space: pre;" class="math-tex">\(\alpha * \beta\)</span> (for
two fresh type variables), infer a type <span type="math/tex" style="white-space: pre;" class="math-tex">\(\gamma\)</span> for <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e2</code></span>, and unify
<span type="math/tex" style="white-space: pre;" class="math-tex">\(\alpha\)</span> with <span type="math/tex" style="white-space: pre;" class="math-tex">\(\gamma\)</span>.  Then the result of type-inference is the
pair-type <span type="math/tex" style="white-space: pre;" class="math-tex">\(\tau = \alpha * \beta\)</span>.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Generalizing_to_tuples)"></a>Generalizing to tuples</h3><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What goes wrong for type-checking and/or type-inference of mutable general tuples?</p></blockquote><p>The core ideas above carry through unchanged, in that tuples will have product
types with more components in them than mere pairs, and the same problems arise
as with immutable tuples: we don&rsquo;t know the tuple sizes in advance.  Therefore
our tuple-setting expressions also must include the size of the tuple, just as
tuple-accesses did.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Sequencing)"></a>Sequencing</h3><p>Now that we have mutation, we need to reconsider the ergonomics of our
language.  It&rsquo;s rare that assigning to a field of a tuple should be the only
thing we want to compute: we likely want to mutate a field and keep going with
our computation.  These mutations therefore fit better into our language as
<span style="font-style: italic">statements</span> to be executed for their side-effects, rather than as
expressions to be evaluated for their answer.  To achieve this, we might want
to express the <span style="font-style: italic">sequencing</span> of multiple expressions, such that our program
evaluates them all in order, but only returns the final result.  We can add
such concrete syntax easily:</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(seq-intro._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span><span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28seq-intro._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28seq-intro._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span></p></blockquote><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>How might we implement support for this feature?  Which phases of
the compiler necessarily change, and which could we avoid changing?</p></blockquote><p>We&rsquo;ll start by adding an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ESeq</code></span> constructor to our expressions.  We have two
options for how to proceed from here.</p><h4>4.1<tt>&nbsp;</tt><a name="(part._.Approach_1__explicit_support)"></a>Approach 1: explicit support</h4><p>Since we said that our language should evaluate both
subexpressions and then evaluate to the result of the second one,</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e1 ; e2</code></pre></div></div></p><p>intuitively should mean the same thing as</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let DONT_CARE = e1 in e2</code></pre></div></div></p><p>Let&rsquo;s try to push this expression through ANFing.  We might start by copying
the code from <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ELet</code></span>, and then just &ldquo;leaving out&rdquo; the binding for the
intermediate variable:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let anf (p : tag program) : unit aprogram =
  let rec helpC (e : tag expr) : (unit cexpr * (string * unit cexpr) list) =
    match e with
    | ESeq(e1, e2, tag) -&gt;
      let (e1_ans, e1_setup) = helpC e1 in
      let (e2_ans, e2_setup) = helpC e2 in
      (e2_ans, e1_setup @ [(* skip binding of DONT_CARE to e1_ans *)] @ e2_setup)
    ...</code></pre></div></div></p><p>But unfortunately this translation is <span style="font-style: italic">wrong</span>: consider the program
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print(1); print(2)</code></span>.  Since the arguments to both calls are
immediate, there is no setup needed, so <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">e1_setup = e2_setup = []</code></span>.  Then we
return just the answer of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">e2</code></span>, and have lost the context for evaluating
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">e1</code></span>!  The solution is to require that <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">e1</code></span> be translated via <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpI</code></span>,
rather than <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpC</code></span>: by requiring that our answer be immediate, we guarantee
that the expression has been fully evaluated and the answer is placed into
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>; we can then neglect to save that value anywhere.</p><h4>4.2<tt>&nbsp;</tt><a name="(part._.Approach_2__desugaring)"></a>Approach 2: desugaring</h4><p>Rather than create an explicit expression form, perhaps we could reuse the
existing <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ELet</code></span> form and use our intuitive definition as the actual
definition.  We can enhance our desugaring function from
<a href="lec_tuples_notes.html" data-pltdoc="x">last time</a> to look for uses of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ESeq</code></span> and
rewrite them into uses of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ELet</code></span>.  This approach says that sequencing is merely
<span style="font-style: italic">syntactic sugar</span>, a convenience that makes programs nicer to write, but
that doesn&rsquo;t add any new expressive power.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let desugar (p : tag program) : tag program =
  let rec helpE (e : tag expr) =
    match e with
    | ESeq(e1, e2, tag) -&gt;
      let newname = gensym "DONT_CARE" in
      ELet([(newname, helpE e1, tag)], helpE e2, tag)
    | ...</code></pre></div></div></p><p>This pass must recur throughout the program, as all of our passes do, and
rewrite any sequence expressions it encounters.  The advantage of this approach
is that our subsequent passes can completely ignore the new sequencing
expression form (they can throw an <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">InternalCompilerException</code></span> instead), and
therefore no other part of our language is affected.</p><p>We can clean this up still further, by adding a new kind of binding form,
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">BBlank</code></span>, that acts like the underscore binding in ML: it indicates that we
want to evaluate the right-hand expression, but not bother to bind it to any
name.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a bind =
  | BName of string * 'a typ * 'a
  | BTuple of 'a bind list * 'a
  | BBlank of 'a typ * 'a
type 'a binding = ('a bind * 'a expr * 'a)</code></pre></div></div></p><p>Our desugaring now will generate a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">BBlank</code></span> binding:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let desugar (p : tag program) : tag program =
  let rec helpE (e : tag expr) =
    match e with
    | ESeq(e1, e2, tag) -&gt;
      ELet([(BBlank(TyBlank tag, tag), helpE e1, tag)], helpE e2, tag)
    | ...</code></pre></div></div></p><p>Lastly, we need to add support to ANF to handle these new kinds of bindings,
taking note of the difficulty we encountered above and being careful to use
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">helpI</code></span> as needed.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let anf (p : tag program) : unit aprogram =
  let rec helpC (e : tag expr) : (unit cexpr * (string * unit cexpr) list) =
    match e with
    | ELet((BName(name, _, _), exp, _)::rest, body, pos) -&gt;
      let (exp_ans, exp_setup) = helpC exp in
      let (body_ans, body_setup) = helpC(ELet(rest, body, pos)) in
      (body_ans, exp_setup @ [(name, exp_ans)] @ body_setup)
    | ELet((BBlank _, exp, _)::rest, body, pos) -&gt;
      let (exp_ans, exp_setup) = helpI exp in (* NOTE: use of helpI *)
      let (body_ans, body_setup) = helpC(ELet(rest, body, pos)) in
      (body_ans, exp_setup @ body_setup) (* NOTE: no binding for exp_ans *)
    | ...
  and helpI (e : tag expr) : (unit immexpr * (stirng * unit cexpr) list) =
    match e with
    | ELet((BName(bind, _, _), exp, _)::rest, body, pos) -&gt;
       let (exp_ans, exp_setup) = helpC exp in
       let (body_ans, body_setup) = helpI (ELet(rest, body, pos)) in
       (body_ans, exp_setup @ [(bind, exp_ans)] @ body_setup)
    | ELet((BBlank(_, _), exp, _)::rest, body, pos) -&gt;
       let (exp_ans, exp_setup) = helpI exp in (* NOTE: use of helpI *)
       let (body_ans, body_setup) = helpI (ELet(rest, body, pos)) in
       (body_ans, exp_setup @ body_setup) (* NOTE: no binding for exp_ans *)
    | ...
  ...</code></pre></div></div></p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Go back through the standard recipe for adding a feature to our
language, and add support for underscore-bindings as needed.  Where else might
underscores appear, if we treat them as bindings?</p></blockquote><p>This effectively combines the two approaches above: we desugar
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ESeq</code></span> to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ELet</code></span> using a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">BBlank</code></span> binding, then our general-purpose
ANF transformation handles the ignorable underscore-binding and produces
exactly the results we want, in a general manner that allows us to use
underscores in a flexible manner throughout our code.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Unfortunately, using either of these two approaches, the rest of our
compiler is unchanged, and is correct, yet programs that use sequencing might
still not compile.  Why?  What might be done about this?  Is it a failure in
the design of sequencing, or a consequence of multiple language features
interacting?</p></blockquote><h3>5<tt>&nbsp;</tt><a name="(part._.Recursive_types__nil__and__real__programs)"></a>Recursive types, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>, and &ldquo;real&rdquo; programs</h3><p>Now that we have mutable tuples, and tuples can contain other tuples, we have
the ability to work with arbitrarily large data.  However, our static type
system is too weak to allow us to do this!  Suppose we wanted to encode a
simple linked list of integers.  We need some value to indicate the end of the
list, but what should its type be?</p><p>In the untyped (or dynamically-typed) case, we could encode a linked list as
pairs whose first items are the elements of the list, whose second items are
the rest of the list, and where the end of the list is <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span>.  For
instance:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def length(l):
  if istuple(l): 1 + length(l[1 of 2])
  else 0</code></pre></div></div></p><p>But there currently is no way for us to type-check this function.  We would
have to specify the type of <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">l</code></span> as a nested tuple type, and then that
type would implicitly have a finite size.  We need a <span style="font-style: italic">recursive</span> type to
indicate arbitrarily long lists.  But such types need a base case, and
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span> already is a boolean, so we need some new value to indicate
our base.</p><p>We will resolve this for our languages by introducing two features at once:
<span style="font-style: italic">recursive type synonyms</span>, and a unique new value <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>.  By way
of examples:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">type intlist = (int * intlist)

def length(l : intlist):
  if l == (nil : intlist): 0
  else: 1 + length(l[1 of 2])</code></pre></div></div></p><p>We&rsquo;ll define type synonyms as giving a name to a particular tuple type, where
the name itself is in scope and permitted to be used within that tuple.  We&rsquo;ll
collect these type synonyms in an environment, for use during type checking or
type inference.</p><p>Additionally, we will add a typing rule that says <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> is permitted
to have any tuple type at all.  (However, to keep type checking and type
inference easier, we will mandate that all uses of <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> are
syntactically annotated with their intended type.)</p><p>To represent <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>, we will simply choose a <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">NULL</code></span> pointer from C,
but tag it as a tuple.  This will allow us to easily evaluate
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">istuple(nil) == true</code></span>, while also ensuring that <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> is
guaranteed to be distinct from any valid tuple value in our language.</p><p>To use type synonyms in our language, we will simply add a case to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">unify</code></span>:
if we encounted a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">TyCon</code></span> during unification, we look it up in our
environment of type synonyms, and continue unification with the expanded
version of the type.  This rule is suspiciously simple, and in a more
complicated system than ours, it would not suffice (and might cause the type
inference algorithm to loop forever), but for our purposes it works just fine.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Now that we&rsquo;ve added <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>, what new problems do we have
to handle in our compilation of tuples everywhere?  Do it.</p></blockquote><p>We know that <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> is a
<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">very
expensive mistake</a>, and that better solutions exist.  A full treatment of
algebraic data types, such as OCaml&rsquo;s type definitions, would allow us to
support recursive type definitions without resorting to introducing
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> values.  But that approach is beyond the scope of this course.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Now that we have recursive, mutable data, write a few examples of
programs that do something interesting, like sorting a list in place, or
building a binary tree, etc.  Rejoice in your newfound mastery over simple
programs!  What features should we add to our language next?</p></blockquote><a name="(part._(gentag._28._lecturemutable-tuples))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._29._lecturemutable-tuples))"></a>1</span></span>This is known as a <span style="font-style: italic">may-alias</span> problem, and
aliasing analyses of various precision are at the core of most optimizing
compilers.</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>