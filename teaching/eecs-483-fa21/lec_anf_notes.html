<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 4: Conditionals and A-Normal Form</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 4:</span> Conditionals and A-<wbr></wbr>Normal Form</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._if._.Growing_the_language__adding_conditionals%29" class="tocviewlink" data-pltdoc="x">Growing the language:<span class="mywbr"> &nbsp;</span> adding conditionals</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._infix._.Growing_the_language__adding_infix_operators%29" class="tocviewlink" data-pltdoc="x">Growing the language:<span class="mywbr"> &nbsp;</span> adding infix operators</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.A-.Normal_.Form%29" class="tocviewlink" data-pltdoc="x">A-<wbr></wbr>Normal Form</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Complications_introduced_by_.A.N.F__.Inadvertent_shadowing__and_name_resolution%29" class="tocviewlink" data-pltdoc="x">Complications introduced by ANF:<span class="mywbr"> &nbsp;</span> Inadvertent shadowing, and name resolution</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 4:</span> Conditionals and A-<wbr></wbr>Normal Form</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._if._.Growing_the_language__adding_conditionals%29" class="tocsubseclink" data-pltdoc="x">Growing the language:<span class="mywbr"> &nbsp;</span> adding conditionals</a></td></tr><tr><td><span class="tocsublinknumber">1.1<tt>&nbsp;</tt></span><a href="#%28part._if._.The_new_concrete_syntax%29" class="tocsubseclink" data-pltdoc="x">The new concrete syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.2<tt>&nbsp;</tt></span><a href="#%28part._if._.Examples_and_semantics%29" class="tocsubseclink" data-pltdoc="x">Examples and semantics</a></td></tr><tr><td><span class="tocsublinknumber">1.3<tt>&nbsp;</tt></span><a href="#%28part._if._.The_new_abstract_syntax%29" class="tocsubseclink" data-pltdoc="x">The new abstract syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.4<tt>&nbsp;</tt></span><a href="#%28part._if._.Enhancing_the_transformations__.Jumping_around%29" class="tocsubseclink" data-pltdoc="x">Enhancing the transformations:<span class="mywbr"> &nbsp;</span> Jumping around</a></td></tr><tr><td><span class="tocsublinknumber">1.4.1<tt>&nbsp;</tt></span><a href="#%28part._if._.Comparisons_and_jumps%29" class="tocsubseclink" data-pltdoc="x">Comparisons and jumps</a></td></tr><tr><td><span class="tocsublinknumber">1.4.2<tt>&nbsp;</tt></span><a href="#%28part._if._.Approach_1__.Gensym%29" class="tocsubseclink" data-pltdoc="x">Approach 1:<span class="mywbr"> &nbsp;</span> Gensym</a></td></tr><tr><td><span class="tocsublinknumber">1.4.3<tt>&nbsp;</tt></span><a href="#%28part._if._.Approach_2__.Tagging%29" class="tocsubseclink" data-pltdoc="x">Approach 2:<span class="mywbr"> &nbsp;</span> Tagging</a></td></tr><tr><td><span class="tocsublinknumber">1.4.4<tt>&nbsp;</tt></span><a href="#%28part._if._.Putting_it_together__compiling_if-expressions%29" class="tocsubseclink" data-pltdoc="x">Putting it together:<span class="mywbr"> &nbsp;</span> compiling if-<wbr></wbr>expressions</a></td></tr><tr><td><span class="tocsublinknumber">1.5<tt>&nbsp;</tt></span><a href="#%28part._if._.Testing%29" class="tocsubseclink" data-pltdoc="x">Testing</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._infix._.Growing_the_language__adding_infix_operators%29" class="tocsubseclink" data-pltdoc="x">Growing the language:<span class="mywbr"> &nbsp;</span> adding infix operators</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._infix._.The_new_concrete_syntax%29" class="tocsubseclink" data-pltdoc="x">The new concrete syntax</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._infix._.Examples_and_semantics%29" class="tocsubseclink" data-pltdoc="x">Examples and semantics</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._infix._.Enhancing_the_abstract_syntax%29" class="tocsubseclink" data-pltdoc="x">Enhancing the abstract syntax</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#%28part._infix._.Enhancing_the_transformations__.Normalization%29" class="tocsubseclink" data-pltdoc="x">Enhancing the transformations:<span class="mywbr"> &nbsp;</span> Normalization</a></td></tr><tr><td><span class="tocsublinknumber">2.4.1<tt>&nbsp;</tt></span><a href="#%28part._infix._.Immediate_expressions%29" class="tocsubseclink" data-pltdoc="x">Immediate expressions</a></td></tr><tr><td><span class="tocsublinknumber">2.5<tt>&nbsp;</tt></span><a href="#%28part._infix._.Testing%29" class="tocsubseclink" data-pltdoc="x">Testing</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.A-.Normal_.Form%29" class="tocsubseclink" data-pltdoc="x">A-<wbr></wbr>Normal Form</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Converting_a_program_to_.A-.Normal_.Form%29" class="tocsubseclink" data-pltdoc="x">Converting a program to A-<wbr></wbr>Normal Form</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Handling_conditionals%29" class="tocsubseclink" data-pltdoc="x">Handling conditionals</a></td></tr><tr><td><span class="tocsublinknumber">3.2.1<tt>&nbsp;</tt></span><a href="#%28part._.Attempt_1__exponential_failure%29" class="tocsubseclink" data-pltdoc="x">Attempt 1:<span class="mywbr"> &nbsp;</span> exponential failure</a></td></tr><tr><td><span class="tocsublinknumber">3.2.2<tt>&nbsp;</tt></span><a href="#%28part._.Attempt_2__.Pragmatic_success%29" class="tocsubseclink" data-pltdoc="x">Attempt 2:<span class="mywbr"> &nbsp;</span> Pragmatic success</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._.Improving_the_translation%29" class="tocsubseclink" data-pltdoc="x">Improving the translation</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#%28part._.An_alternate_approach__.Just_use_the_stack_%29" class="tocsubseclink" data-pltdoc="x">An alternate approach:<span class="mywbr"> &nbsp;</span> Just use the stack!</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Complications_introduced_by_.A.N.F__.Inadvertent_shadowing__and_name_resolution%29" class="tocsubseclink" data-pltdoc="x">Complications introduced by ANF:<span class="mywbr"> &nbsp;</span> Inadvertent shadowing, and name resolution</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="LectureNum">Lecture 4:</span> Conditionals and A-Normal Form</h2><p>Our previous compiler could increment and decrement numbers, as well as handle
let-bound identifiers.  This is completely straight-line code; there are no
decisions to make that would affect code execution.  We need to support
<span style="font-style: italic">conditionals</span> to incorporate such choices.  Also, we&rsquo;d like to be able to
support <span style="font-style: italic">compound expressions</span> like binary, infix operators (or
eventually, function calls), and to do that we&rsquo;ll need some more careful
management of data.</p><p>Let&rsquo;s start with conditionals, and move on to compound expressions second.</p><h3>1<tt>&nbsp;</tt><a name="(part._if._.Growing_the_language__adding_conditionals)"></a>Growing the language: adding conditionals</h3><p><p>Reminder: Every time we enhance our source language, we need to consider several things:
</p><ol><li><p>Its impact on the <span style="font-style: italic">concrete syntax</span> of the language</p></li><li><p>Examples using the new enhancements, so we build intuition of them</p></li><li><p>Its impact on the <span style="font-style: italic">abstract syntax</span> and <span style="font-style: italic">semantics</span> of the language</p></li><li><p>Any new or changed <span style="font-style: italic">transformations</span> needed to process the new
forms</p></li><li><p>Executable <span style="font-style: italic">tests</span> to confirm the enhancement works as intended</p></li></ol></p><h4>1.1<tt>&nbsp;</tt><a name="(part._if._.The_new_concrete_syntax)"></a>The new concrete syntax</h4><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._if._(bnf-prod._(if._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">if</span> <span class=""><a href="#%28elem._if._%28bnf-prod._%28if._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._if._%28bnf-prod._%28if._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">else:</span> <span class=""><a href="#%28elem._if._%28bnf-prod._%28if._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span></p></blockquote><h4>1.2<tt>&nbsp;</tt><a name="(part._if._.Examples_and_semantics)"></a>Examples and semantics</h4><p>Currently our language includes only integers as its values.  We&rsquo;ll therefore
define conditionals to match C&rsquo;s behavior: if the condition evaluates to a
nonzero value, the then-branch will execute, and if the condition evaluates to
zero, the else-branch will execute.  It is never the case that both branches
should execute.</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Concrete Syntax</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Answer</p></td></tr><tr><td><p><span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if 5: 6 else: 7</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>6</code></p></td></tr><tr><td><p><span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if 0: 6 else: 7</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>7</code></p></td></tr><tr><td><p><span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if sub1(1): 6 else: 7</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>7</code></p></td></tr></table></p><p>Unlike C, though, if-expressions are indeed <span style="font-style: italic">expressions</span>: they evaluate
to a value, which means they can be composed freely with the other expression
forms in our language.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Construct larger examples, combining if-expressions with each other
or with let-bindings, and show their evaluation.</p></blockquote><h4>1.3<tt>&nbsp;</tt><a name="(part._if._.The_new_abstract_syntax)"></a>The new abstract syntax</h4><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type expr = ...
  | EIf of expr * expr * expr (* condition, then branch, else branch *)</code></pre></div></div></p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Extend your interpreter from the prior lecture to include
conditionals.  As with last lecture, suppose we added a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">print</code></span> expression
to the language &#8212;<wbr></wbr> what care must be taken to get the correct semantics?</p></blockquote><p>There&rsquo;s something a bit unsatisfying about interpreting <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> in our
language by using <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">if</code></span> in OCaml: it feels like a coincidence that our
semantics and OCaml&rsquo;s semantics agree, and it doesn&rsquo;t convey much understanding
of how conditionals like <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> actually work...</p><h4>1.4<tt>&nbsp;</tt><a name="(part._if._.Enhancing_the_transformations__.Jumping_around)"></a>Enhancing the transformations: Jumping around</h4><h5>1.4.1<tt>&nbsp;</tt><a name="(part._if._.Comparisons_and_jumps)"></a>Comparisons and jumps</h5><p>To compile conditionals, we need to add new assembly instructions that allow us
to change the default control flow of our program: rather than proceeding
sequentially from one instruction to the next, we need <span style="font-style: italic">jumps</span> to
immediately go to an instruction of our choosing.  The simplest such form is
just <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jmp SOME_LABEL</code></span>, which unconditionally jumps to the named label in
our program.  We&rsquo;ve seen only one label so far, namely
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">our_code_starts_here</code></span>, but we can freely add more labels to our program to
indicate targets of jumps.  More interesting are <span style="font-style: italic">conditional jumps</span>,
which only jump based on some test; otherwise, they simply fall through to the
next instruction.</p><p><p>To trigger a conditional jump, we need to have some sort of comparison.
The instruction <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp arg1 arg2</code></span> compares its two arguments, and sets
various flags whose values are used by the conditional jump instructions:
</p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Instruction</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Jump if ...</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">je </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the two compared values are equal</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jne</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the two compared values are not equal</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jl </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is less than the second</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jle</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is less than or equal to the second</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jg </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is greater than the second</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jge</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is greater than or equal to the second</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jb </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is less than the second, when treated as unsigned</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jbe</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is less than or equal to the second, when treated as unsigned</p></td></tr></table></p><p>Some conditional jumps are triggered by arithmetic operations, instead:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Instruction</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Jump if ...</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jz </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the last arithmetic result is zero</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jnz</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the last arithmetic result is non-zero</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jo </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the last arithmetic result overflowed</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jno</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the last arithmetic result did not overflow</p></td></tr></table></p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Consider the examples of if-expressions above.  Translate them
manually to assembly.</p></blockquote><p><p>Let&rsquo;s examine the last example above:
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">~hl:2:s~if ~hl:1:s~sub1(1)~hl:1:e~: ~hl:3:s~6~hl:3:e~ else: ~hl:4:s~7~hl:4:e~~hl:2:e~</code></span>.
Which of the following could be valid translations of this expression?
</p><table cellspacing="0" cellpadding="0" class="centered"><tr><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:1:s~mov RAX, 1
  sub1 RAX~hl:1:e~
  ~hl:2:s~cmp RAX, 0
  je if_false
if_true:
  ~hl:3:s~mov RAX, 6~hl:3:e~
  jmp done
if_false:
  ~hl:4:s~mov RAX, 7~hl:4:e~
done:~hl:2:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:1:s~mov RAX, 1
  sub1 RAX~hl:1:e~
  ~hl:2:s~cmp RAX, 0
  je if_false
if_true:
  ~hl:3:s~mov RAX, 6~hl:3:e~

if_false:
  ~hl:4:s~mov RAX, 7~hl:4:e~
done:~hl:2:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:1:s~mov RAX, 1
  sub1 RAX~hl:1:e~
  ~hl:2:s~cmp RAX, 0
  jne if_true
if_true:
  ~hl:3:s~mov RAX, 6~hl:3:e~
  jmp done
if_false:
  ~hl:4:s~mov RAX, 7~hl:4:e~
done:~hl:2:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:1:s~mov RAX, 1
  sub1 RAX~hl:1:e~
  ~hl:2:s~cmp RAX, 0
  jne if_true
if_false:
  ~hl:4:s~mov RAX, 7~hl:4:e~
  jmp done
if_true:
  ~hl:3:s~mov RAX, 6~hl:3:e~
done:~hl:2:e~</code></pre></div></div></p></td></tr></table></p><p>The first two follow the structure of the original expression most closely, but
the second has a fatal flaw: once the then-branch finishes executing, control
falls through into the else-branch when it shouldn&rsquo;t.  The third version
flips the condition and the target of the jump, but tracing carefully through
it reveals there is no way for control to reach the else-branch.  Likewise,
tracing carefully through the first and last versions reveal they could both be
valid translations of the original expression.</p><p>Working through these examples should give a reasonable intuition for how to
compile if-expressions more generally: we compile the condition, check whether
it is zero and if so jump to the <span style="font-style: italic">else</span> branch and fall through to the
<span style="font-style: italic">then</span> branch.  Both branches are then compiled as normal.  The
then-branch, however, needs an unconditional jump to the instruction just after
the end of the else-branch, so that execution dodges the unwanted branch.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Work through the initial examples, and the examples you created
earlier.  Does this strategy work for all of them?</p></blockquote><p>Let&rsquo;s try this strategy on a few examples.  For clarity, we repeat the previous
example below, so that the formatting is more apparent.</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Original expression</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Compiled assembly</p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">~hl:2:s~if ~hl:1:s~sub1(1)~hl:1:e~:
  ~hl:3:s~6~hl:3:e~
else:
  ~hl:4:s~7~hl:4:e~~hl:2:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:1:s~mov RAX, 1
  sub1 RAX~hl:1:e~
  ~hl:2:s~cmp RAX, 0
  je if_false
if_true:
  ~hl:3:s~mov RAX, 6~hl:3:e~
  jmp done
if_false:
  ~hl:4:s~mov RAX, 7~hl:4:e~
done:~hl:2:e~</code></pre></div></div></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">~hl:1:s~if ~hl:2:s~10~hl:2:e~:
  ~hl:3:s~2~hl:3:e~
else:
  ~hl:4:s~sub1(0)~hl:4:e~~hl:1:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:2:s~mov RAX, 10~hl:2:e~
  ~hl:1:s~cmp RAX, 0
  je if_false
if_true:
  ~hl:3:s~mov RAX, 2~hl:3:e~
  jmp done
if_false:
  ~hl:4:s~mov RAX, 0
  sub1 RAX~hl:4:e~
done:~hl:1:e~</code></pre></div></div></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">~hl:1:s~let x =~hl:1:e~ if 10:
          2
        else:
          0
in
~hl:3:s~if ~hl:2:s~x~hl:2:e~:
  ~hl:4:s~55~hl:4:e~
else:
  ~hl:5:s~999~hl:5:e~~hl:3:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  mov RAX, 10
  cmp RAX, 0
  je if_false
if_true:
  mov RAX, 2
  jmp done
if_false:
  mov RAX, 0
done:
  ~hl:1:s~mov [RSP-8], RAX~hl:1:e~
  ~hl:2:s~mov RAX, [RSP-8]~hl:2:e~
  ~hl:3:s~cmp RAX, 0
  je if_false
if_true:
  ~hl:4:s~mov RAX, 55~hl:4:e~
  jmp done
if_false:
  ~hl:5:s~mov RAX, 999~hl:5:e~
done:~hl:3:e~</code></pre></div></div></p></td></tr></table></p><p>The last example is broken: the various labels used in the two if-expressions
are duplicated, which leads to illegal assembly:
<div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ nasm -f elf64 -o output/test1.o output/test1.s
output/test1.s:20: error: symbol `if_true' redefined
output/test1.s:23: error: symbol `if_false' redefined
output/test1.s:25: error: symbol `done' redefined</code></pre></div></div></p><p>We need to generate <span style="font-style: italic">unique</span> labels for each expression.</p><h5>1.4.2<tt>&nbsp;</tt><a name="(part._if._.Approach_1__.Gensym)"></a>Approach 1: Gensym</h5><p>One common approach is to write a simple function that <span style="font-style: italic">gen</span>erates unique
<span style="font-style: italic">sym</span>bols every time it&rsquo;s called, by keeping track of a mutable counter:
<div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let gensym =
  let counter = ref 0 in
  (fun basename -&gt;
    counter := !counter + 1;
    sprintf "%s_%d" basename !counter);;</code></pre></div></div>
We make sure that counters can never be inadvertently reused by defining
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">counter</code></span> in a let-expression scoped within the binding of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">gensym</code></span>.</p><p>This approach works, is simple to implement and simple to understand.  However, it
does have a readability drawback: the generated names bear no connection to the
expressions that produced them, making it hard to trace backwards from the
generated output to the relevant source expressions.  Additionally, it assumes
that only one stream of names is ever needed in the compiler &#8212;<wbr></wbr> but it might
be nice for the generated names to start counting again from zero, in each
subsequent phase of the compiler.  Lastly, it is particularly tricky to use
this <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">gensym</code></span> in testing, as the precise numbers it generates are dependent
on the entire history of calls to <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">gensym</code></span>, which makes writing tests very brittle.</p><h5>1.4.3<tt>&nbsp;</tt><a name="(part._if._.Approach_2__.Tagging)"></a>Approach 2: Tagging</h5><p>In the last assignment, recall that our definition of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">expr</code></span> was slightly
more complicated than that presented above: it was parameterized by an
arbitrary type, allowing us to stash any data we wanted at the nodes of our
AST:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a expr =
  | ENumber of int64 * 'a
  | EId of string * 'a
  | ELet of (string * 'a expr * 'a) list * 'a expr * 'a
  | EPrim1 of prim1 * 'a expr * 'a
  ...</code></pre></div></div></p><p>We originally used this flexibility to tag every expression with its source
location information, so that we could give precisely-located error messages
when scoping problems arose.  But this parameter is more flexible than that: we
might consider walking the expression and giving every node a unique identifier:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type tag = int
let tag (e : 'a expr) : tag expr =
  let rec help (e : 'a expr) (cur : tag) : (tag expr * tag) =
    match e with
    | EPrim1(op, e, _) -&gt;
      let (tag_e, next_tag) = help e (cur + 1) in
      (EPrim1(op, tag_e, cur), next_tag)
    | ...
  in
  let (tagged, _) = help e 1 in tagged;;</code></pre></div></div></p><p>This function is completely determined by its input, without relying on mutable
state, making it much easier to work with in the context of testing.  It also
implicitly resets counting every time it&rsquo;s called, making the successive phases
of the compiler more readable and independent.  Lastly, if we use these ids as
the basis for our generated names, then our generated names are easily traceable
back to the expressions that created them, making debugging much easier.</p><h5>1.4.4<tt>&nbsp;</tt><a name="(part._if._.Putting_it_together__compiling_if-expressions)"></a>Putting it together: compiling if-expressions</h5><p>If we use our decorated <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a expr</code></span> definition and our <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">tag</code></span> function
above, then compiling if-expressions becomes:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec compile_expr (e : tag expr) (si : int) (env : (string * int) list) =
  match e with
  ...
  | EIf(cond, thn, els, tag) -&gt;
    let else_label = sprintf "if_false_%d" tag in
    let done_label = sprintf "done_%d" tag in
    (compile_expr cond) @
    [
      ICmp(Reg(RAX), Const(0));
      IJe(else_label)
    ]
    @ (compile_expr thn si env)
    @ [ IJmp(done_label); ILabel(else_label) ]
    @ (compile_expr els si env)
    @ [ ILabel(done_label) ]

let compile e =
  let tagged = tag e in
  let compiled = compile_expr tagged 1 [] in
  (* ... surround compiled with prelude as needed ... *)</code></pre></div></div></p><h4>1.5<tt>&nbsp;</tt><a name="(part._if._.Testing)"></a>Testing</h4><p><p>As always, we must test our enhancements.  Properly testing if-expressions is
slightly tricky right now: we need to confirm that
</p><ul><li><p>We always generate valid assembly</p></li><li><p>If-expressions compose properly with each other, and with other
expressions in the language.</p></li><li><p>The generated assembly only ever executes one of the two branches of an
if-expression</p></li></ul></p><p>Testing the first property amounts to testing the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">tag</code></span> function, to confirm
that it never generates duplicate ids in a given expression.  Testing the next
one can be done by writing a suite of programs in this language and confirming
that they produce the correct answers.  Testing the last requirement is
hardest: we don&rsquo;t yet have a way to signal errors in our programs (for example,
the compiled equivalent of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">failwith "This branch shouldn't run!"</code></span>)  For
now, the best we can do is manually inspect the generated output and confirm
that it is correct-by-construction, but this won&rsquo;t suffice forever.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Add a new <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Prim1</code></span> operator to the language, that you can recognize
and <span style="font-style: italic">deliberately compile</span> into invalid assembly that crashes the compiled
program.  Use this side-effect to confirm that the compilation of
if-expressions only ever executes one branch of the expression.  <span style="font-style: italic">Hint:</span>
using the
<a href="https://stackoverflow.com/a/45053244/783424"><code>sys_exit(int)</code></a>
syscall is probably helpful.</p></blockquote><h3>2<tt>&nbsp;</tt><a name="(part._infix._.Growing_the_language__adding_infix_operators)"></a>Growing the language: adding infix operators</h3><p><p>Again, we follow our standard recipe:
</p><ol><li><p>Its impact on the <span style="font-style: italic">concrete syntax</span> of the language</p></li><li><p>Examples using the new enhancements, so we build intuition of them</p></li><li><p>Its impact on the <span style="font-style: italic">abstract syntax</span> and <span style="font-style: italic">semantics</span> of the language</p></li><li><p>Any new or changed <span style="font-style: italic">transformations</span> needed to process the new
forms</p></li><li><p>Executable <span style="font-style: italic">tests</span> to confirm the enhancement works as intended</p></li></ol></p><h4>2.1<tt>&nbsp;</tt><a name="(part._infix._.The_new_concrete_syntax)"></a>The new concrete syntax</h4><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._infix._(bnf-prod._(binops._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._infix._%28bnf-prod._%28binops._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">+</span> <span class=""><a href="#%28elem._infix._%28bnf-prod._%28binops._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._infix._%28bnf-prod._%28binops._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">-</span> <span class=""><a href="#%28elem._infix._%28bnf-prod._%28binops._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._infix._%28bnf-prod._%28binops._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">*</span> <span class=""><a href="#%28elem._infix._%28bnf-prod._%28binops._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span></p></blockquote><h4>2.2<tt>&nbsp;</tt><a name="(part._infix._.Examples_and_semantics)"></a>Examples and semantics</h4><p>These new expression forms should be familiar from standard arithmetic
notation.  Note that there is no notion of operator precedence; instead, we use
the tree structure to indicate grouping.  For this language, we will decide
that the order of evaluation should be leftmost-innermost: that is, in the
expression <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(2 - 3) + (4 * 5)</code></span>, the evaluation order should step through</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">    (2 - 3) + (4 * 5)
==&gt; -1 + (4 * 5)
==&gt; -1 + 20
==&gt; 19</code></pre></div></div></p><p>rather than the possible alternative of doing the multiplication first.</p><h4>2.3<tt>&nbsp;</tt><a name="(part._infix._.Enhancing_the_abstract_syntax)"></a>Enhancing the abstract syntax</h4><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type prim2 =
  | Plus
  | Minus
  | Times

type expr = ...
  | EPrim2 of prim2 * expr * expr</code></pre></div></div></p><p>We simply add a new constructor describing our primitive binary operations, and
an enumeration of what those operations might be.</p><h4>2.4<tt>&nbsp;</tt><a name="(part._infix._.Enhancing_the_transformations__.Normalization)"></a>Enhancing the transformations: Normalization</h4><p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>What goes wrong with our current naive transformations?  How can we
fix them?</p></blockquote><p>Let&rsquo;s try manually &ldquo;compiling&rdquo; some simple binary-operator expressions to
assembly:</p></p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Original expression</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Compiled assembly</p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(2 + 3) + 4</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RAX, 2
add RAX, 3
add RAX, 4</code></pre></div></div></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(4 - 3) - 2</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RAX, 4
sub RAX, 3
sub RAX, 2</code></pre></div></div></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">((4 - 3) - 2) * 5</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RAX, 4
sub RAX, 3
sub RAX, 2
mul RAX, 5</code></pre></div></div></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(2 - 3) + (4 * 5)</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RAX, 2
sub RAX, 3
?????</code></pre></div></div></p></td></tr></table></p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Convince yourself that using a let-bound variable in place of any of
these constants will work just as well.</p></blockquote><p>So far, our compiler has only ever had to deal with a single active expression
at a time: it moves the result into <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>, increments or decrements it, and
then potentially moves it somewhere onto the stack, for retrieval and later
use.  But with our new compound expression forms, that won&rsquo;t suffice: the
execution of <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(2 - 3) + (4 * 5)</code></span> above clearly must stash the result of
<span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(2 - 3)</code></span> somewhere, to make room in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> for the subsequent
multiplication.  We might try to use another register (<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBX</code></span>, maybe?), but
clearly this approach won&rsquo;t scale up, since there are only a handful of
registers available.  What to do?</p><h5>2.4.1<tt>&nbsp;</tt><a name="(part._infix._.Immediate_expressions)"></a>Immediate expressions</h5><p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Why did the first few expressions compile successfully?</p></blockquote><p>Notice that for the first few expressions, all the arguments to the operators
were <span style="font-style: italic">immediately ready</span>:
</p><ul><li><p>They required no further computation to be ready.</p></li><li><p>They were either constants, or variables that could be read off the
stack.</p></li></ul></p><p>Perhaps we can salvage the final program by transforming it somehow, such that
all its operations are on immediate values, too.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Try to do this: Find a program that computes the same answer, in the same
order of operations, but where every operator is applied only to immediate values.</p></blockquote><p>Note that conceptually, our last program is equivalent to the following:</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let first = 2 - 3 in
let second = 4 * 5 in
first + second</code></pre></div></div></p><p>This program has decomposed the compound addition expression into the sum of
two let-bound variables, each of which is a single operation on immediate
values.  We can easily compile each individual operation, and we already know
how to save results to the stack and restore them for later use, which means we
can compile this transformed program to assembly successfully.</p><p>This transformation can be generalized and systematized, and thereby make the
rest of compilation succeed where currently it would fail.  Let&rsquo;s examine it
more carefully in the next section.</p><h4>2.5<tt>&nbsp;</tt><a name="(part._infix._.Testing)"></a>Testing</h4><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Once you&rsquo;ve completed the section below, run the given source
programs through our compiler pipeline.  It should give us exactly the
handwritten assembly we intend.  If not, debug the compiler until it does.</p></blockquote><h3>3<tt>&nbsp;</tt><a name="(part._.A-.Normal_.Form)"></a>A-Normal Form</h3><p>Our goal is to transform our program such that every operator is applied only
to immediate values, such that every expression does exactly one thing with no
other internal computation necessary.  We will call such a form <span style="font-style: italic">A-Normal
Form</span><span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._53._lectureanf%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">Evidently the &ldquo;A&rdquo; doesn&rsquo;t stand for anything in particular, and
was originally <span type="math/tex" style="white-space: pre;" class="math-tex">\(\alpha\)</span>; it has been retroactively been defined as
<span style="font-style: italic">Administrative Normal Form</span>.</span></span> or <span style="font-style: italic">ANF</span> for short.  It&rsquo;s worth
writing a predicate to check this property for us, to formalize what we mean.
(We will say that a program is &ldquo;in ANF&rdquo; when it satisfies this property; we
will also use the word &ldquo;ANF&rdquo; colloquially as a verb to convert a program into
A-normal form.)  First let&rsquo;s capture our notion of immediate expressions:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let is_imm e =
  match e with
  | ENumber _ -&gt; true
  | EId _ -&gt; true
  | _ -&gt; false
;;</code></pre></div></div>
Simple enough.  Next we need to ensure that all operands are immediate:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec is_anf (e : 'a expr) : bool =
  match e with
  | EPrim1(_, e, _) -&gt; is_imm e
  | EPrim2(_, e1, e2, _) -&gt; is_imm e1 &amp;&amp; is_imm e2
  | ELet(binds, body, _) -&gt;
     List.for_all (fun (_, e, _) -&gt; is_anf e) binds
     &amp;&amp; is_anf body
  | EIf(cond, thn, els, _) -&gt; (* ??? *) cond &amp;&amp; is_anf thn &amp;&amp; is_anf els
  | _ -&gt; is_imm e
;;</code></pre></div></div></p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What function should we use to check <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">cond</code></span>?  Why?</p></blockquote><p>For primitives, we simply check that the arguments are immediate.  For
let-bindings, we recursively check all expressions to ensure that they too are
in A-normal form.  Conditionals are a bit tricky.  Certainly, the two
branches of the condition must be normalized, but what about the condition?  At
minimum, it too must be normalized, so we might check <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">is_anf cond</code></span>.  But
taking a step back, we might say that conditionals are somewhat like a
primitive, in that they examine their first argument and take action
accordingly: an if-expression in ANF should
not <span style="font-style: italic">also</span> be responsible for evaluating its condition down to a value.
So we will enforce that the condition itself must be <span style="font-style: italic">immediate</span>: the
appropriate check is <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">is_imm cond</code></span>.</p><h4>3.1<tt>&nbsp;</tt><a name="(part._.Converting_a_program_to_.A-.Normal_.Form)"></a>Converting a program to A-Normal Form</h4><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Try to systematically define a conversion function
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf : tag expr -&gt; unit expr</code></span> such that the resulting expression satisfies
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">is_anf</code></span>.</p></blockquote><p>There are several different ways to define &ldquo;the&rdquo; conversion into
ANF.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._54._lectureanf%29%29" data-pltdoc="x">2</a></span></span><span class="FootnoteContent">Which brings up the obvious complaint: if it is not unique, then how
is it a <span style="font-style: italic">normal</span> form?  The original definition of ANF was not given
algorithmically, but rather via a set of axioms to reason about equivalence of
programs.  When those axioms were applied systematically, the result is indeed
unique, and hence &ldquo;normal&rdquo;.  </span></span>  We present a simple one first, then refine
it.</p><p>The central idea is that to convert some expression <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e1 + e2</code></span> (or any other
operator), we must somehow obtain an immediate value describing the <span style="font-style: italic">answer</span>
of <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e1</code></span> and another describing the answer of <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e2</code></span>, which we can then
use for the addition.  Those immediate values might be constants, in which case
we&rsquo;re in luck.  But if either of them are variables, then we clearly need some
<span style="font-style: italic">context</span> to supply the definition of those variables.  That context is
going to be a list of variable bindings &#8212;<wbr></wbr> and each of those bindings must in
turn be in ANF, meaning that they might have context bindings of their own...</p><p>As a first guess, we might try to design our function as follows:
<div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">(* The result is a pair of an answer and a context.
   The answer must be an immediate, and the context must be a list of bindings
   that are all in ANF. *)
let rec anf_v1 (e : tag expr) : (unit expr * (string * unit expr) list) =
  match e with
  ...
  | EPrim2(Plus, left, right, tag) -&gt;
    let (left_ans, left_context) = anf_v1 left in
    let (right_ans, right_context) = anf_v1 right in
    let temp = sprintf "plus_%d" tag in
    (EId(temp, ()), (* the answer *)
     left_context @ (* the context needed for the left answer to make sense *)
     right_context @ (* the context needed for the right answer to make sense *)
     [(temp, EPrim2(Plus, left_ans, right_ans, ()))]) (* definition of the answer *)</code></pre></div></div></p><p><p>This is definitely on the right track, but it has the wrong signature: we want
to return an actual ANF expression, not an expression paired with a context.
Fortunately, it is very easy to convert the output of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf_v1</code></span> to the desired
form.
</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Do this.  Be careful of preserving the appropriate order of the
context bindings.</p></blockquote></p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Handling_conditionals)"></a>Handling conditionals</h4><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Define the case for if-expressions.  How should the branches be
handled?  Be careful to ensure that only one branch gets executed &#8212;<wbr></wbr> including
any relevant context!</p></blockquote><h5>3.2.1<tt>&nbsp;</tt><a name="(part._.Attempt_1__exponential_failure)"></a>Attempt 1: exponential failure</h5><p>Conditionals are challenging.  Suppose we had two if-expressions in a row, like
this:
<div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let c1 = ... in
let c2 = ... in
(let x = (if c1: 5 + 5 else 6 * 2) in
  (let y = (if c2: x * 3 else x + 5) in
    (rest-of-program)))</code></pre></div></div>
Ignoring <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">c1</code></span> and <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">c2</code></span> for now, how should we transform the conditionals?
All the branches are compound expressions and not immediates, so they clearly
need to be let-bound somewhere.  And our goal for the ANF transformation is to
say, all let-bindings should do exactly one thing on their right-hand-sides.
So how could we achieve this?  The only way to achieve this, given our current
goals, is to <span style="font-style: italic">commute</span> the conditionals outside their let-bindings:
<div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">~hl:2:s~(let x = ~hl:1:s~(if c1: 5 + 5 else 6 * 2)~hl:1:e~ in
  ~hl:4:s~(let y = ~hl:3:s~(if c2: x * 3 else x + 5)~hl:3:e~ in
    ~hl:5:s~(rest-of-program)~hl:5:e~)~hl:4:e~)~hl:2:e~

=== commute the if-c1 past the let-x ===&gt;

~hl:1:s~(if c1:
  ~hl:2:s~(let x = 5 + 5 in ~hl:4:s~(let y = ~hl:3:s~(if c2: x * 3 else x + 6)~hl:3:e~ in ~hl:5:s~(rest-of-program)~hl:5:e~)~hl:4:e~)~hl:2:e~
else
  ~hl:2:s~(let x = 6 * 2 in ~hl:4:s~(let y = ~hl:3:s~(if c2: x * 3 else x + 6)~hl:3:e~ in ~hl:5:s~(rest-of-program)~hl:5:e~)~hl:4:e~)~hl:2:e~)~hl:1:e~

=== commute the if-c2 past the let-y ===&gt;

~hl:1:s~(if c1:
  ~hl:2:s~(let x = 5 + 5 in
    ~hl:3:s~(if c2:
      ~hl:4:s~(let y = x * 3 in ~hl:5:s~(rest-of-program)~hl:5:e~)~hl:4:e~
    else
      ~hl:4:s~(let y = x + 6 in ~hl:5:s~(rest-of-program)~hl:5:e~)~hl:4:e~)~hl:3:e~)~hl:2:e~
else
  ~hl:2:s~(let x = 5 + 5 in
    ~hl:3:s~(if c2:
      ~hl:4:s~(let y = x * 3 in ~hl:5:s~(rest-of-program)~hl:5:e~)~hl:4:e~
    else
      ~hl:4:s~(let y = x + 6 in ~hl:5:s~(rest-of-program)~hl:5:e~)~hl:4:e~)~hl:3:e~)~hl:2:e~)~hl:1:e~</code></pre></div></div></p><p>But this is unfeasibly expensive: the bindings for <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">y</code></span> are duplicated, and
<span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">rest-of-program</code></span> has been replicated four times &#8212;<wbr></wbr> and that&rsquo;s just with
two conditions!  With more conditions, we would have exponential code duplication:
one copy corresponding to each path through our code.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._55._lectureanf%29%29" data-pltdoc="x">3</a></span></span><span class="FootnoteContent">And we haven&rsquo;t even
considered loops yet, which have an infinite number of paths through the
code...</span></span>  In general, even though our input program can be represented by a
syntax <span style="font-style: italic">tree</span>, the control flow of that program is a <span style="font-style: italic">directed
graph</span>, and it is well-known that the number of distinct paths through a
graph can be exponential in the number of nodes in the graph (if no cycles), or
worse (if cycles are present).</p><h5>3.2.2<tt>&nbsp;</tt><a name="(part._.Attempt_2__.Pragmatic_success)"></a>Attempt 2: Pragmatic success</h5><p>Instead, we make a very pragmatic compromise.  Recall that our invariant for
compilation is, &ldquo;the answer goes in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>.&rdquo;  If we ANF-transform both
branches of the conditional, then regardless of which one executes, the correct
answer will be in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>.  And <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> can easily be considered an
immediate value.  So, we&rsquo;ll agree to consider if-expressions, <span style="font-style: italic">in their
entirety</span>, to be valid on the right-hand-side of a let-binding if their
condition is immediate and their bodies are ANF&rsquo;ed.</p><p>In other words, we&rsquo;ll accept the following translation:</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">~hl:2:s~(let x = ~hl:1:s~(if c1: 5 + 5 else 6 * 2)~hl:1:e~ in
  ~hl:4:s~(let y = ~hl:3:s~(if c2: x * 3 else x + 5)~hl:3:e~ in
    ~hl:5:s~(rest-of-program)~hl:5:e~)~hl:4:e~)~hl:2:e~

=== ANF the branches ===&gt;

~hl:2:s~(let x = ~hl:1:s~(if c1: let temp1 = 5 + 5 in temp1 else let temp2 = 6 * 2 in temp2)~hl:1:e~
  ~hl:4:s~(let y = ~hl:3:s~(if c2: let temp3 = x * 3 in temp3 else let temp4 = x + 5 in temp4)~hl:3:e~
    ~hl:5:s~(rest-of-program)~hl:5:e~)~hl:4:e~)~hl:2:e~</code></pre></div></div></p><p>This avoids all code-duplication, at the cost of muddying our pristine
description of what it means to be in ANF.  That cost is worth it.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Complete the definition of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf_v1</code></span> for if-expressions, if you have
not yet done so.</p></blockquote><h4>3.3<tt>&nbsp;</tt><a name="(part._.Improving_the_translation)"></a>Improving the translation</h4><p><p>This ANF conversion is somewhat sloppy: it will generate far too many temporary
variables.
</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Find a simple expression that need not generate any extra variables,
but for which <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf_v1</code></span> generates at least one unneeded variable.</p></blockquote></p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Refine the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf_v1</code></span> function into two helper functions, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf_C</code></span>
that can produce an answer that is any ANF expression, and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">anf_I</code></span> that can
produce only immediate values as answers.</p></blockquote><h4>3.4<tt>&nbsp;</tt><a name="(part._.An_alternate_approach__.Just_use_the_stack_)"></a>An alternate approach: Just use the stack!</h4><p>One could make the argument that converting to ANF is a complicated waste of
effort.  We could simply walk the tree of <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPrim2</code></span> expressions, evaluate
their left arguments and push them onto the stack &#8212;<wbr></wbr> after all, we have the
next-available stack index as a parameter to our compiler, since we use it to
compile let-bindings.  Then we evaluate the right argument, and push it onto
the stack.  We then can retrieve both arguments from the stack (since we know
where they were placed) and operate on them as normal &#8212;<wbr></wbr> effectively, we&rsquo;ve
made them into immediate arguments, without going through the motions of
creating all those let-bindings.  Then we can implicitly pop the two values off
the stack, basically, by forgetting they even exist, just as we do with
let-bound variables that go out of scope. Surely this is simpler!</p><p>On the face of it, it is indeed simpler.  But as we&rsquo;ll see later, this will
cause some additional headaches, because it entails that our stack frames are
of dynamic size, growing and shrinking depending on the complexity of the
expression being evaluated.  This isn&rsquo;t inherently a bad thing &#8212;<wbr></wbr> in fact, it
helps ensure that our stack is &ldquo;compact&rdquo;, without holes for values we haven&rsquo;t
defined or used yet &#8212;<wbr></wbr> but it will require <span style="font-style: italic">remembering</span> that our stack
frame size can change, independently of the let-bound variables in scope, which
will make subsequent phases of the compiler more tightly coupled to this one.</p><p>Additionally, though it isn&rsquo;t apparent so far, having code in A-normal form
actually <span style="font-style: italic">enables</span> some subsequent compiler passes, like optimizations,
that would be incredibly difficult to pull off otherwise.  The advantages of
keeping the compiler-phases less tightly coupled, along with the later benefits
of having code in a normalized form, tend to make ANF the winning engineering
tradeoff.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Complications_introduced_by_.A.N.F__.Inadvertent_shadowing__and_name_resolution)"></a>Complications introduced by ANF: Inadvertent shadowing, and name resolution</h3><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What should the ANF translation of the following program be?</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(let x = 1 in x) + (let x = 2 in x)</code></pre></div></div></p><p>Why?  What do we have to do to fix it?</p></blockquote><p>According to our rules, we encounter the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EPlus</code></span> expression, so we
transform both its operands, which gives essentially the following:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let (left_ans, left_context) = (EId("x"), [("x", ENum(1))]) in
let (right_ans, right_context) = (EId("x"), [("x", ENum(2))]) in
let temp = "plusExp" in
(EId(temp, ()), (* the answer *)
 left_context @ (* the context needed for the left answer to make sense *)
 right_context @ (* the context needed for the right answer to make sense *)
 [(temp, EPrim2(Plus, left_ans, right_ans, ()))]) (* definition of the answer *)</code></pre></div></div></p><p>This eventually produces the final program</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = 1 in
  let x = 2 in
    let plusExp = x + x in
      plusExp</code></pre></div></div></p><p>which evaluates to <span style="font-style: italic">four</span>, rather than the intended <span style="font-style: italic">three</span>.  The
problem is introduced when we blindly reorder the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">right_context</code></span> before the
use of the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">left_ans</code></span> in our output expression.  This is very unfortunate:
we would want our compiler to be able to reorder code when necessary without
being afraid of introducing semantic changes.  By reordering the code, we&rsquo;ve
inadvertently <span style="font-style: italic">captured</span> the first use of <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span>, such that it now refers
to the inner binding that shadows the first one.</p><p>The solution is to introduce another pass to our compiler that renames
variables throughout the program, in a manner consistent with the scoping and
shadowing rules, so that all variable names are unique.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._56._lectureanf%29%29" data-pltdoc="x">4</a></span></span><span class="FootnoteContent">Such a
scope-preserving renaming is called <span style="font-style: italic"><span type="math/tex" style="white-space: pre;" class="math-tex">\(\alpha\)</span>-renaming</span>, and two
programs which can be renamed into one another are said to be
<span style="font-style: italic"><span type="math/tex" style="white-space: pre;" class="math-tex">\(\alpha\)</span>-equivalent</span>.</span></span>  There is only one place in our pipeline
where this pass would help:</p><ul><li><p><span style="font-style: italic">after</span> scope checking, so that we know all names are genuinely
bound, but</p></li><li><p><span style="font-style: italic">before</span> ANFing, since the ANF transformation can introduce
shadowing by mistake.</p></li></ul><p>This new pass will take the form of a function</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rename (e : tag expr) : tag expr =
  let rec help e (env : (string * string) list) =
    match e with
    | EId(x, tag) -&gt;
      EId(... lookup x in the environment and replace it with the environment's
              renamed version ..., tag)
    | ELet([(x, e, x_tag)], body, tag) -&gt;
      (* NOTE: this only handles a single binding case; you'll have to
         generalize to multiple bindings *)
      let renamed_e = help e env in (* rename e consistently *)
      let renamed_x = sprintf "%s#%d" x x_tag in (* create new unique name for x *)
      let renamed_body = help body ((x, renamed_x)::env) in
      ELet([(renamed_x, renamed_e, x_tag)], renamed_body, tag)
    | ...
  in help e []</code></pre></div></div></p><p>Now, we can finally look at our current compiler pipeline:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let compile e =
  (* make sure all names are in scope, and then *)
  let tagged = tag e in
  let renamed = rename tagged in
  let anfed = anf renamed in
  let compiled = compile_expr anfed 1 [] in
  (* ... surround compiled with prelude as needed ... *)</code></pre></div></div></p><p>Quite a lot of changes, just for adding arithmetic and conditionals!</p><a name="(part._(gentag._52._lectureanf))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._53._lectureanf))"></a>1</span></span>Evidently the &ldquo;A&rdquo; doesn&rsquo;t stand for anything in particular, and
was originally <span type="math/tex" style="white-space: pre;" class="math-tex">\(\alpha\)</span>; it has been retroactively been defined as
<span style="font-style: italic">Administrative Normal Form</span>.</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._54._lectureanf))"></a>2</span></span>Which brings up the obvious complaint: if it is not unique, then how
is it a <span style="font-style: italic">normal</span> form?  The original definition of ANF was not given
algorithmically, but rather via a set of axioms to reason about equivalence of
programs.  When those axioms were applied systematically, the result is indeed
unique, and hence &ldquo;normal&rdquo;.  </p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._55._lectureanf))"></a>3</span></span>And we haven&rsquo;t even
considered loops yet, which have an infinite number of paths through the
code...</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._56._lectureanf))"></a>4</span></span>Such a
scope-preserving renaming is called <span style="font-style: italic"><span type="math/tex" style="white-space: pre;" class="math-tex">\(\alpha\)</span>-renaming</span>, and two
programs which can be renamed into one another are said to be
<span style="font-style: italic"><span type="math/tex" style="white-space: pre;" class="math-tex">\(\alpha\)</span>-equivalent</span>.</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>