<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 7: Defining functions</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 7:</span> Defining functions</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Warmup__a_new_primitive%29" class="tocviewlink" data-pltdoc="x">Warmup:<span class="mywbr"> &nbsp;</span> a new primitive</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.A_general-purpose_call_expression%29" class="tocviewlink" data-pltdoc="x">A general-<wbr></wbr>purpose call expression</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._fundefs._.Defining_our_own_functions%29" class="tocviewlink" data-pltdoc="x">Defining our own functions</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Testing%29" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 7:</span> Defining functions</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Warmup__a_new_primitive%29" class="tocsubseclink" data-pltdoc="x">Warmup:<span class="mywbr"> &nbsp;</span> a new primitive</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.A_general-purpose_call_expression%29" class="tocsubseclink" data-pltdoc="x">A general-<wbr></wbr>purpose call expression</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._.Concrete_syntax%29" class="tocsubseclink" data-pltdoc="x">Concrete syntax</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._.Examples%29" class="tocsubseclink" data-pltdoc="x">Examples</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._.Abstract_syntax_and_.Semantics%29" class="tocsubseclink" data-pltdoc="x">Abstract syntax and Semantics</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#%28part._.Making_the_call%29" class="tocsubseclink" data-pltdoc="x">Making the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span></a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._fundefs._.Defining_our_own_functions%29" class="tocsubseclink" data-pltdoc="x">Defining our own functions</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._fundefs._.Semantics%29" class="tocsubseclink" data-pltdoc="x">Semantics</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._fundefs._.Compilation%29" class="tocsubseclink" data-pltdoc="x">Compilation</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Testing%29" class="tocsubseclink" data-pltdoc="x">Testing</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="LectureNum">Lecture 7:</span> Defining functions</h2><p>Last time we built up the infrastructure for calling functions in a manner
that&rsquo;s compatible with the C calling convention, so that we could interact with
functions defined in our <code>main.c</code> runtime.  This prompts the obvious
generalization: can we expand our <span style="font-style: italic">source</span> language to include function
calls too?  Could we expand it further to define our own functions?</p><h3>1<tt>&nbsp;</tt><a name="(part._.Warmup__a_new_primitive)"></a>Warmup: a new primitive</h3><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Enhance your compiler with a new unary primitive, <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span>, that
accepts a single argument, prints it to the console, and returns its value.</p><p>This is not particularly general-purpose, but it allows us to focus on
providing a new runtime function and using it from within our language, rather
than by needing to create additional syntax just yet.</p></blockquote><p>We already have a printing function in <code>main.c</code>, from <a href="lec_tagging-values_notes.html" data-pltdoc="x">Lecture 5</a>:</p><p><div class="sourceCodeWrapper"><span data-label="C/C++" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-csrc" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">typedef uint64_t SNAKEVAL;
const uint64_t BOOL_TAG   = 0x0000000000000001;
const SNAKEVAL BOOL_TRUE  = ...; // These must be the same values
const SNAKEVAL BOOL_FALSE = ...; // as chosen in compile.ml
SNAKEVAL print(SNAKEVAL val) {
  if ((val &amp; BOOL_TAG) == 0) { // val is even ==&gt; number
    printf("%ld", ((int64_t)(val)) / 2); // shift bits right to remove tag
  } else if (val == BOOL_TRUE) {
    printf("true");
  } else if (val == BOOL_FALSE) {
    printf("false");
  } else {
    printf("Unknown value: %#018x", val); // print unknown val in hex
  }
  return val;
}</code></pre></div></div></p><p>We&rsquo;ll need to expose this code to our generated assembly: add a line to our
program&rsquo;s prologue that declares</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">extern print</code></pre></div></div></p><p>We just need to generate code for the new <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Print</code></span> <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">prim1</code></span> operator.
This should reuse the same function-call mechanisms that we developed last time
for reporting errors.</p><h3>2<tt>&nbsp;</tt><a name="(part._.A_general-purpose_call_expression)"></a>A general-purpose call expression</h3><p>Of course, we can&rsquo;t add new hard-coded primitive names to our language every
single time we want to define a new function.  Moreover, if we want to define
functions of more than one argument, we can&rsquo;t just use <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">prim2</code></span> (whose syntax
is all infix operators) or <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">prim3</code></span> (which doesn&rsquo;t exist)...</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><ol><li><p>Extend the source language with a new expression form for function calls</p></li><li><p>Give examples of functions we&rsquo;d like to provide, and examples of their use</p></li><li><p>Extend the abstract syntax and its semantics</p></li><li><p>Extend our transformations</p></li><li><p>Test the new expressions</p></li></ol></blockquote><h4>2.1<tt>&nbsp;</tt><a name="(part._.Concrete_syntax)"></a>Concrete syntax</h4><p>We&rsquo;ll start with concrete syntax: a function call starts with a function name
and takes zero or more comma-separated expressions as arguments.  There is no
whitespace permitted between the function name and the left-parenthesis.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._44._lecturefunction-defs%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">There&rsquo;s
a fiddly syntactic nuisance to deal with here.  Our language already accepts
identifiers as expressions by themselves.  We might also want to add parenthesized
expressions for clarity&rsquo;s sake.  Once we do that, though, it becomes difficult
to tell whether <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f(1 + 2)</code></span> is a function call, or an identifier followed by
a parenthesized expression.  While it might seem obvious to us, by taking a
holistic look at the language we currently have, that we can never have two
consecutive expressions, it&rsquo;s not at all obvious to the parser.  In practice
there are a number of workarounds for this: the one we choose for now is to say
that whitespace is prohibited, and that when no whitespace is present we try to
parse the code as a function call.  When we talk about parsing techniques later
in the course, we&rsquo;ll talk about other ways we might resolve this ambiguity.</span></span></p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(funcalls._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28funcalls._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(funcalls._exprs)))"></a><span class="bnf-rule">&#8249;exprs&#8250;</span><span class="bnf-meta">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28funcalls._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span><span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28funcalls._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28funcalls._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span></p></blockquote><h4>2.2<tt>&nbsp;</tt><a name="(part._.Examples)"></a>Examples</h4><p>For our examples, let&rsquo;s design <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max</code></span>, which takes two numeric arguments and
returns the larger of the two.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Define the <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">max</code></span> function in <code>main.c</code>.</p></blockquote><p>It&rsquo;s pretty easy to define the <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">max</code></span> function, assuming the arguments are
indeed numbers!  But we can&rsquo;t make that assumption in our runtime: it would be
a shame for <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(5, false)</code></span> to return <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span>.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Why would the result be <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">false</code></span>? (Hint: consider the
bit-level representations...)</p></blockquote><p>Instead, we&rsquo;ll need to include logic in our runtime implementation of <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">max</code></span>
that mimics the tag-checking emitted by our compiler.</p><p>We&rsquo;d expect the following examples to work:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Source</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Output</p></td></tr><tr><td><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(1, 2)</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">2</code></span></p></td></tr><tr><td><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(5, -15)</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">5</code></span></p></td></tr><tr><td><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(true, 5)</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Runtime Error: expected number, got true</code></span></p></td></tr></table></p><h4>2.3<tt>&nbsp;</tt><a name="(part._.Abstract_syntax_and_.Semantics)"></a>Abstract syntax and Semantics</h4><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What should the semantics of <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f(e1, e2, ..., en)</code></span> be?  How should
we represent this in our <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">'a expr</code></span> data definition?  What knock-on effects
does it have for the transformation passes of our compiler?</p></blockquote><p>The first thing we might notice is that attempting to call an unknown function
should be prohibited &#8212;<wbr></wbr> this is analogous to the scope-checking we already do
for variable names, and should be done at the same time.  Indeed, we can
generalize our scope-checking to a suite of <span style="font-style: italic">well-formedness</span> checks, that
assert that the program we&rsquo;re compiling is &ldquo;put together right&rdquo;.  (These
static checks include static type-checking, which we are not yet doing, and
in fact many popular languages these days are focusing heavily on improving the
precision and efficiency of their well-formedness checking as a way to improve
programmer efficiency and correctness.)  Checking for undefined functions
implies that we need something like an environment of known functions.  We
don&rsquo;t yet know what that environment should contain, but at a minimum it needs
to contain the names of the functions we support.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What other programmer mistakes should we try to catch with well-formedness
checking?  What new mistakes are possible with function calls?</p></blockquote><p>What should happen if a programmer tries to call <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(1)</code></span> or
<span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(1, 2, 3)</code></span>?  Certainly nothing good can happen at runtime if we
allowed this to occur.  Fortunately, we can track enough information to prevent
this at well-formedness time, too.  Our function environment should keep track
of known function names and their arities.  Then we can check every function
call expression and see whether it contains the correct number of actual
arguments.</p><p><p>We need more examples:
</p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Source</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Output</p></td></tr><tr><td><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(1)</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Compile Error: expected 2 arguments, got 1</code></span></p></td></tr><tr><td><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">max(1, 2, 3)</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Compile Error: expected 2 arguments, got 3</code></span></p></td></tr><tr><td><p><span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">unknown(1, 2)</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Compile Error: unknown function 'unknown'</code></span></p></td></tr></table></p><p>To represent call expressions in our AST, we just need to keep track of the
function name, the argument list, and any tag information:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a expr = ...
  | EApp of string * 'a expr list * 'a</code></pre></div></div></p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Extend <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">tag</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">untag</code></span> to support this new construction.</p></blockquote><p>We need to consider how our expression evaluates, which in turn means
considering how it should normalize under ANF.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What are the design choices here?</p></blockquote><p>Since <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EApp</code></span> expressions are compound, containing multiple subexpressions,
they probably should normalize similar to how we normalize <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">prim2</code></span>
expressions: the arguments should all be made immediate.</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">let rec is_anf (e : 'a expr) : bool =
  match e with
  ...
  | EApp(f, args, _) -&gt; List.for_all is_imm args</code></pre></div></div></p><p>We have at least two possible designs here, for how to normalize these
expressions: we can choose a left-to-right or right-to-left evaluation order
for the arguments.  For consistency with infix operators, we&rsquo;ll choose a
left-to-right ordering.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What tiny example program, using only the expressions we have so
far, would demonstrate the difference between these two orderings?</p></blockquote><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Define the ANF transformation for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EApp</code></span>.</p></blockquote><h4>2.4<tt>&nbsp;</tt><a name="(part._.Making_the_call)"></a>Making the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span></h4><p>Once we&rsquo;ve confirmed our program is well-formed, and subsequently ANFed it,
what information do we need to retain in our compiler in order to finish the
compilation?  Do we still need the function environment?  Not really!  Assuming
that the function name is the same as label name that we <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span>, we don&rsquo;t
need anything else but that name and the immediate arguments of the call.
After that, we output the same calling code as when implementing <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Print</code></span>
above.  Remember to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push</code></span> the arguments in <span style="font-style: italic">reverse order</span>, so that
the first argument is closest to the top of the stack.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Redefine <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> as a callable function, instead of as a
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">prim1</code></span> operator.</p></blockquote><h3>3<tt>&nbsp;</tt><a name="(part._fundefs._.Defining_our_own_functions)"></a>Defining our own functions</h3><p>Being able to call other functions is just one side of the story; being able to
define our own is the other half.  We&rsquo;ve already discussed the responsibilities
of a function body in order to be a responsible participant in the C call
stack.  Now we merely need to &ldquo;do the same thing&rdquo; for our own functions.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><ol><li><p>Extend the source language with syntax for function definitions</p></li><li><p>Give examples of functions we&rsquo;d like to provide, and examples of their use</p></li><li><p>Extend the abstract syntax and its semantics</p></li><li><p>Extend our transformations</p></li><li><p>Test the new expressions</p></li></ol></blockquote><p>This time, we need to really change our syntactic structure.  Our programs
can&rsquo;t just be expressions any longer: we need some notion of function
definitions, too.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._fundefs._(bnf-prod._(fundefs._program)))"></a><span class="bnf-rule">&#8249;program&#8250;</span><span class="bnf-meta">:</span> 
                <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._decls%29%29%29" data-pltdoc="x">&#8249;decls&#8250;</a></span> <span class=""><a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
                <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
<a name="(elem._fundefs._(bnf-prod._(fundefs._decls)))"></a><span class="bnf-rule">&#8249;decls&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._decl%29%29%29" data-pltdoc="x">&#8249;decl&#8250;</a></span>
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._decl%29%29%29" data-pltdoc="x">&#8249;decl&#8250;</a></span> <span class=""><a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._decls%29%29%29" data-pltdoc="x">&#8249;decls&#8250;</a></span>
<a name="(elem._fundefs._(bnf-prod._(fundefs._decl)))"></a><span class="bnf-rule">&#8249;decl&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class="bnf-lit">def</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._ids%29%29%29" data-pltdoc="x">&#8249;ids&#8250;</a></span> <span class="bnf-lit">)</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">def</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">(</span> <span class="bnf-lit">)</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
<a name="(elem._fundefs._(bnf-prod._(fundefs._ids)))"></a><span class="bnf-rule">&#8249;ids&#8250;</span><span class="bnf-meta">:</span> 
        <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span>
        <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._ids%29%29%29" data-pltdoc="x">&#8249;ids&#8250;</a></span>
<a name="(elem._fundefs._(bnf-prod._(fundefs._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span></p></blockquote><p>A <a href="#%28elem._fundefs._%28bnf-prod._%28fundefs._program%29%29%29" data-pltdoc="x">&#8249;program&#8250;</a> is now a list of zero or more function
declarations, followed by a single expression that is the main result of the
program.</p><p>As an example:</p><p><div class="sourceCodeWrapper"><span data-label="Diamondback" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def sum3(x, y, z):
  x + y + x

sum3(4, 5, 6)</code></pre></div></div></p><p>This program should evaluate to 15.</p><p>Our AST representation now grows to match:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a decl =
    (* function name, argument names, body, tag *)
  | DFun of string * string list * 'a expr * 'a

type 'a program =
  | Program of 'a decl list * 'a expr</code></pre></div></div></p><h4>3.1<tt>&nbsp;</tt><a name="(part._fundefs._.Semantics)"></a>Semantics</h4><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What new semantic concerns do we have with providing our own
definitions?</p></blockquote><p>As soon as we introduce a new form of definition into our language, we need to
consider scoping concerns.  One possibility is to declare that earlier
definitions can be used by later ones, but not vice versa.  This possibility is
relatively easy to implement, but restrictive: it prevents us from having
mutually-recursive functions.  Fortunately, because all our functions are
statically defined, supporting mutual recursion is not all that difficult; the
only complication is getting the well-formedness checks to work out correctly.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Do so.</p></blockquote><p>Additionally, the bodies of function definitions need to consider scope as
well.</p><p><div class="sourceCodeWrapper"><span data-label="Diamondback" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def sum3(x, y, z):
  a + b + c

x + 5</code></pre></div></div></p><p>This program refers to names that are not in scope: <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">a</code></span>, <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">b</code></span> and <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">c</code></span>
are not in scope within <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">sum3</code></span>, and <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> is not in scope outside of it.</p><p><div class="sourceCodeWrapper"><span data-label="Diamondback" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def f(x): x

def f(y): y

f(3)</code></pre></div></div></p><p>Repeatedly defining functions of the same name should be problematic: which
function is intended to be called?</p><p><div class="sourceCodeWrapper"><span data-label="Diamondback" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def f(x, x): x

f(3, 4)</code></pre></div></div></p><p>Having multiple arguments of the same name should be problematic: which
argument should be returned here?</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>What should we do with the following program, assuming our work
above on builtin functions is completed?</p><p><div class="sourceCodeWrapper"><span data-label="Diamondback" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def max(x, y):
  if x &lt; y: y else: x

true</code></pre></div></div></p></blockquote><h4>3.2<tt>&nbsp;</tt><a name="(part._fundefs._.Compilation)"></a>Compilation</h4><p>As we mentioned in <a href="lec_function-calls_notes.html" data-pltdoc="x">Lecture 6</a>, a function body needs to
actively participate in the call-stack in order to be usable.  To do that, it
must (1) save the previous base pointer <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> onto the stack, (2) copy the
current stack pointer <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> into <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span>, and (3) reserve space for its
local variables by decrementing <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span>.  At the end of the function, it must
undo those steps by (1) restoring <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> to its previous value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span>,
(2) popping the saved base-pointer value back into <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span>, and (3) returning
to the caller.</p><ul><li><p>At the start of the function:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push RBP          ; save (previous, caller's) RBP on stack
mov RBP, RSP      ; make current RSP the new RBP
sub RSP, 8*N      ; "allocate space" for N local variables</code></pre></div></div></p></li><li><p>At the end of the function</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RSP, RBP      ; restore value of RSP to that just before call
                  ; now, value at [RSP] is caller's (saved) RBP
pop RBP           ; so: restore caller's RBP from stack [RSP]
ret               ; return to caller</code></pre></div></div></p></li></ul><p><p>Between that prologue and epilogue, the body of the function basically is just
a normal expression, whose value winds up in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> as always.  However, the
crucial difference is that the body of a function can use its arguments while
evaluating&#8212;<wbr></wbr>that&rsquo;s the whole point of passing arguments to a function!  This
is similar in spirit to handling let-bound variables: we just need to keep
track of more mappings from names to stack locations.  However the details are
quite different: rather than looking <span style="font-style: italic">above</span> <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> (i.e. stack address
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP - 8 * i</code></span> contains the <span type="math/tex" style="white-space: pre;" class="math-tex">\(i^{th}\)</span> local variable), we need to look
<span style="font-style: italic">below</span> <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span>, where the arguments were pushed by our caller.  There&rsquo;s
a bit of a gap, though: at <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> itself is the <span style="font-style: italic">saved</span> caller&rsquo;s value
of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span>, and at <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP + 8</code></span> is the return address of our function.  So
</p><ul><li><p>In a stack-only calling convention, the zeroth argument to our function
can be found at <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP + 16</code></span>, and the <span type="math/tex" style="white-space: pre;" class="math-tex">\(i^{th}\)</span> argument can be found at
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP + 8 * (i + 2)</code></span>.</p></li><li><p>In the x64 calling convention, the first six arguments go in registers,
the <span style="font-style: italic">seventh</span> argument can be found at <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP + 16</code></span>, and the <span type="math/tex" style="white-space: pre;" class="math-tex">\((i +
6)^{th}\)</span> argument can be found at <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP + 8 * (i + 2)</code></span>.</p></li></ul></p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Complete the remaining stages of the pipeline: enhance ANF to work
over programs; generate valid assembly output for each of our functions using
the calling convention we discussed last time; and write test programs to
confirm that the scoping of functions works properly.  Can you support
recursion?  Mutual recursion?</p></blockquote><h3>4<tt>&nbsp;</tt><a name="(part._.Testing)"></a>Testing</h3><p>Now that we have functions and builtins, especially ones that can produce
output, we&rsquo;re gaining the ability to write non-trivial test programs.  At this
point, it starts becoming more useful to write integration tests, namely entire
programs in our language that we run through the entire compiler pipeline and
execute.  Unit tests still have their place: it&rsquo;s very easy to make a tiny
mistake somewhere in the compiler and produce bizarre or inexplicable output.
Narrowing down the cause of the error is tricky, and requires careful attention
to each stage of our pipeline.</p><p>Additionally, now that we&rsquo;re manipulating the stack in earnest, we should be
particularly careful that we conform to the calling convention.
<span style="font-weight: bold"><a href="http://valgrind.org/">Valgrind</a></span> is a tool that&rsquo;s designed
to help check such issues.  Once you&rsquo;ve compiled <code>output/foo.run</code> to
produce an executable, executing <code>valgrind output/foo.run</code> will run your
program within a sandboxed environment that can check for common mistakes in
the calling convention.  A clean valgrind run will report no errors.
Interpreting valgrind errors can be tricky, but a useful strategy (as always)
is to minimize the input program until there&rsquo;s hardly anything left, and
removing anything else seems to make the problem disappear.  At that point,
start diving into the compiler phases that influence that output, and write
unit tests for them.</p><a name="(part._(gentag._43._lecturefunction-defs))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._44._lecturefunction-defs))"></a>1</span></span>There&rsquo;s
a fiddly syntactic nuisance to deal with here.  Our language already accepts
identifiers as expressions by themselves.  We might also want to add parenthesized
expressions for clarity&rsquo;s sake.  Once we do that, though, it becomes difficult
to tell whether <span title="Diamondback" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">f(1 + 2)</code></span> is a function call, or an identifier followed by
a parenthesized expression.  While it might seem obvious to us, by taking a
holistic look at the language we currently have, that we can never have two
consecutive expressions, it&rsquo;s not at all obvious to the parser.  In practice
there are a number of workarounds for this: the one we choose for now is to say
that whitespace is prohibited, and that when no whitespace is present we try to
parse the code as a function call.  When we talk about parsing techniques later
in the course, we&rsquo;ll talk about other ways we might resolve this ambiguity.</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>