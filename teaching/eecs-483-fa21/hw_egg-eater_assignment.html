<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Assignment 8: Egg-eater: Tuples</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 8:</span> Egg-<wbr></wbr>eater:<span class="mywbr"> &nbsp;</span> Tuples</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Language_and_.Requirements%29" class="tocviewlink" data-pltdoc="x">Language and Requirements</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Syntax_.Additions_and_.Semantics%29" class="tocviewlink" data-pltdoc="x">Syntax Additions and Semantics</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Desugaring_away_unnecessary_complexity%29" class="tocviewlink" data-pltdoc="x">Desugaring away unnecessary complexity</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Semantics_and_.Representation_of_.Tuples%29" class="tocviewlink" data-pltdoc="x">Semantics and Representation of Tuples</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Approaching_.Reality%29" class="tocviewlink" data-pltdoc="x">Approaching Reality</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.Wait__nil__%29" class="tocviewlink" data-pltdoc="x">Wait, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>??</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#%28part._.Recommended_.T.O.D.O_.List%29" class="tocviewlink" data-pltdoc="x">Recommended TODO List</a></td></tr><tr><td align="right">8&nbsp;</td><td><a href="#%28part._.List_of_.Deliverables%29" class="tocviewlink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td align="right">9&nbsp;</td><td><a href="#%28part._.Grading_.Standards%29" class="tocviewlink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td align="right">10&nbsp;</td><td><a href="#%28part._.Submission%29" class="tocviewlink" data-pltdoc="x">Submission</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="AssignmentNum">Assignment 8:</span> Egg-<wbr></wbr>eater:<span class="mywbr"> &nbsp;</span> Tuples</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Language_and_.Requirements%29" class="tocsubseclink" data-pltdoc="x">Language and Requirements</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Syntax_.Additions_and_.Semantics%29" class="tocsubseclink" data-pltdoc="x">Syntax Additions and Semantics</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Desugaring_away_unnecessary_complexity%29" class="tocsubseclink" data-pltdoc="x">Desugaring away unnecessary complexity</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Semantics_and_.Representation_of_.Tuples%29" class="tocsubseclink" data-pltdoc="x">Semantics and Representation of Tuples</a></td></tr><tr><td><span class="tocsublinknumber">4.1<tt>&nbsp;</tt></span><a href="#%28part._.Tuple_.Heap_.Layout%29" class="tocsubseclink" data-pltdoc="x">Tuple Heap Layout</a></td></tr><tr><td><span class="tocsublinknumber">4.2<tt>&nbsp;</tt></span><a href="#%28part._.Accessing_.Tuple_.Contents%29" class="tocsubseclink" data-pltdoc="x">Accessing Tuple Contents</a></td></tr><tr><td><span class="tocsublinknumber">4.3<tt>&nbsp;</tt></span><a href="#%28part._.General_.Heap_.Layout%29" class="tocsubseclink" data-pltdoc="x">General Heap Layout</a></td></tr><tr><td><span class="tocsublinknumber">4.4<tt>&nbsp;</tt></span><a href="#%28part._.Interaction_with_.Existing_.Features%29" class="tocsubseclink" data-pltdoc="x">Interaction with Existing Features</a></td></tr><tr><td><span class="tocsublinknumber">4.5<tt>&nbsp;</tt></span><a href="#%28part._.Dealing_with_types%29" class="tocsubseclink" data-pltdoc="x">Dealing with types</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Approaching_.Reality%29" class="tocsubseclink" data-pltdoc="x">Approaching Reality</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.Wait__nil__%29" class="tocsubseclink" data-pltdoc="x">Wait, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>??</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._.Recommended_.T.O.D.O_.List%29" class="tocsubseclink" data-pltdoc="x">Recommended TODO List</a></td></tr><tr><td><span class="tocsublinknumber">8<tt>&nbsp;</tt></span><a href="#%28part._.List_of_.Deliverables%29" class="tocsubseclink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td><span class="tocsublinknumber">9<tt>&nbsp;</tt></span><a href="#%28part._.Grading_.Standards%29" class="tocsubseclink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td><span class="tocsublinknumber">10<tt>&nbsp;</tt></span><a href="#%28part._.Submission%29" class="tocsubseclink" data-pltdoc="x">Submission</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">7.5</span></div><h2><a name="(part._)"></a><span class="AssignmentNum">Assignment 8:</span> Egg-eater: Tuples</h2><p><h4 class="due">Due: Sat 03/21 at 8:59pm</h4></p><p><p class="git-clone"><code><span class="kw">git clone </span><input onclick="this.select();" readonly="readonly" value="https://github.ccs.neu.edu/cs4410/starter-egg-eater-typed"/></code></p></p><p><span style="color: red">Note: starter code will be made available Monday evening; use Monday to
read through the assignment and plan, rather than immediately start coding.</span></p><p><span style="font-style: italic">In this assignment you&rsquo;ll extend Taipan to implement mutable tuples,
whose syntax looks vaguely egg-shaped, if you don&rsquo;t think about it too much...</span></p><p><div class="sourceCodeWrapper"><div class="sourceCode"><pre data-lang="" class="sourceCode"><code data-lang="" class="sourceCode">(egg)</code></pre></div></div></p><p><p style="text-align: center"><img class="titleimage" src="https://c1.staticflickr.com/3/2416/2147232839_56c3687915_b.jpg"/></p></p><h3>1<tt>&nbsp;</tt><a name="(part._.Language_and_.Requirements)"></a>Language and Requirements</h3><p><p>Egg-eater starts with the same semantics as Taipan, and adds support for
</p><ul><li><p>tuple expressions: creating values, accessing components, and mutating
components</p></li><li><p>sequencing of expressions</p></li><li><p>simple recursive tuple types, with <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> values</p></li><li><p>richer binding syntax</p></li></ul><p>The runtime system must add support for
</p><ul><li><p>Allocating values on the heap, and avoiding heap overflows</p></li><li><p>Printing tuple values</p></li><li><p>Comparing tuple values for structural equality</p></li><li><p>Asking the user for input</p></li></ul></p><p>This is a large assignment, and its pieces are tightly interconnected.  Read
through the whole assignment below carefully, then take note of the recommended
TODO list at the bottom for a suggested order to tackle these pieces.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Syntax_.Additions_and_.Semantics)"></a>Syntax Additions and Semantics</h3><p>The main addition in Egg-eater is <span style="font-style: italic">tuple expressions</span>, along with accessor
expressions for getting or setting the contents of tuples, and a unary
primitive for checking if a value is a tuple.  Tuple expressions are a series
of <span style="font-style: italic">zero or more</span> comma-separated expressions enclosed in parentheses.
(The syntax of one-element tuples is slightly odd, and requires a trailing
comma; this is to avoid confusion with our existing use of parentheses for
grouping infix expressions.) A tuple access expression is an expression
followed by an integer literal enclosed in square brakcets, which expresses
which field to be accessed.  Finally, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">istuple</code></span> is a primitive (like
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">isnum</code></span> and <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">isbool</code></span>) that checks for tuple-ness.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Eggeater._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._tuple%29%29%29" data-pltdoc="x">&#8249;tuple&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._tuple-get%29%29%29" data-pltdoc="x">&#8249;tuple-get&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._tuple-set%29%29%29" data-pltdoc="x">&#8249;tuple-set&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">istuple</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Eggeater._tuple)))"></a><span class="bnf-rule">&#8249;tuple&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class="bnf-lit">)</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class="bnf-lit">)</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class="bnf-lit bnf-unknown">...</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Eggeater._tuple-get)))"></a><span class="bnf-rule">&#8249;tuple-get&#8250;</span><span class="bnf-meta">:</span> 
                    <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">ID</span> <span class="bnf-lit">[</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">of</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">]</span>
                    <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class="bnf-lit bnf-unknown">ID</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span> <span class="bnf-lit">)</span> <span class="bnf-lit">[</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">of</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">]</span>
                    <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._tuple-get%29%29%29" data-pltdoc="x">&#8249;tuple-get&#8250;</a></span> <span class="bnf-lit">[</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">of</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">]</span>
<a name="(elem._(bnf-prod._(.Eggeater._tuple-set)))"></a><span class="bnf-rule">&#8249;tuple-set&#8250;</span><span class="bnf-meta">:</span> 
                    <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">ID</span> <span class="bnf-lit">[</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">of</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">:=</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">]</span>
                    <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class="bnf-lit bnf-unknown">ID</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span> <span class="bnf-lit">)</span> <span class="bnf-lit">[</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">of</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">:=</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">]</span>
                    <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._tuple-set%29%29%29" data-pltdoc="x">&#8249;tuple-set&#8250;</a></span> <span class="bnf-lit">[</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">of</span> <span class="bnf-lit bnf-unknown">NUM</span> <span class="bnf-lit">:=</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">]</span>
<a name="(elem._(bnf-prod._(.Eggeater._bind)))"></a><span class="bnf-rule">&#8249;bind&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">_</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._binds%29%29%29" data-pltdoc="x">&#8249;binds&#8250;</a></span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Eggeater._binds)))"></a><span class="bnf-rule">&#8249;binds&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._bind%29%29%29" data-pltdoc="x">&#8249;bind&#8250;</a></span>
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._bind%29%29%29" data-pltdoc="x">&#8249;bind&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._binds%29%29%29" data-pltdoc="x">&#8249;binds&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Eggeater._typ)))"></a><span class="bnf-rule">&#8249;typ&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
        <span class="bnf-meta"> | </span><span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._startyps%29%29%29" data-pltdoc="x">&#8249;startyps&#8250;</a></span> <span class="bnf-lit">)</span>
        <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span> <span class="bnf-lit">&lt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._typs%29%29%29" data-pltdoc="x">&#8249;typs&#8250;</a></span> <span class="bnf-lit">&gt;</span>
<a name="(elem._(bnf-prod._(.Eggeater._typs)))"></a><span class="bnf-rule">&#8249;typs&#8250;</span><span class="bnf-meta">:</span> 
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._typs%29%29%29" data-pltdoc="x">&#8249;typs&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Eggeater._startyps)))"></a><span class="bnf-rule">&#8249;startyps&#8250;</span><span class="bnf-meta">:</span> 
                  <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span>
                  <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._typ%29%29%29" data-pltdoc="x">&#8249;typ&#8250;</a></span> <span class="bnf-lit">*</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._startyps%29%29%29" data-pltdoc="x">&#8249;startyps&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Eggeater._tydecl)))"></a><span class="bnf-rule">&#8249;tydecl&#8250;</span><span class="bnf-meta">:</span> 
              <span class="bnf-meta"> | </span><span class="bnf-lit">type</span> <span class="bnf-lit bnf-unknown">ID</span> <span class="bnf-lit">=</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._startyps%29%29%29" data-pltdoc="x">&#8249;startyps&#8250;</a></span> <span class="bnf-lit">)</span>
              <span class="bnf-meta"> | </span><span class="bnf-lit">type</span> <span class="bnf-lit bnf-unknown">ID</span> <span class="bnf-lit">&lt;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._tyids%29%29%29" data-pltdoc="x">&#8249;tyids&#8250;</a></span> <span class="bnf-lit">&gt;</span> <span class="bnf-lit">=</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._startyps%29%29%29" data-pltdoc="x">&#8249;startyps&#8250;</a></span> <span class="bnf-lit">)</span>
<a name="(elem._(bnf-prod._(.Eggeater._tyids)))"></a><span class="bnf-rule">&#8249;tyids&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class="bnf-eps">&#949;</span>
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._tyid%29%29%29" data-pltdoc="x">&#8249;tyid&#8250;</a></span>
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._tyid%29%29%29" data-pltdoc="x">&#8249;tyid&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._tyids%29%29%29" data-pltdoc="x">&#8249;tyids&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Eggeater._tyid)))"></a><span class="bnf-rule">&#8249;tyid&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit">&rsquo;</span> <span class="bnf-lit bnf-unknown">IDENTIFIER</span></p></blockquote><p>For example, we can create three tuples and access their fields:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let unit = () in
let one = (1,) in
let three = (3, 4, 5) in
three[0 of 3]</code></pre></div></div></p><p>A tuple-set expression evaluates both arguments, updates the tuple at the
appropriate index, and returns the entire tuple value as its result.  We can
therefore chain tuple-set expressions together, and write</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let three = (0, 0, 0) in
three[0 of 3 := 1][1 of 3 := 2][2 of 3 := 3]
# Now three equals (1, 2, 3)

let pair = (0, 0) in
pair[0 of 2 := three[1 of 3 := 10]]
# Now three equals (1, 10, 3) and pair equals (1, three)</code></pre></div></div></p><p>We can also actively <span style="font-style: italic">destructure</span> tuples when we bind them:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let t = (3, ((4, true), 5)) in
let (x, (y, z)) = t
x + y[0 of 2] + z</code></pre></div></div></p><p>Notice that we can destructure tuples &ldquo;all the way down&rdquo;, or &ldquo;stop early&rdquo;:
in this case, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">y</code></span> is bound to the tuple <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(4, true)</code></span>, or
said another way, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">y == t[1 of 2][0 of 2]</code></span>.</p><p>In the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">expr</code></span> datatype, these are represented as:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a expr =
  ...
  | ETuple of 'a expr list * 'a
  | EGetItem of 'a expr * int * int * 'a
  | ESetItem of 'a expr * int * int * 'a expr * 'a
  | ESeq of 'a expr * 'a expr * 'a

type prim1 =
  ...
  | IsTuple</code></pre></div></div></p><p><span style="font-weight: bold">Important:</span> The syntax for <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EGetItem</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ESetItem</code></span> are quite
odd-looking.  The restrictions here are added to make your task of
type-checking and type-inference easier:</p><ul><li><p>The left-most expression in a tuple-get or tuple-set expression must be
an identifier, so that you can look up the type of the expression in your
current type environment.  If that type is some type-variable, you might not
have enough information to type-check, and so type-checking can fail.
Therefore we also permit explicitly annotating the identifier with some
explicit type, to allow the programmer to help the typechecker.</p></li><li><p>When trying to infer a type for a tuple-get or tuple-set
expression, again you might only currently know that the tuple has some
type-variable as its type.  This is not enough to infer a type<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._5._assignmentegg-eater%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent">We say
that of all the tuple types, there is no <span style="font-style: italic">most general unifier</span> that could
be used instead.</span></span>, so we require that the programmer provide the width of the
tuple.  This is enough to infer a general tuple type of the appropriate size,
and inference can then further constrain those types.</p></li></ul><p>The parser will ensure that these well-formedness constraints are satisfied by user
programs; if you choose to create programs that do not satisfy the constraint,
then you&rsquo;ll need to support that generality in your type system instead.</p><p>In ANF syntax, these expressions are represented as <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">cexpr</code></span>s, with <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">immexpr</code></span>
components:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a cexpr =
  ...
  | CTuple of 'a immexpr list * 'a
  | CGetItem of 'a immexpr * int * 'a
  | CSetItem of 'a immexpr * int * 'a immexpr * 'a</code></pre></div></div></p><p>We&rsquo;re requiring integer literals in the index position, just as the concrete
syntax did.  Note that these expressions are all <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">cexpr</code></span>s, and not
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">immexpr</code></span>s &ndash; the allocation of a tuple counts as a &ldquo;step&rdquo; of execution,
and so they are not themselves already values.  Also note that the ANF
expressions do not include the tuple size; it&rsquo;s no longer needed syntactically.</p><p>To make the bindings work in our AST, we need to enhance our representation of
binding positions:</p><p><div class="sourceCodeWrapper"><span data-label="OCaml" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-ocaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">type 'a bind =
  | BName of string * 'a
  | BTuple of 'a bind list * 'a typ * 'a
  | BBlank of 'a typ * 'a

type 'a binding = ('a bind * 'a expr * 'a)

type 'a expr = ...
  | ELet of 'a binding list * 'a expr ' a

type 'a decl =
  | DFun of string * 'a bind list * 'a scheme * 'a expr * 'a</code></pre></div></div></p><p>Let-bindings now can take an arbitrary, deeply-structured binding, rather than
just simple names.  Further, because we have mutation of tuples, these act more
like statements than expressions, and so we may need to sequence multiple
expressions together.  Further still, sequencing of expressions acts just like
let-binding the first expression and then ignoring its result, before executing
the second expression.  In other words, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e1 ; e2</code></span> means the same
thing as <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let _ = e1 in e2</code></span>.  To avoid making up a new name for the
ignored value, we introduce <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">BBlank</code></span> bindings that indicate the programmer
doesn&rsquo;t need to store this value in a variable.  Lastly, now that we have
richer binding structure, we&rsquo;re going to use it everywhere, including in
function definitions:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def add-pairs((x1, y1), (x2, y2)):
  (x1 + x2, y1 + y2)</code></pre></div></div></p><p>This should be treated as syntactic sugar for a similar function</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def add_pairs(p1, p2):
  let (x1, y1) = p1, (x2, y2) = p2 in
  (x1 + x2, y1 + y2)</code></pre></div></div></p><p>(Your solution will likely generate different names than <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">p1</code></span> or
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">p2</code></span>.)</p><h3>3<tt>&nbsp;</tt><a name="(part._.Desugaring_away_unnecessary_complexity)"></a>Desugaring away unnecessary complexity</h3><p>The introduction of destructuring let-bindings, sequencing, and blanks all
make the rest of compliation complicated.  ANF&rsquo;ing, stack-slot allocation, and
compilation all are affected.  We can translate this mess away, though, and
avoid dealing with it further.</p><p><span style="font-weight: bold">Nested let-bindings:</span> Given a binding</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let (b1, b2, ..., bn) = e in body</code></pre></div></div></p><p>we can replace this entire expression with the simpler but more verbose</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let temp_name1 = e,
    b1 = temp_name1[0 of n],
    b2 = temp_name1[1 of n],
    ...,
    bn = temp_name1[(n-1) of n]
in body</code></pre></div></div></p><p>(Note that the <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(n-1)</code></span> in the last binding is <span style="font-style: italic">not</span> an
expression, but a compile-time constant literal integer, deduced solely from
the length of the original binding expression.)</p><p><span style="font-weight: bold">Nested function-argument bindings:</span>  Function arguments can now be nested
bindings as well.  The desugaring above <span style="font-style: italic">almost</span> works, except there&rsquo;s no
explicit <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e</code></span> expression to bind to the tuple.  Instead, you should
generate a temporary argument name, and treat the argument bindings as being
bound to those.  The example of <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">add_pairs</code></span> above gives the
intuition: it wraps the existing body of the function in these new
let-bindings, which reduces the problem to solving nested let-bindings.</p><p><span style="font-weight: bold">Sequences:</span>
You should implement a <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">desugar</code></span> phase of the compiler, which runs somewhere
early in the pipeline and which makes subsequent phases easier, by implementing
the translations described in this section.</p><p>Be sure to leave comments (near your <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">compile_to_string</code></span> pipeline)
explaining (1) <span style="font-style: italic">why</span> you chose the particular ordering of desguaring
relative to the other phases that you did, and (2) what <span style="font-style: italic">syntactic
invariants</span> each phase of your compiler expects.  You may want to enforce those
invariants by throwing <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">InternalCompilerError</code></span>s if they&rsquo;re violated.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Semantics_and_.Representation_of_.Tuples)"></a>Semantics and Representation of Tuples</h3><h4>4.1<tt>&nbsp;</tt><a name="(part._.Tuple_.Heap_.Layout)"></a>Tuple Heap Layout</h4><p>Tuples expressions should evaluate their sub-expressions in order from left to
right, and store the resulting values on the heap.  We discussed several
possible representations in class for laying out tuples on the heap; the one
you should use for this assignment is:</p><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_3.png" alt="image" width="506.0" height="59.96875"/></p><p>That is, one word is used to store the <span style="font-style: italic">count</span> of the number of elements in the
tuple, and the subsequent words are used to store the values themselves.  Note
that the count is an actual integer; it is not an encoded Egg-eater integer value.</p><p>A <span style="font-style: italic">tuple value</span> is stored in variables and registers as the address of the
first word in the tuple&rsquo;s memory, but with an additional <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">1</code></span> added to the value
to act as a tag.  So, for example, if the start address of the above memory
were <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x0adadad0</code></span>, the tuple value would be <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x0adadad1</code></span>.  With this change, we
extend the set of tag bits to the following:</p><ul><li><p>Numbers: <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0</code></span> in the least significant bit</p></li><li><p>Booleans: <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">111</code></span> in the three least significant bits</p></li><li><p>Tuples: <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">001</code></span> in the three least significant bits</p></li></ul><p>Visualized differently, the value layout is:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Bit pattern</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Value type</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0xWWWWWWW[www0]</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>Number</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0xFFFFFFF[1111]</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>True</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x7FFFFFF[1111]</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>False</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0xWWWWWWW[w001]</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>Tuple</p></td></tr></table></p><p>Where <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">W</code></span> is a &ldquo;wildcard&rdquo; nibble and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">w</code></span> is a &ldquo;wildcard&rdquo; bit.</p><h4>4.2<tt>&nbsp;</tt><a name="(part._.Accessing_.Tuple_.Contents)"></a>Accessing Tuple Contents</h4><p>In a <span style="font-style: italic">tuple access</span> expression, like</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let t = (6, 7, 8, 9) in t[1 of 2]</code></pre></div></div></p><p>The behavior should be:</p><ol><li><p>Evaluate the expression in tuple position (before the brackets), then the
index expression (the one inside the brackets).</p></li><li><p>Check that the tuple position&rsquo;s value is actually a tuple, and signal an
error containing <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">"expected tuple"</code></span> if not.</p></li><li><p><strike>Check that the actual tuple length matches the expected length, and signal
an error containing <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">"incorrect length"</code></span> if not.</strike></p></li><li><p>Check that the index number is a valid index for the tuple value &#8212;<wbr></wbr> that
is, it is between <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0</code></span> and the stored number of elements in the tuple minus
one.  Signal an error containing <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">"index too small"</code></span> or <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">"index too large"</code></span>
as appropriate.</p></li><li><p>Evaluate to the tuple element at the specified index.</p></li></ol><p>You <span style="font-style: italic">can</span> do this with just <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>, but it causes some minor pain.  The register
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R14</code></span> has been added to the registers in <code>instruction.ml</code> &#8212;<wbr></wbr> feel free to
generate code that uses both <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R14</code></span> in this case (for example saving
the index in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R14</code></span> and using <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> to store the address of the tuple).  This
can save a number of instructions.  Note that we will generate code that
doesn&rsquo;t need to use <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R14</code></span> or <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span> beyond the extent of this one expression, so
there is no need to worry about saving or restoring the old value from <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R14</code></span>.</p><p>You also may want to use an extended syntax for <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov</code></span> in order to combine these
values for lookup.  For example, this kind of arithmetic is allowed inside
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov</code></span> instructions:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RAX, [RAX + R14 * 8]</code></pre></div></div></p><p>This would access the memory at the location of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>, offset by the value of
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R14 * 8</code></span>.  So if the value in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R14</code></span> were, say <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">2</code></span>, this may be part
of a scheme for accessing the first element of a tuple (there are other details
you should think through here; this is <span style="font-style: italic">not</span> a complete solution) Feel free to
add additional <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">arg</code></span> types in <code>instruction.ml</code> to support a broader range of
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov</code></span> instructions, if it helps.</p><p>Neither <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R14</code></span> nor anything beyond the typical <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">RegOffset</code></span> is <span style="font-style: italic">required</span> to make
this work, but you may find it interesting to try different shapes of
generated instructions.</p><h4>4.3<tt>&nbsp;</tt><a name="(part._.General_.Heap_.Layout)"></a>General Heap Layout</h4><p>The register <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> has been designated as the heap pointer.  The provided
<code>main.c</code> does a large <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">malloc</code></span> call, and passes in the resulting address as an
argument to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">our_code_starts_here</code></span>.  The support code provided fetches this
value (as a traditional argument), and stores it in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span>.  It also does a bit
of arithmetic to make sure that <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> starts at a 16-byte boundary &#8212;<wbr></wbr> that is,
the last three <span style="font-style: italic">bits</span> of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> are <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0000</code></span>.  It is up to your code to ensure that:</p><ul><li><p>The value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> always ends in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0b0000</code></span>.  This ensures that the beginning of
each allocation happens at a 16-byte boundary, which means that we only need
60 bits of a 64-bit word in order to store addresses.  The least significant
bits are then fair game for the tag.  <span style="font-style: italic">At the moment,</span> we only need
three bits for tagging purposes, but to leave room for future growth (and to
practice the necessary techniques), we&rsquo;ll proactively ensure a fourth bit is
already available if we need it.</p></li><li><p>The value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> is always the address of the next block of free space (in
increasing address order) in the provided block of memory.</p></li></ul><p>The first point above means that for tuples that take up an odd amount of
8-byte words, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> needs to leave some &ldquo;dead space&rdquo; in order to align with a
16-byte boundary.  For example, assume before an allocation <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> is pointing at
address <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x0000ada0</code></span>:</p><p><img style="vertical-align: 3.0px; margin: -3px -3px -3px -3px;" src="pict_4.png" alt="image" width="244.5" height="130.921875"/></p><p>And then we need to allocate the tuple <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(4, true)</code></span>.  Since we need one word for
the size (2) and one word each for the two values <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">4</code></span> and <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span>, there are 3
words required to store the tuple.  If we left the heap in this state:</p><p><img style="vertical-align: 3.0px; margin: -3px -3px -3px -3px;" src="pict_5.png" alt="image" width="845.0" height="130.921875"/></p><p>Our heap pointer is 8-byte aligned, but is not 16-byte aligned: the address
ends in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x8</code></span>, so the fourth bit is non-zero and can&rsquo;t be used as a tag bit
(if it ever becomes necessary).  So instead of the above resulting picture,
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> should be moved one word further:</p><p><img style="vertical-align: 3.0px; margin: -3px -3px -3px -3px;" src="pict_6.png" alt="image" width="1044.5" height="130.921875"/></p><p>The <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">padding</code></span> is unused space to make the heap allocation strategy with tagging
work cleanly &#8212;<wbr></wbr> this is certainly a place where you can think about some
interesting tradeoffs (what are some of them?)</p><h4>4.4<tt>&nbsp;</tt><a name="(part._.Interaction_with_.Existing_.Features)"></a>Interaction with Existing Features</h4><p>Any time we add a new feature to a language, we need to consider its
interactions with all the existing features.  In the case of Egg-eater, that
means considering:</p><ul><li><p>If expressions</p></li><li><p>Function calls and definitions</p></li><li><p>Tuples in binary and unary operators</p></li><li><p>Let bindings</p></li><li><p>Typing rules</p></li></ul><p>We&rsquo;ll take them one at a time.</p><ul><li><p><span style="font-weight: bold">If expressions</span>:  Since we&rsquo;ve decided to only allow booleans in
conditional position, we simply need to make sure our existing checks for
boolean-tagged values in if continue to work for tuples.</p></li><li><p><span style="font-weight: bold">Function calls and definitions</span>:  Tuple values behave just like other
values when passed to and returned from functions &#8212;<wbr></wbr> the tuple value is just
a (tagged) address that takes up a single word.</p></li><li><p><span style="font-weight: bold">Tuples in let bindings</span>:  As with function calls and returns, tuple values
take up a single word and act just like other values in let bindings.</p></li><li><p><span style="font-weight: bold">Tuples in binary operators</span>:  The arithmetic expressions should
continue to only allow numbers, and signal errors on tuple values.  There is
one binary operator that doesn&rsquo;t check its types, however: <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">==</code></span>.  We need to
decide what the behavior of <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">==</code></span> is on two tuple values.  Note that we have a
(rather important) choice here.  Clearly, this program should evaluate to
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let t = (4, 5) in t == t</code></pre></div></div></p><p>However, we need to decide if</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(4,5) == (4,5)</code></pre></div></div></p><p>should evaluate to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">true</code></span> or <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">false</code></span>.  That is, do we check if the <span style="font-style: italic">tuple
addresses</span> are the same to determine equality, or if the <span style="font-style: italic">tuple contents</span> are
the same.  For this assignment, we&rsquo;ll take the somewhat simpler route and
compare <span style="font-style: italic">addresses</span> of tuples, so the second test should evaluate to
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">false</code></span>.</p><p>However, providing a structural equality operation, where we check the
tuple&rsquo;s contents (recursively, if needed), is also useful.  For this, write a
two-argument function <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">equal</code></span> in <code>main.c</code> that handles this.  Provide
this function as one of the built-in functions available in the global scope
of Egg-eater programs.  (Note that this does <span style="font-style: italic">not mean</span> that <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">equal</code></span>
should be added as a new <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">Prim1</code></span>!)  Your <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">equal</code></span> function should work on
all acyclic tuples of moderate depth, but does not have to be robust in the
presence of cycles or overflowing the C stack.</p></li><li><p><span style="font-weight: bold">Tuples in unary operators</span>: The behavior of the unary operators is
straightforward, with the exception that we need to implement <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> for
tuples.  We could just print the address, but that would be somewhat
unsatisfying.  Instead, we should recursively print the tuple contents, so
that the program</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print((4, (true, 3)))</code></pre></div></div></p><p>actually prints the string <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">"(4, (true, 3))"</code></span>.  This will require some
careful work with pointers in <code>main.c</code>.  A useful hint is to create a
recursive helper function for <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">print</code></span> that traverses the nested structure
of tuples and prints single values.  Again, your <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">print</code></span> function should
work properly for all acyclic tuples of reasonable depth, but does not have
to be robust in the presence of cycles or overflowing the C stack.  </p></li><li><p><span style="font-weight: bold">Types</span>.  </p></li></ul><h4>4.5<tt>&nbsp;</tt><a name="(part._.Dealing_with_types)"></a>Dealing with types</h4><p>There are several levels of complexity involved in enhancing your type systems
for this assignment, and not all of them are required for everyone.</p><ul><li><p><span style="font-weight: bold">Everyone: Required</span> &ndash; enhance your type <span style="font-style: italic">checker</span>
with support for non-recursive tuple types (i.e., tuples that contain numbers,
booleans, or tuples containing numbers, booleans..., but not arbitrary
recursive data definitions), and type definitions for them.</p></li><li><p><span style="font-weight: bold">CS6410 only: Required</span> &ndash; enhance your type <span style="font-style: italic">checker</span> with
support for recursive type definitions.  These could be either monomorphic or
polymorphic; the parser and AST are set up to support both.  You must support
monomorphic definitions.  You do <span style="font-style: italic">not</span> have to enhance your type
<span style="font-style: italic">inference</span> to support tuples, but you <span style="font-style: italic">do</span> need to explain (in a
comment in the <code>inference.ml</code> file) <span style="font-style: italic">why</span> type inference for tuples,
as we currently have them, is hard to do.</p></li><li><p><span style="font-weight: bold">Everyone: Optional</span> &ndash; enhance your type checker to support
polymorphic, recursive type definitions.</p></li><li><p><span style="font-weight: bold">Everyone: Optional</span> &ndash; enhance your type <span style="font-style: italic">inference</span> to
support as much of tuples and type definitions as you can.</p></li></ul><h3>5<tt>&nbsp;</tt><a name="(part._.Approaching_.Reality)"></a>Approaching Reality</h3><p>With the addition of tuples, Egg-eater is dangerously close to a useful
language.  Of course, it still puts no control on memory limits, doesn&rsquo;t have a
module system, and has other major holes.  However, since we have structured
data, we can now, for instance, implement a linked list.  We need to pick a
value to represent <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">empty</code></span>.  Since our tuples are heap-allocated,
let&rsquo;s make the same
<a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">billion
dollar mistake</a> that Sir Tony Hoare made, and create a <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> value.
Then we can write <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">link</code></span>, which creates a pair of the first with the
next link:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def link(first, rest):
  (first, rest)

let mylist = link(1, link(2, link(3, nil))) in
  mylist[0]</code></pre></div></div></p><p>Now we can write some list functions:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def length(l):
  if l == nil: 0
  else:
    1 + length(l[1 of 2])</code></pre></div></div></p><p>Try building on this idea, and writing up a basic list library.  Write at least
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">sum</code></span>, to add up a numeric list, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">append</code></span>, which
concatenates two lists, and <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">reverse</code></span>, which reverses a list.  Hand
them in in a file in the <code>input/</code> directory called <code>lists.egg</code>.
Remember that <code>make output/lists.run</code> will build the executable for this
file.</p><p>Write more functions if you want, as well, and test them out.</p><h3>6<tt>&nbsp;</tt><a name="(part._.Wait__nil__)"></a>Wait, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>??</h3><p>In order for our recursive type definitions to have a base case, we need to
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> to be some value that&rsquo;s compatible with any tuple
type.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._6._assignmentegg-eater%29%29" data-pltdoc="x">2</a></span></span><span class="FootnoteContent">An alternate design, of producing actual algebraic data types as ML
does, much more ambitious: it affects far more phases of the compiler than one
measly <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> value does...</span></span>  However, we now have to amend our tuple
operations above, to be sure they cannot cause a segmentation fault and access
undefined memory.  Accordingly:</p><ul><li><p>Represent <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> at runtime with a tuple-tagged value that is
obviously an invalid memory address.  The address <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x0</code></span> will do nicely,
since it&rsquo;s guaranteed not to be an address in our runtime-allocated heap.</p></li><li><p>Enhance the tuple-get and tuple-set expressions to reject accessing the
fields of <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>, and signal an error containing
<span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">"access component of nil"</code></span>.</p></li><li><p>Ensure that your <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">print</code></span> runtime function does not crash when given
data containing <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span>.</p></li></ul><h3>7<tt>&nbsp;</tt><a name="(part._.Recommended_.T.O.D.O_.List)"></a>Recommended TODO List</h3><ol><li><p>Implement the <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ETuple</code></span>, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EGetItem</code></span> and <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">ESetItem</code></span> cases in ANF.
These should be relatively similar in structure to the other arbitrary-arity
expression form, <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">EApp</code></span>...</p></li><li><p>Get tuple creation and access working for tuples containing two elements,
testing as you go.  This is very similar to the pairs code from lecture.</p></li><li><p>Modify the binary and unary operators to handle tuples appropriately (it may
be useful to skip <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> at first). Test as you go.</p></li><li><p>Make tuple creation and access work for tuples of any size.  Test as you go.</p></li><li><p>Tackle <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> for tuples if you haven&rsquo;t already.  Test as you go.
Reimplement <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> as a global function provided from C, rather than as a
built-in <span title="OCaml" class="sourceCode"><code data-lang="text/x-ocaml" class="sourceCode">prim1</code></span>.</p></li><li><p>Implement <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">input</code></span>, a C function that prompts the user for simple input
&#8212;<wbr></wbr> i.e., numbers or booleans; no need to write your own tuple parser in C!
&#8212;<wbr></wbr> and returns it to the running program.  Provide this function as a
globally-available function in Egg-eater.  For example, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print(input())</code></span>
should echo back whatever value the user entered.  You will need to give
this function an appropriate type, to interact with your type-checker.</p></li><li><p>Write some list library functions (at least the three above) to really
stress your tuple implementation.  Rejoice in your implementation of the
core features needed for nontrivial computation. (Well, aside from the pesky issue
of running out of memory.  More on that in lecture soon.)</p></li><li><p>Implement content-equality for all data (including tuples) as a runtime
function <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">equal</code></span>, and provide it as a globally-available function in Egg-eater.</p></li><li><p>Try implementing something more
ambitious than lists, like a binary search tree, in Egg-eater.  This last
point is ungraded, but quite rewarding!</p></li></ol><p>A note on support code &#8212;<wbr></wbr> a lot is provided, but you can feel free to overwrite
it with your own implementation, if you prefer.</p><h3>8<tt>&nbsp;</tt><a name="(part._.List_of_.Deliverables)"></a>List of Deliverables</h3><ul><li><p><span style="font-style: italic">all</span> your modified files (<code>compile.ml</code>, possibly <code>types.ml</code>
if you&rsquo;ve enhanced it, <code>pretty.ml</code> or anything else)</p></li><li><p>tests in an OUnit test module (<code>test.ml</code>)</p></li><li><p>any test input programs (<code>input/*/*.egg</code> files), including at least <code>lists.egg</code></p></li></ul><p><span style="font-weight: bold">Again, please ensure the makefile builds your code properly.
The black-box tests will give you an automatic 0 if they cannot compile your code!</span></p><p><span style="font-weight: bold">DO NOT SUBMIT YOUR <code>.git</code> DIRECTORY!</span>  For that matter, don&rsquo;t submit
your <code>output</code> or <code>_build</code> directories.</p><h3>9<tt>&nbsp;</tt><a name="(part._.Grading_.Standards)"></a>Grading Standards</h3><p><p>For this assignment, you will be graded on
</p><ul><li><p>Whether your code implements the specification (functional correctness),</p></li><li><p>the clarity and cleanliness of your code, and</p></li><li><p>the comprehensiveness of your test coverage</p></li></ul></p><h3>10<tt>&nbsp;</tt><a name="(part._.Submission)"></a>Submission</h3><p><p><span style="font-weight: bold">Wait!</span> Please read the assignment again and verify that you have not forgotten anything!</p></p><p>Please submit your homework to <a href="https://handins.ccs.neu.edu/"><span class="url">https://handins.ccs.neu.edu/</span></a> by the above deadline.</p><a name="(part._(gentag._4._assignmentegg-eater))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._5._assignmentegg-eater))"></a>1</span></span>We say
that of all the tuple types, there is no <span style="font-style: italic">most general unifier</span> that could
be used instead.</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._6._assignmentegg-eater))"></a>2</span></span>An alternate design, of producing actual algebraic data types as ML
does, much more ambitious: it affects far more phases of the compiler than one
measly <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">nil</code></span> value does...</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>