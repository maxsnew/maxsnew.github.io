<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Assignment 5: Egg-eater: Heap Allocation</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="rust.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="AssignmentNum">Assignment 5:</span> Egg-<wbr></wbr>eater:<span class="mywbr"> &nbsp;</span> Heap Allocation</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._.Language_and_.Requirements%29" class="tocviewlink" data-pltdoc="x">Language and Requirements</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Syntax_.Additions_and_.Semantics%29" class="tocviewlink" data-pltdoc="x">Syntax Additions and Semantics</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Semantics_and_.Representation_of_.Arrays%29" class="tocviewlink" data-pltdoc="x">Semantics and Representation of Arrays</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Recommended_.T.O.D.O_.List%29" class="tocviewlink" data-pltdoc="x">Recommended TODO List</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.List_of_.Deliverables%29" class="tocviewlink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td align="right">6&nbsp;</td><td><a href="#%28part._.Grading_.Standards%29" class="tocviewlink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td align="right">7&nbsp;</td><td><a href="#%28part._.Submission%29" class="tocviewlink" data-pltdoc="x">Submission</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="AssignmentNum">Assignment 5:</span> Egg-<wbr></wbr>eater:<span class="mywbr"> &nbsp;</span> Heap Allocation</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._.Language_and_.Requirements%29" class="tocsubseclink" data-pltdoc="x">Language and Requirements</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._.Syntax_.Additions_and_.Semantics%29" class="tocsubseclink" data-pltdoc="x">Syntax Additions and Semantics</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Semantics_and_.Representation_of_.Arrays%29" class="tocsubseclink" data-pltdoc="x">Semantics and Representation of Arrays</a></td></tr><tr><td><span class="tocsublinknumber">3.1<tt>&nbsp;</tt></span><a href="#%28part._.Array_.Heap_.Layout%29" class="tocsubseclink" data-pltdoc="x">Array Heap Layout</a></td></tr><tr><td><span class="tocsublinknumber">3.2<tt>&nbsp;</tt></span><a href="#%28part._.Accessing_.Array_.Contents%29" class="tocsubseclink" data-pltdoc="x">Accessing Array Contents</a></td></tr><tr><td><span class="tocsublinknumber">3.3<tt>&nbsp;</tt></span><a href="#%28part._.General_.Heap_.Layout%29" class="tocsubseclink" data-pltdoc="x">General Heap Layout</a></td></tr><tr><td><span class="tocsublinknumber">3.4<tt>&nbsp;</tt></span><a href="#%28part._.Interaction_with_.Existing_.Features%29" class="tocsubseclink" data-pltdoc="x">Interaction with Existing Features</a></td></tr><tr><td><span class="tocsublinknumber">3.5<tt>&nbsp;</tt></span><a href="#%28part._.Closures_and_.Recursive_.Function_.Definitions%29" class="tocsubseclink" data-pltdoc="x">Closures and Recursive Function Definitions</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.Recommended_.T.O.D.O_.List%29" class="tocsubseclink" data-pltdoc="x">Recommended TODO List</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.List_of_.Deliverables%29" class="tocsubseclink" data-pltdoc="x">List of Deliverables</a></td></tr><tr><td><span class="tocsublinknumber">6<tt>&nbsp;</tt></span><a href="#%28part._.Grading_.Standards%29" class="tocsubseclink" data-pltdoc="x">Grading Standards</a></td></tr><tr><td><span class="tocsublinknumber">7<tt>&nbsp;</tt></span><a href="#%28part._.Submission%29" class="tocsubseclink" data-pltdoc="x">Submission</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.8</span></div><h2><a name="(part._)"></a><span class="AssignmentNum">Assignment 5:</span> Egg-eater: Heap Allocation</h2><p><h4 class="due">Due: Fri 11/11 at 5pm</h4>
<p class="git-clone"><code><span class="kw">git clone </span><input onclick="this.select();" readonly="readonly" value="https://gitlab.eecs.umich.edu/483-fa22/starter-code/egg-eater"/></code></p></p><p><span class="emph">In this assignment you&rsquo;ll extend to implement arrays and closures,
which are sort like eggs lain in the heap, if you don&rsquo;t think about it too much...</span></p><h3>1<tt>&nbsp;</tt><a name="(part._.Language_and_.Requirements)"></a>Language and Requirements</h3><p>Egg-eater starts with the same semantics as Diamondback, and adds
support for heap-allocated values: arrays and closures. The features
are:</p><p><ul><li><p>array expressions: creating values, accessing components, and mutating components</p></li><li><p>sequencing of expressions with <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">e1; e2</code></span></p></li><li><p>closures: functions can be used as first-class values</p></li><li><p>lambda: non-recursive function values can constructed using lambda notation <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">lambda x,...: e end</code></span></p></li></ul><p>The runtime system must add support for
</p><ul><li><p>Allocating array and closure values on the heap</p></li><li><p>Printing array and closure values</p></li><li><p>Comparing values for structural equality</p></li></ul></p><p>Read through the whole assignment below carefully, then take note of
the recommended TODO list at the bottom for a suggested order to
tackle these pieces.</p><h3>2<tt>&nbsp;</tt><a name="(part._.Syntax_.Additions_and_.Semantics)"></a>Syntax Additions and Semantics</h3><p>Egg-eater adds two new kinds of heap-allocated values: <span class="emph">arrays</span> and <span class="emph">closures</span>.</p><p>For arrays, the new syntactic forms are <span class="emph">array expressions</span>,
along with accessor expressions for getting or setting the contents of
arrays, a unary primitive for checking if a value is an array, and a
unary primitive for getting the length of an array.  Array expressions
are a series of <span class="emph">zero or more</span> comma-separated expressions
enclosed in (square) brackets.  An array access expression is one
expression followed by another enclosed in square brakcets, which
expresses which field to be accessed.  <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">isarray</code></span> is a
primitive (like <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">isnum</code></span> and <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">isbool</code></span>) that checks
if a value is an array. Finally, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">length</code></span> is a primitive
that produces the length of an array.</p><p>For closures we change add a new syntactic forms <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">lambda
x1,...: e end</code></span> for anonymous function values, a unary primitive
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">isfun</code></span> for checking if a value is a function and we now
allow for the function position in a call expression to be an
arbitrary value, not just an identifier.</p><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._(bnf-prod._(.Eggeater._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._array%29%29%29" data-pltdoc="x">&#8249;array&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">[</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">]</span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">[</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">]</span> <span class="bnf-lit">:=</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">;</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">isarray</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">length</span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">(</span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">(</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span> <span class="bnf-lit">)</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">lambda</span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">end</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">lambda</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._params%29%29%29" data-pltdoc="x">&#8249;params&#8250;</a></span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">end</span>
<a name="(elem._(bnf-prod._(.Eggeater._params)))"></a><span class="bnf-rule">&#8249;params&#8250;</span><span class="bnf-meta">:</span> 
              <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span>
              <span class="bnf-meta"> | </span><span class="bnf-lit bnf-unknown">IDENTIFIER</span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._params%29%29%29" data-pltdoc="x">&#8249;params&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Eggeater._exprs)))"></a><span class="bnf-rule">&#8249;exprs&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span>
            <span class="bnf-meta"> | </span><span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">,</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span>
<a name="(elem._(bnf-prod._(.Eggeater._array)))"></a><span class="bnf-rule">&#8249;array&#8250;</span><span class="bnf-meta">:</span> 
            <span class="bnf-meta"> | </span><span class="bnf-lit">[</span> <span class="bnf-lit">]</span>
            <span class="bnf-meta"> | </span><span class="bnf-lit">[</span> <span class=""><a href="#%28elem._%28bnf-prod._%28.Eggeater._exprs%29%29%29" data-pltdoc="x">&#8249;exprs&#8250;</a></span> <span class="bnf-lit">]</span></p></blockquote><p>For example, we can create three arrays and access their fields:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let unit = [] in
let one = [1] in
let three = [3, 4, 5] in
three[0]</code></pre></div></div></p><p>An array-set expression evaluates both arguments, updates the array at the
appropriate index, and returns the entire tuple value as its result. We can
therefore chain array-set expressions together, and write</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let three = [0, 0, 0] in
((three[0] := 1)[1]  := 2)[2] := 3

let pair = [0, 0] in
pair[0] := (three[1] := 10)</code></pre></div></div>
After running this, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">three</code></span> will be <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">[1,10,3]</code></span> and <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">pair</code></span> will be <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">[three, 0]</code></span></p><p>In the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Exp</code></span> datatype, these are represented as:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">enum Exp&lt;Ann&gt; {
  ...
    Array(Vec&lt;Exp&lt;Ann&gt;&gt;, Ann),
    ArraySet {
        array: Box&lt;Exp&lt;Ann&gt;&gt;,
        index: Box&lt;Exp&lt;Ann&gt;&gt;,
        new_value: Box&lt;Exp&lt;Ann&gt;&gt;,
        ann: Ann,
    },

    Semicolon {
        e1: Box&lt;Exp&lt;Ann&gt;&gt;,
        e2: Box&lt;Exp&lt;Ann&gt;&gt;,
        ann: Ann,
    },
    Call(Box&lt;Exp&lt;Ann&gt;&gt;, Vec&lt;Exp&lt;Ann&gt;&gt;, Ann),
    Lambda {
        parameters: Vec&lt;String&gt;,
        body: Box&lt;Exp&lt;Ann&gt;&gt;,
        ann: Ann
    }
    MakeClosure {
        arity: usize,
        label: String,
        env:   Box&lt;Exp&lt;Ann&gt;&gt;,
        ann:   Ann
    }
}
enum Prim1 {
  ...
    IsArray,
    IsFun,
    Length,
}
enum Prim2 {
  ...
  ArrayGet,
}</code></pre></div></div></p><p>This includes an additional form which is purely internal to the
compiler: <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">MakeClosure</code></span>, which constructs a closure given an
arity, the name of the label and an expression constructing the
captured environment. We will desugar our <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Lambda</code></span> and
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">FunDecls</code></span> forms to use this.</p><p>In Sequential form, these expressions are represented as
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">SeqExp</code></span>s, with <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">ImmExp</code></span> components, and additionally we
rename the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Call</code></span> to <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">CallClosure</code></span> to emphasize that this is
a combination of unpacking the closure with our previous notion of
function call:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">enum SeqExp&lt;Ann&gt; {
  ...
    AssertSize(ImmExp, usize, Ann),
    Array(Vec&lt;ImmExp&gt;, Ann),
    ArraySet {
        array: ImmExp,
        index: ImmExp,
        new_value: ImmExp,
        ann: Ann,
    },
    MakeClosure {
        arity: usize,
        label: String,
        env: ImmExp,
        ann: Ann,
    },
    CallClosure {
        fun: ImmExp,
        args: Vec&lt;ImmExp&gt;,
        ann: Ann,
    },
}</code></pre></div></div></p><p>Note that these expressions are all <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">SeqExp</code></span>s, and not
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">ImmExp</code></span>s &ndash; the allocation of an array or closure counts as a
&ldquo;step&rdquo; of execution, and so they are not themselves already values.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Semantics_and_.Representation_of_.Arrays)"></a>Semantics and Representation of Arrays</h3><h4>3.1<tt>&nbsp;</tt><a name="(part._.Array_.Heap_.Layout)"></a>Array Heap Layout</h4><p>Array expressions should evaluate their sub-expressions in order from left to
right, and store the resulting values on the heap.  We discussed several
possible representations in class for laying out arrays on the heap; the one
we recommend you use for this assignment is:</p><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict.png" alt="image" width="506.0" height="60.1328125"/></p><p>That is, one word is used to store the <span class="emph">count</span> of the number of elements in the
array, and the subsequent words are used to store the values themselves.  Note
that the count is an actual integer; it is not an encoded Egg-eater integer value.</p><p>An <span class="emph">array value</span> is stored in variables as the address of the
first word in the array&rsquo;s memory, but with an additional <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">1</code></span> added to the value
to act as a tag.  So, for example, if the start address of the above memory
were <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x0adadad0</code></span>, the array value would be <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x0adadad1</code></span>.  With this change, we
extend the set of tag bits to the following:</p><ul><li><p>Numbers: <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0</code></span> in the least significant bit</p></li><li><p>Booleans: <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">111</code></span> in the three least significant bits</p></li><li><p>Arrays: <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">001</code></span> in the three least significant bits</p></li><li><p>Closures: <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">011</code></span> in the three least significant bits</p></li></ul><p>Visualized differently, the value layout is:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Bit pattern</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Value type</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0xWWWWWWW[bbb0]</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>Number</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0xFFFFFFF[1111]</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>True</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0x7FFFFFF[1111]</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>False</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0xWWWWWWW[b001]</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>Array</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0xWWWWWWW[b011]</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>Closure</p></td></tr></table></p><p>Where <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">W</code></span> is a &ldquo;wildcard&rdquo; 16-bit nibble and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">b</code></span> is a &ldquo;wildcard&rdquo; bit.</p><h4>3.2<tt>&nbsp;</tt><a name="(part._.Accessing_.Array_.Contents)"></a>Accessing Array Contents</h4><p>In an <span class="emph">array access</span> expression, like</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let t = [6, 7, 8, 9] in t[1]</code></pre></div></div></p><p>The behavior should be:</p><ol><li><p>Evaluate the expression in array position (before the brackets), then the
index expression (the one inside the brackets).</p></li><li><p>Check that the array position&rsquo;s value is actually an array, and signal an
error containing <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">"indexed into non-array"</code></span> if not.</p></li><li><p>Check that the indexing expression is a number. Signal an error containing <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">"index not a number"</code></span> if not.</p></li><li><p>Check that the index number is a valid index for the array value &#8212;<wbr></wbr> that
is, it is between <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">0</code></span> and the stored number of elements in the array minus
one.  Signal an error containing <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">"index out of bounds"</code></span></p></li><li><p>Evaluate to the array element at the specified index.</p></li></ol><p>These same error messages apply also to setting the value of an
array. Additionally, if at runtime, <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">length</code></span> is performed on
a non array value, the error message should include <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">"length
called with non-array"</code></span> analogous to similar previous error messages.</p><p>You <span class="emph">can</span> do this with just <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">rax</code></span>, but it causes some
pain. Feel free to use as scratch registers <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">r13</code></span> and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">r14</code></span> as
needed (for example saving the index in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">r14</code></span> and using <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">rax</code></span>
to store the address of the tuple).  This can save a number of
instructions.  Note that we will generate code that doesn&rsquo;t need to
use <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">r13</code></span> or <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">r14</code></span> beyond the extent of this one expression,
so there is no need to worry about saving or restoring the old value
from <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">r14</code></span> except in the compilation of the main expression.</p><p>You also may want to use an extended syntax for <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov</code></span> in order to combine these
values for lookup.  For example, this kind of arithmetic is allowed inside
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov</code></span> instructions:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov rax, [rax + r14 * 8 + 8]</code></pre></div></div></p><p>This would access the memory at the location of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">rax</code></span>, offset by
the value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">r14 * 8 + 8</code></span>.  So if the value in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">r14</code></span> were,
say <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">2</code></span>, this may be part of a scheme for accessing the second
element of a tuple. To aid in this we have generalized the
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">MemRef</code></span> type to allow for these dynamically computed offsets:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">struct MemRef {
    reg: Reg,
    offset: Offset,
}

enum Offset {
    Constant(i32),
    Computed { // reg * factor + constant
        reg: Reg,
        factor: i32,
        constant: i32,
    },
}</code></pre></div></div></p><p>Neither <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R14</code></span> nor anything beyond the typical
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Offset::Constant</code></span> is <span class="emph">required</span> to make this work, but you
may find it simpler to compile using these.</p><h4>3.3<tt>&nbsp;</tt><a name="(part._.General_.Heap_.Layout)"></a>General Heap Layout</h4><p>The register <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">r15</code></span> has been designated as the heap pointer (note
that if you are using <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> for a work register you should either
change that or use a different register for the heap pointer). To
initialize the heap you should either use the technique from
<a href="lec_tuples_notes.html" data-pltdoc="x"><span class="LectureNum">Lecture 10:</span> Tuples and Memory Allocation</a> where we construct an array in Rust and pass it in as
an argument to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">start_here</code></span> or you can construct an array in the
data section of your assembly file. For instance if you start the file with</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">section .data
HEAP:    times 1024 dq 0</code></pre></div></div></p><p>Then the label <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">HEAP</code></span> will be resolved to an address pointing to
an array of 1024 QWORD values initialized to all 0. This is 8
kilobytes which should be enough to pass the autograder tests.</p><p>Whichever approach you take, it is up to your code to initialize the
heap pointer <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> to point to the beginning of this space and
ensure that the value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> is always the address of the next
block of free space (in increasing address order) in the provided
block of memory.</p><h4>3.4<tt>&nbsp;</tt><a name="(part._.Interaction_with_.Existing_.Features)"></a>Interaction with Existing Features</h4><p>Any time we add a new feature to a language, we need to consider its
interactions with all the existing features.</p><p>We&rsquo;ll take them one at a time.</p><ul><li><p><span style="font-weight: bold">Equality</span>:  The arithmetic expressions should
continue to only allow numbers, and signal errors on tuple values.  There is
one binary operator that doesn&rsquo;t check its types, however: <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">==</code></span>.  We need to
decide what the behavior of <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">==</code></span> is on tuple values and closure values.  Note that we have a
(rather important) choice here.  Clearly, this program should evaluate to
<span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">true</code></span>:</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let t = [4, 5] in t == t</code></pre></div></div></p><p>However, we need to decide if</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">[4,5] == [4,5]</code></pre></div></div></p><p>should evaluate to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">true</code></span> or <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">false</code></span>. For this assignment we
will consider these arguments to be <span class="emph">not equal</span> because they
are not implemented as the same value on the heap, so if one was
mutated, the other would not be. That is, we will use <span class="emph">pointer
equality</span> rather than <span class="emph">structural equality</span>.</p><p>We will similarly consider two closures to be equal only when they
are the same underlying pointer in memory.</p></li><li><p><span style="font-weight: bold">Print</span>: The behavior of the unary operators is
straightforward, with the exception that we need to implement <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span> for
tuples and closures.</p><p>Closures should really be opaque values that you can only interact
with by calling, so we will simply print <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">"&lt;closure&gt;"</code></span> when we
encounter one.</p><p>For arrays, we could just print the address, but that would be
somewhat unsatisfying. Instead, we should recursively print the
tuple contents, so that the program</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print([4, [true, 3]])</code></pre></div></div></p><p>actually prints the string <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">"[4, [true, 3]]"</code></span>.  This will require some
additional work with pointers in <code>stub.rs</code>.  A useful hint is to create a
recursive helper function for <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">sprint_snake_val</code></span> that traverses the nested structure
of tuples and prints single values.
To help you working with raw bytes in Rust, we have provided a
function <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">load_snake_array</code></span> that takes a pointer to an array in
the heap and "parses" it into a struct consisting of a size and a
pointer to the first element of the array. You can then access the
other elements of the array by using the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">.add(n)</code></span> method on
pointers. You will need to use <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">unsafe</code></span> code to implement this,
of course.</p><p>The interesting case is when there is a cyclic heap value. For instance the following program</p><p><div class="sourceCodeWrapper"><span data-label="Egg-eater" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let pair = [ 0 , 1 ] in
pair[1] := pair;
pair</code></pre></div></div></p><p>creates a cyclic linked list in memory, and naively traversing it
would cause an infinite recursion. A small number of test cases will
check for correctly implementing printing of cyclic values like
this, so you should likely put a bound on your initial print
function or the autograder might take very long to run.</p><p>In the presence of a cyclic value you should print <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">"&lt;loop&gt;"</code></span>
where the first loop occurs. For instance the above cyclic list
should be printed as <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">"[0, &lt;loop&gt;]"</code></span>.</p></li></ul><h4>3.5<tt>&nbsp;</tt><a name="(part._.Closures_and_.Recursive_.Function_.Definitions)"></a>Closures and Recursive Function Definitions</h4><p>First, we need to consider how static and dynamic error messages are
affected by making functions first-class values.</p><ul><li><p>We no longer need a separate <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">UndefinedFunction</code></span> error, as
functions will be in the same namespace as other values and so we will
just use the general <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">UnboundVariable</code></span> error.</p></li><li><p>We no longer need a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">FunctionUsedAsValue</code></span> error, as
functions can be used as values!</p></li><li><p>We will also no longer have a <span class="emph">static</span>
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">ValueUsedAsFunction</code></span> error, but we need instead to have a
dynamic error when a number, boolean or array is used as the function
in a call. In this case, your code should error with a message that
includes the string "called a non-function".</p></li><li><p>Similarly, we will no longer have a <span class="emph">static</span>
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">FunctionCalledWrongArity</code></span> message, as this check will be delayed
to runtime. When a function is called with the wrong number of
arguments at runtime, your code should raise an error which includes
the string "wrong number of arguments".</p></li></ul><p>To implement closures, we will adapt our lambda lifting phase to
desugar the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Lambda</code></span> and <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">FunDefs</code></span> forms to explicit closure
construction <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">MakeClosure</code></span>. This is not as big of a change as it
might at first appear: your lambda lifting code is already determining
what the captured environment is, but now instead of adding all of
those variables as extra arguments individually, we will put them into
an array and pass that as a single extra argument, and produce a
closure value. Note that unlike in diamondback, lambda lifting no
longer has to change the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Call</code></span> instructions to pass additional
variables, as the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">Call</code></span> instruction will instead be compiled to
pass the environment that is stored in the closure.
See <a href="lec_lambdas_notes.html" data-pltdoc="x"><span class="LectureNum">Lecture 12:</span> First-class Functions</a> for more details on the code generation.</p><p>As discussed in class, recursive function definitions can be handled
in several different ways:</p><ul><li><p>You can construct a single environment and make closures with all of the different variables</p></li><li><p>You can use Landin&rsquo;s knot to desugar the recursion into a sequence of let-bindings of lambdas, where you store the functions in a mutable array</p></li></ul><p>Note: While all of the methods presented in class will work in the
presence of a garbage collector, since we do not have one for our
language, some of the implementations (the one presented in class on
10/24 and the Y combinator) will eventually consume arbitrary
memory. So please use either Landin&rsquo;s knot as presented in class on
10/26 or see the corrected version of the technique shown in 10/24 in
the updated notes <a href="lec_lambdas_notes.html" data-pltdoc="x"><span class="LectureNum">Lecture 12:</span> First-class Functions</a>.</p><p>Any of these will work, and you are free to choose what you are most
comfortable with implementing. The first is the most straightforward
to fit in the existing pipeline, while the latter two would probably
benefit from being implemented by a new desugaring pass. The benefit
of the latter two approaches is that if you get the desugaring
correct, then you can then rely on your correct implementation of
lambdas and arrays to ensure the mutually recursive functions are
implemented correctly.</p><h3>4<tt>&nbsp;</tt><a name="(part._.Recommended_.T.O.D.O_.List)"></a>Recommended TODO List</h3><ol><li><p>Try implementing an interesting test cases using lists, binary
trees or another interesting recursive datatypes in Egg-eater. Include one of
these examples as <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">interesting.egg</code></span> in the
<code>examples/</code> directory.</p></li><li><p>Add your existing code, adding <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">panic!</code></span> for the new cases (arrays, lambda) and
changed cases (function calls).</p></li><li><p>Write tests for the array features.</p></li><li><p>Extend <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">check_prog</code></span> to handle arrays, and adapt it to
correctly handle the changed error messages relating to functions.</p></li><li><p>Extend your passes (<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">uniquify, lambda_lift,sequentialize</code></span>) to support arrays.</p></li><li><p>Implement code generation for arrays. </p></li><li><p>Implement printing arrays in Rust.</p></li><li><p>Write tests for closures/lambdas.</p></li><li><p>Extend <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">lambda_lift</code></span> to translate <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">lambda</code></span>s to uses of <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">make_closure</code></span>.</p></li><li><p>Implement code generation for <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">make_closure</code></span> and <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">call_closure</code></span>.</p></li><li><p>Extend your implementation to handle recursive closures. We
discussed several methods for this in class (directly, Landin&rsquo;s knot and
the Y combinator) and you are free to use whichever you wish.</p></li></ol><h3>5<tt>&nbsp;</tt><a name="(part._.List_of_.Deliverables)"></a>List of Deliverables</h3><ul><li><p>your <code>compile.rs</code></p></li><li><p>the other src/*.rs files in the starter code</p></li><li><p>any additional modules you saw fit to write</p></li><li><p>your <code>runtime/stub.rs</code></p></li><li><p>the Cargo.toml</p></li><li><p>integration tests (<code>tests/examples.rs</code>)</p></li><li><p>your test input programs (<code>examples/*.egg</code> files), specifically at least one <code>examples/interesting.egg</code></p></li></ul><p><span style="font-weight: bold">Again, please ensure <code>cargo</code> builds your code properly.
The autograder will give you an automatic 0 if they cannot compile your code!</span></p><h3>6<tt>&nbsp;</tt><a name="(part._.Grading_.Standards)"></a>Grading Standards</h3><p><p>For this assignment, you will be graded on
</p><ul><li><p>Whether your code implements the specification (functional correctness),</p></li><li><p>Whether you include an interesting <span title="Egg-eater" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">interesting.egg</code></span>. We&rsquo;ll have a low bar for interestingness
but try to have fun with it!</p></li></ul></p><h3>7<tt>&nbsp;</tt><a name="(part._.Submission)"></a>Submission</h3><p><p><span style="font-weight: bold">Wait!</span> Please read the assignment again and verify that you have not forgotten anything!</p></p><p>Please submit your homework to gradescope by the above deadline.</p><a name="(part._(gentag._2._assignmentegg-eater))"></a><p class="FootnoteBlock"></p></div></div><div id="contextindicator">&nbsp;</div></body></html>