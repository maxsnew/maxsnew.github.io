<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 6: Conditionals Part 1: Branching and Logical Operations</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="rust.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 6:</span> Conditionals Part 1:<span class="mywbr"> &nbsp;</span> Branching and Logical Operations</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._if._.Growing_the_language__adding_conditionals_and_logical_operations%29" class="tocviewlink" data-pltdoc="x">Growing the language:<span class="mywbr"> &nbsp;</span> adding conditionals and logical operations</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._.Conditional_.Control_.Flow_in_.Assembly%29" class="tocviewlink" data-pltdoc="x">Conditional Control Flow in Assembly</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Intermediate_representation_for_conditionals%29" class="tocviewlink" data-pltdoc="x">Intermediate representation for conditionals</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.Join_.Points%29" class="tocviewlink" data-pltdoc="x">Join Points</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 6:</span> Conditionals Part 1:<span class="mywbr"> &nbsp;</span> Branching and Logical Operations</a></td></tr><tr><td><span class="tocsublinknumber">1<span class="stt">&nbsp;</span></span><a href="#%28part._if._.Growing_the_language__adding_conditionals_and_logical_operations%29" class="tocsubseclink" data-pltdoc="x">Growing the language:<span class="mywbr"> &nbsp;</span> adding conditionals and logical operations</a></td></tr><tr><td><span class="tocsublinknumber">1.1<span class="stt">&nbsp;</span></span><a href="#%28part._if._.The_new_concrete_syntax%29" class="tocsubseclink" data-pltdoc="x">The new concrete syntax</a></td></tr><tr><td><span class="tocsublinknumber">1.2<span class="stt">&nbsp;</span></span><a href="#%28part._if._.Examples_and_semantics%29" class="tocsubseclink" data-pltdoc="x">Examples and semantics</a></td></tr><tr><td><span class="tocsublinknumber">1.3<span class="stt">&nbsp;</span></span><a href="#%28part._if._.The_new_abstract_syntax%29" class="tocsubseclink" data-pltdoc="x">The new abstract syntax</a></td></tr><tr><td><span class="tocsublinknumber">2<span class="stt">&nbsp;</span></span><a href="#%28part._.Conditional_.Control_.Flow_in_.Assembly%29" class="tocsubseclink" data-pltdoc="x">Conditional Control Flow in Assembly</a></td></tr><tr><td><span class="tocsublinknumber">2.1<span class="stt">&nbsp;</span></span><a href="#%28part._.Comparisons_and_jumps%29" class="tocsubseclink" data-pltdoc="x">Comparisons and jumps</a></td></tr><tr><td><span class="tocsublinknumber">3<span class="stt">&nbsp;</span></span><a href="#%28part._.Intermediate_representation_for_conditionals%29" class="tocsubseclink" data-pltdoc="x">Intermediate representation for conditionals</a></td></tr><tr><td><span class="tocsublinknumber">3.1<span class="stt">&nbsp;</span></span><a href="#%28part._.From__sub-_blocks_to_x86%29" class="tocsubseclink" data-pltdoc="x">From (sub-<wbr></wbr>)blocks to x86</a></td></tr><tr><td><span class="tocsublinknumber">3.2<span class="stt">&nbsp;</span></span><a href="#%28part._.From_.If_to_.Branching%29" class="tocsubseclink" data-pltdoc="x">From If to Branching</a></td></tr><tr><td><span class="tocsublinknumber">4<span class="stt">&nbsp;</span></span><a href="#%28part._.Join_.Points%29" class="tocsubseclink" data-pltdoc="x">Join Points</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.18</span></div><section class="SsectionLevel1" id="section 0"><h1 class="heading"><a name="(part._)"></a><span class="LectureNum">Lecture 6:</span> Conditionals Part 1: Branching and Logical Operations<span class="button-group"><a href="#(part._)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h1><p>Our compiler so far can handle basic arithmetic operations on numbers
as well as handle let-bound identifiers. This is completely
<span class="emph">straight-line code</span>; there are no decisions to make that would affect
code execution. We need to support <span class="emph">conditionals</span> to incorporate
such choices.</p><section class="SsectionLevel2" id="section 1"><h2 class="heading">1<span class="stt">&nbsp;</span><a name="(part._if._.Growing_the_language__adding_conditionals_and_logical_operations)"></a>Growing the language: adding conditionals and logical operations<span class="button-group"><a href="#(part._if._.Growing_the_language__adding_conditionals_and_logical_operations)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h2><p><p>Reminder: Every time we enhance our source language, we need to consider several things:
</p><ol><li><p>Its impact on the <span class="emph">concrete syntax</span> of the language</p></li><li><p>Examples using the new enhancements, so we build intuition of them</p></li><li><p>Its impact on the <span class="emph">abstract syntax</span> and <span class="emph">semantics</span> of the language</p></li><li><p>Any needed changes to our <span class="emph">intermediate representation</span></p></li><li><p>Any new or changed <span class="emph">transformations</span> needed to process the new forms</p></li><li><p>Executable <span class="emph">tests</span> to confirm the enhancement works as intended</p></li></ol></p><section class="SsectionLevel3" id="section 1.1"><h3 class="heading">1.1<span class="stt">&nbsp;</span><a name="(part._if._.The_new_concrete_syntax)"></a>The new concrete syntax<span class="button-group"><a href="#(part._if._.The_new_concrete_syntax)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><blockquote class="SCodeFlow" style="white-space: pre;"><p><a name="(elem._if._(bnf-prod._(if._expr)))"></a><span class="bnf-rule">&#8249;expr&#8250;</span><span class="bnf-meta">:</span> <span class="bnf-lit bnf-unknown">...</span>
          <span class="bnf-meta"> | </span><span class="bnf-lit">if</span> <span class=""><a href="#%28elem._if._%28bnf-prod._%28if._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">:</span> <span class=""><a href="#%28elem._if._%28bnf-prod._%28if._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span> <span class="bnf-lit">else:</span> <span class=""><a href="#%28elem._if._%28bnf-prod._%28if._expr%29%29%29" data-pltdoc="x">&#8249;expr&#8250;</a></span></p></blockquote></section><section class="SsectionLevel3" id="section 1.2"><h3 class="heading">1.2<span class="stt">&nbsp;</span><a name="(part._if._.Examples_and_semantics)"></a>Examples and semantics<span class="button-group"><a href="#(part._if._.Examples_and_semantics)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>Currently our language includes only integers as its values.  We&rsquo;ll therefore
define conditionals to match C&rsquo;s behavior: if the condition evaluates to a
nonzero value, the then-branch will execute, and if the condition evaluates to
zero, the else-branch will execute.  It is never the case that both branches
should execute.</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Concrete Syntax</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Answer</p></td></tr><tr><td><p><span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if 5: 6 else: 7</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>6</code></p></td></tr><tr><td><p><span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if 0: 6 else: 7</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>7</code></p></td></tr><tr><td><p><span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if sub1(1): 6 else: 7</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><code>7</code></p></td></tr></table></p><p>Unlike C, but as in Rust, if-expressions are indeed
<span class="emph">expressions</span>: they evaluate to a value, which means they can be
composed freely with the other expression forms in our language. For
instance we can form complex expressions with an <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> as a
sub-expression such as</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">(if x: 6 else: 8) + (if y: x else: 3)</code></pre></div></div></p><p>This makes our if expression analogous to C&rsquo;s "ternary conditional
operator", in C the first example would be written as <span title="C/C++" class="sourceCode"><code data-lang="text/x-csrc" class="sourceCode">5 ? 6: 1</code></span>. In
Rust, <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">if (5 != 0) { 6 } else { 7 }</code></span>. Since our <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> is an
expression, we always include an <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">else</code></span> branch.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Construct larger examples, combining if-expressions with each other
or with let-bindings, and show their evaluation.</p></blockquote></section><section class="SsectionLevel3" id="section 1.3"><h3 class="heading">1.3<span class="stt">&nbsp;</span><a name="(part._if._.The_new_abstract_syntax)"></a>The new abstract syntax<span class="button-group"><a href="#(part._if._.The_new_abstract_syntax)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">enum Exp {
  ...
  If { cond: Box&lt;Exp&gt;, thn: Box&lt;Exp&gt;, els: Box&lt;Exp&gt; }
}</code></pre></div></div></p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Extend your interpreter from the prior lecture to include
conditionals.  As with last lecture, suppose we added a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">print</code></span> expression
to the language &#8212;<wbr></wbr> what care must be taken to get the correct semantics?</p></blockquote><p>We should ensure that our programs only evaluate one side of an
<span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> expression. But how would we test this? We need to have a
test where we can tell whether some code has executed or not. This
would work if we had <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span>ing or say infinite loops.</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if x:
  print(1)
else:
  print(0)</code></pre></div></div></p><p>or</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">let x = 1 in
if x:
  7
else:
  infinite-loop</code></pre></div></div></p><p>There&rsquo;s something a bit unsatisfying about interpreting <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> in our
language by using <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">if</code></span> in Rust: it feels like a coincidence that our
semantics and Rusts&rsquo;s semantics agree, and it doesn&rsquo;t convey much understanding
of how conditionals like <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> actually work...</p><p>Scope</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def main(x):
if 0:
  y
else:
  x</code></pre></div></div></p></section></section><section class="SsectionLevel2" id="section 2"><h2 class="heading">2<span class="stt">&nbsp;</span><a name="(part._.Conditional_.Control_.Flow_in_.Assembly)"></a>Conditional Control Flow in Assembly<span class="button-group"><a href="#(part._.Conditional_.Control_.Flow_in_.Assembly)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h2><section class="SsectionLevel3" id="section 2.1"><h3 class="heading">2.1<span class="stt">&nbsp;</span><a name="(part._.Comparisons_and_jumps)"></a>Comparisons and jumps<span class="button-group"><a href="#(part._.Comparisons_and_jumps)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>To understand how to compile conditionals, we first need to understand
how we can implement conditional execution in x86. So far, x86
execution has always gone sequentially from one instruction to the
next. Concretely, in x86 what instruction to run is determined by a
special register called the <span class="emph">instruction pointer</span>, whose name is,
somewhat morbidly, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span>. <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span> stores a 64-bit value like the
general purpose registers, but that&rsquo;s where the similarities end. The
value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span> is interpreted as an address, and at each step of
execution, the x86 abstract machine interprets the memory at <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span>
as the binary encoding of the instruction to execute. Then most of the
instructions we&rsquo;ve used so far implicitly increment <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span> so that
after executing the instruction, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span> then points to the
<span class="emph">next</span> instruction in memory. This is what produces the
sequential behavior we have seen so far.</p><p>TODO: show some assembly code in memory</p><p>There are several instructions in x86 that manipulate <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span> in
more interesting ways. The first is the "jump" instruction <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jmp
addr</code></span>, which simply sets <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span> to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">addr</code></span> directly. <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">addr</code></span>
here could be a register or a <span class="emph">label</span>, an x86 abstraction of an
address that will be determined by the assembler. We&rsquo;ve seen only one
label so far, namely <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">our_code_starts_here</code></span>, but we can freely add
more labels to our program to indicate targets of jumps.</p><p>To compile conditionals, we want something a little more complicated:
we want to be able to <span class="emph">choose</span> based on some dynamically
determined information whether to set <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span> to the address for the
start of the <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">then</code></span> branch or the start of the <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">else</code></span>
branch. x86 has a large group of instructions that do just that, which
are called <span class="emph">conditional jump</span> instructions which are of the form
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jcc loc</code></span> where <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cc</code></span> is one of many different condition codes
that say what condition to check, and the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">loc</code></span> is a memory
address. The behavior of a conditional jump is that if the condition
code is satisfied, the instruction pointer is set to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">loc</code></span>, and
otherwise, the instruction pointer is incremented and the sequentially
next instruction in memory is executed, as with a typical expression.</p><p>The condition codes themselves are interpeted by yet another special
register, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RFLAGS</code></span>. This register consists of many single-bit
flags such as SF (sign flag), OF (overflow flag), ZF (zero flag), etc.
Like <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span>, most x86 instructions implicitly manipulate these
flags. For instance, the zero flag <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">ZF</code></span> is set to 1 if the result
of an arithmetic operation is 0 and 1 otherwise, the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">SF</code></span> is set
to 1 if the result of the operation is negative and 0 otherwise and
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">OF</code></span> is set to 1 if the arithmetic operation overflowed and 0
otherwise. The various condition codes then each check for some
specific combination of flag settings. For instance, the condition
code <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">z</code></span> checks for if the zero flag is set.</p><p>Other conditions are more complex. For instance, the condition code
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">l</code></span> for "less than" means that the overflow flag is set <span class="emph">xor</span>
the sign flag is set. This results in the correct condition for <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">x
&lt; y</code></span> if the flags have been set as in the instruction <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sub x, y</code></span>.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Why is <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">x &lt; y</code></span> if and only if <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">x - y</code></span> is negative xor overflows?</p></blockquote><p>The most common way to set the condition codes is with the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp
arg1, arg2</code></span> instruction, which sets the flags in the same way as a
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sub</code></span> operation, but without changing the value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">arg1</code></span>. The following conditional jumps make the most sense after executing such a <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span>:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Instruction</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Jump if ...</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">je </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the two compared values are equal</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jne</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the two compared values are not equal</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jl </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is less than the second</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jle</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is less than or equal to the second</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jg </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is greater than the second</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jge</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is greater than or equal to the second</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jb </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is less than the second, when treated as unsigned</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jbe</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the first value is less than or equal to the second, when treated as unsigned</p></td></tr></table></p><p>Some conditional jumps instead make more sense directly after an arithmetic operation:</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Instruction</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Jump if ...</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jz </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the last arithmetic result is zero</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jnz</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the last arithmetic result is non-zero</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jo </code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the last arithmetic result overflowed</p></td></tr><tr><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jno</code></span> LABEL</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p>... the last arithmetic result did not overflow</p></td></tr></table></p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Consider the examples of if-expressions above.  Translate them
manually to assembly.</p></blockquote><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def main(x):
  if sub1(x):
    6
  else:
    7</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">entry:
  mov rax, rdi
  sub rax, 1
  cmp rax, 0
  jne thn
els:
  mov rax, 7
  ret
thn:
  mov rax, 6
  ret</code></pre></div></div></p><p><p>Let&rsquo;s examine the last example above:
<span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">~hl:2:s~if ~hl:1:s~sub1(1)~hl:1:e~: ~hl:3:s~6~hl:3:e~ else: ~hl:4:s~7~hl:4:e~~hl:2:e~</code></span>.
Which of the following could be valid translations of this expression?
</p><table cellspacing="0" cellpadding="0" class="centered"><tr><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:1:s~mov RAX, 1
  sub1 RAX~hl:1:e~
  ~hl:2:s~cmp RAX, 0
  je if_false
if_true:
  ~hl:3:s~mov RAX, 6~hl:3:e~
  jmp done
if_false:
  ~hl:4:s~mov RAX, 7~hl:4:e~
done:~hl:2:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:1:s~mov RAX, 1
  sub1 RAX~hl:1:e~
  ~hl:2:s~cmp RAX, 0
  je if_false
if_true:
  ~hl:3:s~mov RAX, 6~hl:3:e~

if_false:
  ~hl:4:s~mov RAX, 7~hl:4:e~
done:~hl:2:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:1:s~mov RAX, 1
  sub1 RAX~hl:1:e~
  ~hl:2:s~cmp RAX, 0
  jne if_true
if_true:
  ~hl:3:s~mov RAX, 6~hl:3:e~
  jmp done
if_false:
  ~hl:4:s~mov RAX, 7~hl:4:e~
done:~hl:2:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:1:s~mov RAX, 1
  sub1 RAX~hl:1:e~
  ~hl:2:s~cmp RAX, 0
  jne if_true
if_false:
  ~hl:4:s~mov RAX, 7~hl:4:e~
  jmp done
if_true:
  ~hl:3:s~mov RAX, 6~hl:3:e~
done:~hl:2:e~</code></pre></div></div></p></td></tr></table></p><p>The first two follow the structure of the original expression most closely, but
the second has a fatal flaw: once the then-branch finishes executing, control
falls through into the else-branch when it shouldn&rsquo;t.  The third version
flips the condition and the target of the jump, but tracing carefully through
it reveals there is no way for control to reach the else-branch.  Likewise,
tracing carefully through the first and last versions reveal they could both be
valid translations of the original expression.</p><p>Working through these examples should give a reasonable intuition for how to
compile if-expressions more generally: we compile the condition, check whether
it is zero and if so jump to the <span class="emph">else</span> branch and fall through to the
<span class="emph">then</span> branch.  Both branches are then compiled as normal.  The
then-branch, however, needs an unconditional jump to the instruction just after
the end of the else-branch, so that execution dodges the unwanted branch.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Work through the initial examples, and the examples you created
earlier.  Does this strategy work for all of them?</p></blockquote><p>Let&rsquo;s try this strategy on a few examples.  For clarity, we repeat the previous
example below, so that the formatting is more apparent.</p><p><table cellspacing="0" cellpadding="0" class="centered" style="border-collapse: collapse;"><tr><td style="border-bottom: 1px solid black;"><p>Original expression</p></td><td style="border-bottom: 1px solid black;"><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td style="border-bottom: 1px solid black;"><p>Compiled assembly</p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">~hl:2:s~if ~hl:1:s~sub1(1)~hl:1:e~:
  ~hl:3:s~6~hl:3:e~
else:
  ~hl:4:s~7~hl:4:e~~hl:2:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:1:s~mov RAX, 1
  sub1 RAX~hl:1:e~
  ~hl:2:s~cmp RAX, 0
  je if_false
if_true:
  ~hl:3:s~mov RAX, 6~hl:3:e~
  jmp done
if_false:
  ~hl:4:s~mov RAX, 7~hl:4:e~
done:~hl:2:e~</code></pre></div></div></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">~hl:1:s~if ~hl:2:s~10~hl:2:e~:
  ~hl:3:s~2~hl:3:e~
else:
  ~hl:4:s~sub1(0)~hl:4:e~~hl:1:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ~hl:2:s~mov RAX, 10~hl:2:e~
  ~hl:1:s~cmp RAX, 0
  je if_false
if_true:
  ~hl:3:s~mov RAX, 2~hl:3:e~
  jmp done
if_false:
  ~hl:4:s~mov RAX, 0
  sub1 RAX~hl:4:e~
done:~hl:1:e~</code></pre></div></div></p></td></tr><tr><td><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">~hl:1:s~let x =~hl:1:e~ if 10:
          2
        else:
          0
in
~hl:3:s~if ~hl:2:s~x~hl:2:e~:
  ~hl:4:s~55~hl:4:e~
else:
  ~hl:5:s~999~hl:5:e~~hl:3:e~</code></pre></div></div></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  mov RAX, 10
  cmp RAX, 0
  je if_false
if_true:
  mov RAX, 2
  jmp done
if_false:
  mov RAX, 0
done:
  ~hl:1:s~mov [RSP-8], RAX~hl:1:e~
  ~hl:2:s~mov RAX, [RSP-8]~hl:2:e~
  ~hl:3:s~cmp RAX, 0
  je if_false
if_true:
  ~hl:4:s~mov RAX, 55~hl:4:e~
  jmp done
if_false:
  ~hl:5:s~mov RAX, 999~hl:5:e~
done:~hl:3:e~</code></pre></div></div></p></td></tr></table></p><p>The last example is broken: the various labels used in the two if-expressions
are duplicated, which leads to illegal assembly:
<div class="sourceCodeWrapper"><span data-label="Shell" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-sh" class="sourceCode"><code data-lang="text/x-sh" class="sourceCode">$ nasm -f elf64 -o output/test1.o output/test1.s
output/test1.s:20: error: symbol `if_true' redefined
output/test1.s:23: error: symbol `if_false' redefined
output/test1.s:25: error: symbol `done' redefined</code></pre></div></div></p><p>We need to generate <span class="emph">unique</span> labels for each expression.</p><p>TODO: rewrite this based on the approach we end up using.</p></section></section><section class="SsectionLevel2" id="section 3"><h2 class="heading">3<span class="stt">&nbsp;</span><a name="(part._.Intermediate_representation_for_conditionals)"></a>Intermediate representation for conditionals<span class="button-group"><a href="#(part._.Intermediate_representation_for_conditionals)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h2><p><p>To compile our conditionals to x86 conditional jumps and blocks, we
enrich our intermediate representation with blocks and conditional
branching, but without all the complexity of the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span> and
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RFLAGS</code></span> registers. Recall that our current IR consists of a
single block: a sequence of operations that assign to a variable
ending in a return to one of those variables.
We extend this with two new constructors for blocks:
</p><ul><li><p>We add a form for defining a new named block</p></li><li><p>We add a form for <span class="emph">conditional branching</span> where the targets of the branch are previously declared blocks</p></li></ul></p><p>We change the abstract syntax as follows:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">pub struct Program {
    pub param: VarName,
    pub entry: BlockBody,
}
pub enum BlockBody {
    Terminator(Terminator),
    Operation {
        dest: VarName,
        op: Operation,
        next: Box&lt;BlockBody&gt;,
    },
    SubBlock {
        block: BasicBlock,
        next: Box&lt;BlockBody&gt;,
    },
}
pub enum Terminator {
    Return(Immediate),
    ConditionalBranch {
        cond: Immediate,
        thn: Label,
        els: Label,
    },
}
pub enum Operation {
    Immediate(Immediate),
    Prim(Prim, Immediate, Immediate),
}
pub struct BasicBlock {
    pub label: Label,
    pub body: BlockBody,
}</code></pre></div></div></p><p>TODO: Rust</p><p>Whereas before every basic block ended in a <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">return</code></span>, now they may
also end in a conditional <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">br</code></span>. We group these forms together into
what we call a <span class="emph">terminator</span>. So now every block consists of a
sequence of declarations ending in a terminator.</p><p>We will use the following textual format for these:</p><p>TODO: example of sub-blocks.</p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">entry(x):
  thn:
    ret 6
  els:
    ret 7
  sub1_arg = x
  cond = sub sub1_arg 1
  cbr cond thn els</code></pre></div></div></p><p>The semantics of this form is a simplified form of the x86 control
flow. The declaration of a sub-block doesn&rsquo;t have any observable
side-effect, it&rsquo;s simply there as a declaration providing a
<span class="emph">name</span> for the block so that we have the ability to branch to it
later. As with our variable names, we should ensure that the names we
use for blocks are <span class="emph">unique</span> so there is no confusion during code
generation. The semantics of a <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">br x l1 l2</code></span> is analogous to our
<span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> expression: if <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> is non-zero, we start executing the
<span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">l1</code></span> block and otherwise we start executing the <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">l2</code></span> block.</p><section class="SsectionLevel3" id="section 3.1"><h3 class="heading">3.1<span class="stt">&nbsp;</span><a name="(part._.From__sub-_blocks_to_x86)"></a>From (sub-)blocks to x86<span class="button-group"><a href="#(part._.From__sub-_blocks_to_x86)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>We can translate our new IR forms to assembly by turning each named
SSA block into a corresponding region ox x86 code with a <span class="emph">label</span>
corresponding to the declared block name.</p><p>The main difference the IR blocks and labeled assembly code blocks is
that our IR blocks are nested within each other:
<div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">TODO: example nested block</code></pre></div></div>
And we need to ensure when we generate the assembly instructions not to naively put them in the same order:
<div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">TODO</code></pre></div></div>
But instead to produce the code for the sub-blocks either
<span class="emph">before</span> the label of the current block or <span class="emph">after</span> the
compiled code for the terminator of the block:
<div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">TODO</code></pre></div></div></p><p>Then to compile a conditional branch <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">br x l1 l2</code></span>, we need to
check if <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> is non-zero and branch accordingly. For this we can
use the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span> instruction <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x</code></span> and <span title="SSA" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">0</code></span> to set the
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">rflags</code></span> register and then check for the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">e</code></span> condition code:</p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">cbr x l1 l2</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov rax, 0
cmp rax, [rsp - offset(x)] ;; compare 0 to the stored value of rax
je l2
jmp l1</code></pre></div></div></p><p>Of course, we also need to incorporate our new SSA forms into the
existing analyses in our translation. Specifically, we need to extend
our assignment of variables to work with sub-blocks.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Where should we store variables that are declared in a sub-block?</p></blockquote><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">entry:
        mov [rsp + -8], rdi
        mov rax, [rsp + -8]
        mov [rsp + -16], rax
        mov rax, [rsp + -16]
        mov r10, 1
        sub rax, r10
        mov [rsp + -24], rax
        mov rax, [rsp + -24]
        cmp rax, 0
        jne thn#0
        jmp els#1
thn#0:
        mov rax, 6
        ret
els#1:
        mov rax, 7
        ret</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if cond:
  thn
else:
  els</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">thn%uid:
  ... thn code
els%uid':
  ... els code
... cond code
cond_result%uid'' = ...
cbr cond_result%uid'' thn%uid els%uid'</code></pre></div></div></p><p>We also need to account for the <span class="emph">continuation</span> for the current result.</p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">thn%uid:
  ... thn code
  ... continuation code
els%uid':
  ... els code
  ... continuation code
... cond code
cond_result%uid'' = ...
cbr cond_result%uid'' thn%uid els%uid'</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def main(y):
  let x = (if y: 5 else: 6) in
  x * x</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">entry(y%5):
  thn%0:
    x%2 = 5
    res%3 = x%2 * x%2
    ret res%3
  els%1:
    x%4 = 6
    res%3 = x%4 * x%4
    ret res%3
  cbr y%5 thn%0 els%1</code></pre></div></div></p></section><section class="SsectionLevel3" id="section 3.2"><h3 class="heading">3.2<span class="stt">&nbsp;</span><a name="(part._.From_.If_to_.Branching)"></a>From If to Branching<span class="button-group"><a href="#(part._.From_.If_to_.Branching)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h3><p>How do we compile our if expressions to branches?</p><p>Schematically, we want</p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">

</code></pre></div></div></p><p>Looking at a basic example like ... TODO: example where the if is in tail position ... we simply push the return into the blocks of the if.</p><p>But recall that in producing the intermediate code, we also need to
flatten the code, and for this we are given a continuation as an extra
argument.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>In what cases does this compilation strategy go horribly wrong?</p></blockquote></section></section><section class="SsectionLevel2" id="section 4"><h2 class="heading">4<span class="stt">&nbsp;</span><a name="(part._.Join_.Points)"></a>Join Points<span class="button-group"><a href="#(part._.Join_.Points)" class="heading-anchor" title="Link to here">ðŸ”—</a><span style="visibility: hidden"> </span></span></h2><p>If we copy the code for the continuation, we have a problem: each time
a continuation for a conditional is used, its code is produced twice
in the output. But then <span class="emph">that</span> code may itself be used in a
continuation. For example:</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">def main(y):
  let x = if y: 5 else: 6 in
  let x = if y: x else: add1(x) in
  let x = if y: x else: add1(x) in
  x * x</code></pre></div></div></p><p>In our continuation-copying scheme, the continuation containing the
<span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x * x</code></span> computation is copied in the third <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span>, meaning it is
used twice. Then that code constitutes the continuation for the second
<span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span>, so it is copied again, meaning the <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x * x</code></span> is now
included 4 times. This process repeats and now the code for <span title="Boa" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">x *
x</code></span> is included 8 times. This produces some very large SSA even for this simple program:</p><p><div class="sourceCodeWrapper"><span data-label="Boa" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">entry(y%0):
  thn#4():
    x%1 = 5
    thn#2():
      x%2 = x%1
      thn#0():
        x%3 = x%2
        *_0%4 = x%3
        *_1%5 = x%3
        result%6 = *_0%4 * *_1%5
        ret result%6
      els#1():
        add1_0%8 = x%2
        x%3 = add1_0%8 + 1
        *_0%4 = x%3
        *_1%5 = x%3
        result%6 = *_0%4 * *_1%5
        ret result%6
      cond%7 = y%0
      cbr cond%7 thn#0 els#1
    els#3():
      add1_0%10 = x%1
      x%2 = add1_0%10 + 1
      thn#0():
        x%3 = x%2
        *_0%4 = x%3
        *_1%5 = x%3
        result%6 = *_0%4 * *_1%5
        ret result%6
      els#1():
        add1_0%8 = x%2
        x%3 = add1_0%8 + 1
        *_0%4 = x%3
        *_1%5 = x%3
        result%6 = *_0%4 * *_1%5
        ret result%6
      cond%7 = y%0
      cbr cond%7 thn#0 els#1
    cond%9 = y%0
    cbr cond%9 thn#2 els#3
  els#5():
    x%1 = 6
    thn#2():
      x%2 = x%1
      thn#0():
        x%3 = x%2
        *_0%4 = x%3
        *_1%5 = x%3
        result%6 = *_0%4 * *_1%5
        ret result%6
      els#1():
        add1_0%8 = x%2
        x%3 = add1_0%8 + 1
        *_0%4 = x%3
        *_1%5 = x%3
        result%6 = *_0%4 * *_1%5
        ret result%6
      cond%7 = y%0
      cbr cond%7 thn#0 els#1
    els#3():
      add1_0%10 = x%1
      x%2 = add1_0%10 + 1
      thn#0():
        x%3 = x%2
        *_0%4 = x%3
        *_1%5 = x%3
        result%6 = *_0%4 * *_1%5
        ret result%6
      els#1():
        add1_0%8 = x%2
        x%3 = add1_0%8 + 1
        *_0%4 = x%3
        *_1%5 = x%3
        result%6 = *_0%4 * *_1%5
        ret result%6
      cond%7 = y%0
      cbr cond%7 thn#0 els#1
    cond%9 = y%0
    cbr cond%9 thn#2 els#3
  cond%11 = y%0
  cbr cond%11 thn#4 els#5</code></pre></div></div>
And just for a program with 3 sequential conditionals!</p><p>How can we address this? On the one hand, this compilation strategy is
<span class="emph">correct</span>, because the same continuation needs to be used by the
two branches. So what we need to do is to share the continuation
without copying the instructions themselves. We can do this by instead
making some kind of new block for the continuation and then having
each branch of the conditional branch back to this new block. In assembly code we might implement this as</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">entry:
        cmp rdi, 0
        jne thn#0
        jmp els#1
thn#0:
        mov rax, 5
        jmp jn#2
els#1:
        mov rax, 6
        jmp jn#2
jn#2:
        imul rax, rax
        ret</code></pre></div></div></p><p>How could we implement this in our SSA intermediate representation?
We should clearly make this join point a block, and now we want to do
an <span class="emph">unconditional</span> branch to the join point, which is easy enough
to add to our IR:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">entry(y%0):
  jn#2:
    ...?
    result%4 = x%1 * x%1
    ret result%4
  thn#0:
    thn_res%6 = 5
    ...?
    br jn#2
  els#1:
    els_res%7 = 6
    ...?
    br jn#2
  cond%5 = y%0
  cbr cond%5 thn#0 els#1</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">entry(y%0):
  jn#2:
    result%4 = x%1 * x%1
    ret result%4
  thn#0:
    x%1 = 5
    br jn#2
  els#1:
    x%1 = 6
    br jn#2
  cond%5 = y%0
  cbr cond%5 thn#0 els#1</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">entry(y%0):
  jn#2:
    x%1 = &#981;(thn_res%6, els_res%7)
    result%4 = x%1 * x%1
    ret result%4
  thn#0:
    thn_res%6 = 5
    br jn#2
  els#1:
    els_res%7 = 6
    br jn#2
  cond%5 = y%0
  cbr cond%5 thn#0 els#1</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">entry(y%0):
  jn#2(x%1):
    result%4 = x%1 * x%1
    ret result%4
  thn#0():
    br jn#2(5)
  els#1():
    br jn#2(6)
  cond%5 = y%0
  cbr cond%5 thn#0() els#1()</code></pre></div></div>
&#981;ony &#981;unctions: &#981; nodes</p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">l(x1,x2,x3):
  ...
br l(imm1,imm2,imm3)</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov rax, imm1
mov [rsp - offset(x1)], rax
mov rax, imm2
mov [rsp - offset(x2)], rax
mov rax, imm3
mov [rsp - offset(x3)], rax
jmp l</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">l(x1,x2,x3):
  ...
x1 = imm1
x2 = imm2
x3 = imm3
br l</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">cbr x l1 l2</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov rax, [rsp - offset(x)]
cmp rax, 0
jne l1
jmp l2</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">l1(v1,v2):
...
l2(w):
...
cbr x l1(y1,y2) l2(z)</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov rax, [rsp - offset(x)]
cmp rax, 0
mov rax, [rsp - offset(y1)]
mov [rsp - offset(v1)], rax
mov rax, [rsp - offset(y1)]
mov [rsp - offset(v1)], rax
jne l1
mov rax, [rsp - offset(z)]
mov [rsp - offset(w)], rax
jmp l2</code></pre></div></div></p><p>Instead implement as a source-to-source transformation</p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">l1(v1,v2):
...
l2(w):
...
l1b():
  l1(y1,y2)
l2b():
  l2(z)
cbr x l1b l2b</code></pre></div></div></p><p><div class="sourceCodeWrapper"><span data-label="SSA" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-snake" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">jn%uid''(x): ; continuation parameter
  ... continuation code
thn%uid:
  ... thn code
  br jn%uid''(thn_res)
els%uid':
  ... els code
  br jn%uid''(els_res)
... cond code
cond_result%uid'' = ...
cbr cond_result%uid'' thn%uid els%uid'</code></pre></div></div></p></section><section class="SsectionLevel2" id="section 0"><a name="(part._(gentag._2._lecturebranching))"></a><p class="FootnoteBlock"></p></section></section></div></div><div id="contextindicator">&nbsp;</div></body></html>