<!doctype HTML>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta name="viewport" content="width=device-width, initial-scale=0.8"/><title>Lecture 7: Checking for errors and calling Rust functions</title><link rel="stylesheet" type="text/css" href="scribble.css" title="default"/><link rel="stylesheet" type="text/css" href="footnote.css" title="default"/><link rel="stylesheet" type="text/css" href="screen.css" title="default"/><link rel="stylesheet" type="text/css" href="manual-racket.css" title="default"/><script type="text/javascript" src="scribble-common.js"></script><script type="text/javascript" src="manual-racket.js"></script><!--[if IE 6]><style type="text/css">.SIEHidden { overflow: hidden; }</style><![endif]--><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script><script>$.noConflict();</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS"],
  tex2jax: {
    inlineMath: [ ["$","$"], ["\\(","\\)"] ],
    displayMath: [ ["$$","$$"],
                   ["\\[","\\]"],
                   ["\\begin{equation}","\\end{equation}"],
                   ["\\begin{equation*}","\\end{equation*}"] ],
    processEscapes: true
  },
  "HTML-CSS": {
    availableFonts: ["Asana-Math", "STIX", "TeX"],
    webFont: "Asana-Math",
    preferredFont: "Asana-Math",
    imageFont: null,
    mtexFontInherit: true
  }
});</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script src="codemirror.js"></script><script src="runmode.js"></script><script src="scheme.js"></script><script src="mllike.js"></script><script src="rust.js"></script><script src="haskell.js"></script><script src="clike.js"></script><script src="javascript.js"></script><script src="asm86.js"></script><script src="asm64.js"></script><script src="shell.js"></script><script src="python.js"></script><script src="makefile-mode.js"></script><script src="setup-cm.js"></script></head><body id="scribble-racket-lang-org"><div class="tocset"><div class="tocview"><div class="tocviewlist tocviewlisttopspace"><div class="tocviewtitle"><table cellspacing="0" cellpadding="0"><tr><td style="width: 1em;"><a href="javascript:void(0);" title="Expand/Collapse" class="tocviewtoggle" onclick="TocviewToggle(this,&quot;tocview_0&quot;);">&#9658;</a></td><td></td><td><a href="" class="tocviewselflink" data-pltdoc="x"><span class="LectureNum">Lecture 7:</span> Checking for errors and calling Rust functions</a></td></tr></table></div><div class="tocviewsublistonly" style="display: none;" id="tocview_0"><table cellspacing="0" cellpadding="0"><tr><td align="right">1&nbsp;</td><td><a href="#%28part._error-checking._.Checking_for_errors%29" class="tocviewlink" data-pltdoc="x">Checking for errors</a></td></tr><tr><td align="right">2&nbsp;</td><td><a href="#%28part._calling-conventions._.Calling_.Functions%29" class="tocviewlink" data-pltdoc="x">Calling Functions</a></td></tr><tr><td align="right">3&nbsp;</td><td><a href="#%28part._.Putting_the_pieces_together%29" class="tocviewlink" data-pltdoc="x">Putting the pieces together</a></td></tr><tr><td align="right">4&nbsp;</td><td><a href="#%28part._.What_calling_convention_to_use_%29" class="tocviewlink" data-pltdoc="x">What calling convention to use?</a></td></tr><tr><td align="right">5&nbsp;</td><td><a href="#%28part._.Testing%29" class="tocviewlink" data-pltdoc="x">Testing</a></td></tr></table></div></div></div><div class="tocsub"><table class="tocsublist" cellspacing="0"><tr><td><span class="tocsublinknumber"></span><a href="#%28part._%29" class="tocsubseclink" data-pltdoc="x"><span class="LectureNum">Lecture 7:</span> Checking for errors and calling Rust functions</a></td></tr><tr><td><span class="tocsublinknumber">1<tt>&nbsp;</tt></span><a href="#%28part._error-checking._.Checking_for_errors%29" class="tocsubseclink" data-pltdoc="x">Checking for errors</a></td></tr><tr><td><span class="tocsublinknumber">2<tt>&nbsp;</tt></span><a href="#%28part._calling-conventions._.Calling_.Functions%29" class="tocsubseclink" data-pltdoc="x">Calling Functions</a></td></tr><tr><td><span class="tocsublinknumber">2.1<tt>&nbsp;</tt></span><a href="#%28part._calling-conventions._.System_.V_.A.M.D64_.A.B.I%29" class="tocsubseclink" data-pltdoc="x">System V AMD64 ABI</a></td></tr><tr><td><span class="tocsublinknumber">2.2<tt>&nbsp;</tt></span><a href="#%28part._calling-conventions._.Protecting_our_.Local_.Variables%29" class="tocsubseclink" data-pltdoc="x">Protecting our Local Variables</a></td></tr><tr><td><span class="tocsublinknumber">2.3<tt>&nbsp;</tt></span><a href="#%28part._calling-conventions._.Alignment%29" class="tocsubseclink" data-pltdoc="x">Alignment</a></td></tr><tr><td><span class="tocsublinknumber">2.4<tt>&nbsp;</tt></span><a href="#%28part._calling-conventions._.Saving_.Restoring_.Registers%29" class="tocsubseclink" data-pltdoc="x">Saving/<span class="mywbr"> &nbsp;</span>Restoring Registers</a></td></tr><tr><td><span class="tocsublinknumber">3<tt>&nbsp;</tt></span><a href="#%28part._.Putting_the_pieces_together%29" class="tocsubseclink" data-pltdoc="x">Putting the pieces together</a></td></tr><tr><td><span class="tocsublinknumber">4<tt>&nbsp;</tt></span><a href="#%28part._.What_calling_convention_to_use_%29" class="tocsubseclink" data-pltdoc="x">What calling convention to use?</a></td></tr><tr><td><span class="tocsublinknumber">5<tt>&nbsp;</tt></span><a href="#%28part._.Testing%29" class="tocsubseclink" data-pltdoc="x">Testing</a></td></tr></table></div></div><div class="maincolumn"><div class="main"><div class="versionbox"><span class="versionNoNav">8.6</span></div><h2><a name="(part._)"></a><span class="LectureNum">Lecture 7:</span> Checking for errors and calling Rust functions</h2><p>Where we left off last time, we could work with both numbers and
booleans in our program.  Unfortunately, we had no way of ensuring
that we only worked with them <span class="emph">consistently</span>, as opposed to, say,
applying an arithmetic operation to boolean values.  Let&rsquo;s remedy
that. Our intended semantics is that when one of these errors occurs,
(1) an appropriate error message is printed out and (2) the program
should terminate with a non-zero exit code to indicate there was an
error. In order to keep our compiler relatively platform-independent
we will use our Rust runtime in <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">stub.rs</code></span> to implement printing
and exiting (since the Rust compiler developers have conveniently
already implemented the platform-specific details).</p><p>This means when an error happens in our compiled program, we need to
call an appropriate Rust function, and pass it arguments to print an
appropriate error message. So we need to understand what interface we
have to calling Rust functions, what&rsquo;s called a <span class="emph">calling
convention</span>.</p><h3>1<tt>&nbsp;</tt><a name="(part._error-checking._.Checking_for_errors)"></a>Checking for errors</h3><p>Error handling is going to be a pervasive feature in our compiled
output: we need to check the arguments and returned values of every
operation are valid.  That sequenece of checking instructions will
appear at every location in the program that it&rsquo;s needed.  But the
error handling itself is identical everywhere: we want to show some
kind of message that describes the error that occured.  So for
example, we might want to check if a value is a number as follows:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">  ... ;; get RAX to have the value we need
  test RAX, 0x0000000000000001 ;; check only the tag bit of the value
  jnz error_not_number         ;; if the bit is set, go to some centralized error handler

error_not_number:
  ?????</code></pre></div></div></p><p>(The <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">test</code></span> instruction performs a bitwise-and of its two arguments and
discards the result, but sets the zero and signedness flags to be used with
conditional jumps.<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._11._lectureerrors%29%29" data-pltdoc="x">1</a></span></span><span class="FootnoteContent"><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">test</code></span> is to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">and</code></span> the same way <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span> is
to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sub</code></span>: they perform the same logical operation, but throw away the
results and keep only the flags.</span></span>  It&rsquo;s convenient in this case, though for
more complex tag checks, we might need a cleverer sequence of assembly
instructions, possibly involving a second register as a temporary value.)</p><p>What code should we have at the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">error_not_number</code></span> label?  We&rsquo;d like to be
able to be able to print some kind of error message when the arguments to an
operation are invalid.  But our language doesn&rsquo;t have any notion of strings
yet, so we have no way of representing a message, let alone actually printing
it.  Fortunately, we have <code>stub.rs</code> available to us, and Rust <span class="emph">does</span> have
strings and printing.  It&rsquo;s not too hard to define a new function in
<code>stub.rs</code> that achieves the desired goal:</p><p><div class="sourceCodeWrapper"><span data-label="Rust" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-rustsrc" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">type ErrorCode = u64;
static ADD1_ERROR: ErrorCode = 0;
static ADD_ERROR: ErrorCode  = 1;

#[export_name = "\x01snake_error"]
extern "sysv64" fn snake_error(err_code: u64, v: SnakeVal) {
    if err_code == ADD1_ERROR {
        eprintln!("add1 expected a number but got a boolean {}", sprint_snake_val(v));
    } else if err_code == ADD_ERROR {
        eprintln!("+ expected a number but got a boolean {}", sprint_snake_val(v));
    } else {
        eprintln!("I apologize to you, dear user. I made a bug. Here's a snake value: {}", sprint_snake_val(v));
    }
    std::process::exit(1);
}</code></pre></div></div></p><p>Here we have a function that takes in two arguments: an error code
which will be used to decide what the main error message is, and then
another argument with a value related to the error message. Then we
will use <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">std::process:exit</code></span> from the Rust standard library to do
the platform-specific operation of exiting the process with an
appropriate error code.</p><p>Now we need to figure out how to call this function from our compiled
assembly code programs. This is what the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">#[export_name = ...]</code></span>
declaration and <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">extern "sysv64"</code></span> parts are for: the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">extern
"sysv64"</code></span> says to make this function available to code we link with
using the System V AMD64 calling convention, which is the standard x64
calling convention for 64-bit Mac and Linux<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._12._lectureerrors%29%29" data-pltdoc="x">2</a></span></span><span class="FootnoteContent">Previously we used
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">extern "C"</code></span>, which means "use whatever my default C compiler
uses". We&rsquo;ll use "sysv64" from now on to make it clearer that this
doesn&rsquo;t really have anything to do with C, the language</span></span>, and the
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">export_name</code></span> says to make it available under the provided
name. This is the other side of the FFI from what we&rsquo;ve already seen
with the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">start_here</code></span> function: that allowed Rust to call us, and
now we need to understand how to call Rust back.</p><h3>2<tt>&nbsp;</tt><a name="(part._calling-conventions._.Calling_.Functions)"></a>Calling Functions</h3><p>Let&rsquo;s take a step back and think about what it means to call a
function. In high-level languages like Rust, C/C++, Java or Python, we
have some notion of a procedure which includes several different ideas
that are <span class="emph">not</span> present in assembly code:</p><ul><li><p>Procedures can be invoked with different arguments</p></li><li><p>A procedure typically ends by returning some value to its caller</p></li><li><p>Procedures have access to local variables which are private in that other procedure cannot access them</p></li></ul><p>Our machine doesn&rsquo;t work with these primitives, instead these are
high-level abstractions that are a convenient fiction for us
programmers to use. Our assembly code works directly with the following:</p><ul><li><p>Control proceeds to the next instruction unless we use a <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">jmp</code></span> or one of its variant instructions</p></li><li><p>We can store values in a fixed set of registers or somewhere in memory by using pointers, and all code is free to use any registers or access any memory it chooses<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._13._lectureerrors%29%29" data-pltdoc="x">3</a></span></span><span class="FootnoteContent">This is a security nightmare and so in practice we have both software and hardware-level techniques for stopping code from accessing memory it shouldn&rsquo;t, but it&rsquo;s a good first approximation to think about memory this way for the purposes of compilation.</span></span></p></li></ul><p>So we see that one of the big differences is that while in our
high-level languages, functions have some notion of &ldquo;private
variable&rdquo;, in assembly code nothing enforces the distinction between
values belonging to one function or another. In high-level language we
have a kind of notion of private ownership, but in the implementation
we have a global view of the registers and memory as a <span class="emph">shared</span>
resource. So when we implement functions and function calls, we need
to come up with a kind of <span class="emph">protocol</span> for functions to use to
<span class="emph">cooperate</span> with each other so that we don&rsquo;t accidentally
overwrite memory that another function was planning to use. That is,
we need to teach our functions how to <span class="emph">share</span> their resources.</p><p>The other big difference is that in our high-level language, we have
an intrinsic notion of call-and-return, whereas in low-level code we
really only have a single notion of a jump, which we will have to use
to encode our call and return protocol. So when we return in assembly
code, we need to know <span class="emph">where</span> to jump to! This is called the
<span class="emph">return address</span> and it must be stored somewhere that the callee
can access. And when we make a function call with arguments, we need
to communicate somehow what the values of the arguments are. The only
way we can do this is to use our shared resources: the registers and
the stack.</p><p>A <span class="emph">calling convention</span> then, is simply a protocol for how a
caller and a callee can cooperatively use the state of the
machine. The main portions of a calling convention are to specify:</p><ul><li><p>Where is the return address stored?</p></li><li><p>Where are the arguments stored?</p></li><li><p>When the callee returns, where should it store the return value?</p></li><li><p>Which parts of memory is the callee allowed to use?</p></li><li><p>Which registers can the caller expect to be preserved we the call returns?</p></li></ul><p>To understand how to call a Rust function, we need to understand a bit
about the C <span class="emph">calling convention</span>.  The calling convention
describes an agreement between the callers of functions and the callee
functions on where to place arguments and return values so the other
function can find them, and on which function is responsible for
saving any temporary values in registers.</p><p>We&rsquo;ve already encountered one part of the calling convention: &ldquo;the answer goes
in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>.&rdquo;  This simple statement asserts that the callee
places its answer in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>, and the caller should expect to look for the
answer there...which means that the caller should expect the value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>
to change as a result of the call.  If the caller needs to keep the old value
of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>, it is responsible for saving that value before performing the
call: we say this is a <span class="emph">caller-save register</span>.  On the other hand,
functions are allowed to manipulate the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> register to allocate
variables on the stack.  When the function returns, though, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> must be
restored to its value prior to the function invocation, or else the caller will
be hopelessly confused.  We say that <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> is a <span class="emph">callee-save
register</span>.  In general, the calling convention specifies which registers are
caller-save, and which are callee-save, and we must encode those rules into our
compilation as appropriate.</p><h4>2.1<tt>&nbsp;</tt><a name="(part._calling-conventions._.System_.V_.A.M.D64_.A.B.I)"></a>System V AMD64 ABI</h4><p>Here is a simple overview of the most relevant portions of the System
V AMD64 ABI. We will use this whenever we call into Rust functions
from assembly or vice-versa. The full gory details are in the
<a href="https://gitlab.com/x86-psABIs/x86-64-ABI/-/jobs/artifacts/master/raw/x86-64-ABI/abi.pdf?job=build">official
documentation</a>.</p><ul><li><p>(Return Address) Upon entry into the callee, the register <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> will point to the return address.</p></li><li><p>(Stack Alignment) Upon entry into the callee, the value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP + 8</code></span> should be divisible by 16.</p></li><li><p>(Arguments) The first six arguments go in registers <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RDI</code></span>, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSI</code></span>,
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RDX</code></span>, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RCX</code></span>, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R8</code></span>, and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R9</code></span>. Any further arguments are stored at higher addresses than the return address.</p></li><li><p>(Free stack space) Upon entry into the callee, the memory at addresses above <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> is free stack space for the callee, and the memory below this is owned by the caller.</p></li><li><p>(Returning) To return, the callee should pop the return address off the stack (incrementing <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span>) and jumping to it.</p></li><li><p>(Registers) The registers <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span>, <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBX</code></span>, and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R12</code></span> through <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">R15</code></span> are callee-save, all other registers are caller-save.</p></li></ul><p>So when we implement a function that is called using this calling
convention with 9 arguments, the stack will look like this during the
execution:</p><p><p class="center"><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_8.png" alt="image" width="509.5279947916667" height="296.0"/></p></p><p>Arguments 1 through 6 are stored in registers, arguments 7 through 9 are
on the stack, below the return address and we have our locals above
the return address on the stack.  Below the arguments, we have all of
the caller&rsquo;s used memory in the stack. We, the callee, should never
touch this for fear of messing up our caller&rsquo;s local variables.</p><p>So we can make a call using this convention by <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov</code></span>ing the first
6 arguments into the appropriate registers, then <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push</code></span>ing the
remaining arguments onto the stack in reverse order, pushing the
return address and then jumping to the function we want to call.  The
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push</code></span> instruction decrements <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> by one slot, and then
moves its argument into the memory location now pointed to by the new
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> value.  Pictorially,</p><p><table cellspacing="0" cellpadding="0" class="centered"><tr><td><p>Initial</p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push 42</code></span></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push 65</code></span></p></td></tr><tr><td><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_9.png" alt="image" width="253.35026041666669" height="136.0"/></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_10.png" alt="image" width="253.35026041666669" height="136.0"/></p></td><td><p><span class="hspace">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p></td><td><p><img style="vertical-align: -0.0px; margin: -3px -3px -3px -3px;" src="pict_11.png" alt="image" width="253.35026041666669" height="136.0"/></p></td></tr></table></p><p>The final step of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">push</code></span>ing a return address and then jumping
somewhere is so common in calling con ventions that x64 has a built-in
instruction for it: <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span>.  Every instruction exists at some address in
memory, and the currently executing instruction&rsquo;s address is stored in
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span>, the <span class="emph">instruction pointer</span>.  Our assembly code should
never modify this register directly.  Instead, the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span>
instruction first pushes a <span class="emph">return address</span> describing the
location of the next instruction to run &#8212;<wbr></wbr> i.e. the value of
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RIP</code></span> just <span class="emph">after</span> the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span> instruction itself &#8212;<wbr></wbr> and
then jumps to the specified label.</p><p>Putting these instructions together can implement <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">error_not_number</code></span> as follows.</p><p>First we need to declare at the beginning of our generated assembly
that we expect our rust code to define a symbol &lsquo;snake_error&lsquo;</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">section .text
global start_here
extern snake_error</code></pre></div></div></p><p>Then we define a block that calls the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">snake_error</code></span> function.</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">error_not_number:
  mov RSI, RAX   ;; Arg 2: the badly behaved value
  mov RDI, 1     ;; Arg 1: a constant describing which error-code occurred
  call snake_error ;; our error handler</code></pre></div></div></p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>The above has a subtle bug, which may or may not cause a
segfault on your machine(!) What is it? We fix it below.</p></blockquote><h4>2.2<tt>&nbsp;</tt><a name="(part._calling-conventions._.Protecting_our_.Local_.Variables)"></a>Protecting our Local Variables</h4><p>Our <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">snake_error</code></span> function is a bit of a simple case, it never
returns! For the next homework we will implement a function
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">print</code></span> that prints out a snake value to the user. If we try to
do the simple call code above for that, we will run into problems with
our stack! Why? Well when we <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span>, we push the return address
onto the stack and decrement <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span>. But we store our local
variables in the addresses below <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> so this will overwrite our
first local variable. Even worse, the callee, following the calling
convention, will be free to use the remaining addresses below
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> to store <span class="emph">their</span> local variables, meaning potentially
all of our local variables will get overwritten in the process.</p><p>The solution is simple: before we execute the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">call</code></span> instruction,
we need to <span class="emph">decrement</span> <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> so that our local variables will
be safely in "caller space" when the callee is running, and then upon
return, we <span class="emph">increment</span> <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> back to where it was<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._14._lectureerrors%29%29" data-pltdoc="x">4</a></span></span><span class="FootnoteContent">Some
of you may be familiar with alternative implementations where we use
an additional register <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> as the base of our stack frame. This
is only necessary if the stack frame has dynamic size. Since our snake
languages will all have statically bounded frame sizes, we will, like
many modern compilers, only use <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> so that <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> is free to
use as an additional work register.</span></span>.</p><p>So say we have 2 local variables, stored at offsets <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">[RSP - 8]</code></span>
and <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">[RSP - 16]</code></span>, then to call a <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">print</code></span> function that takes
one argument we can do it as follows:</p><p><div class="sourceCodeWrapper"><span data-label="X64 Assembly" class="sourceLangLabel"></span><div class="sourceCode"><pre data-lang="text/x-asm64" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov RDI, arg ;; the argument to be printed
dec RSP, 16  ;; "save" our local variables on the stack
call print
inc RSP, 2 * 8  ;; restore our stack pointer to the base of our stack frame
...</code></pre></div></div></p><h4>2.3<tt>&nbsp;</tt><a name="(part._calling-conventions._.Alignment)"></a>Alignment</h4><p>Depending on your computer, the above code may not work because it
breaks the System V AMD64 calling convention! The reason is the one
part of the calling convention we haven&rsquo;t yet addressed: stack
alignment. Upon entry into the callee, the value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP + 8</code></span>
should be divisible by 16<span class="Footnote"><span class="FootnoteRef"><span style="vertical-align: super; font-size: 80%"><a href="#%28counter-%28%29._%28gentag._15._lectureerrors%29%29" data-pltdoc="x">5</a></span></span><span class="FootnoteContent">The reason this is enforced by the
calling convention is simply to make it more convenient to use
instructions, such as SIMD instructions that require 16-byte
alignment.</span></span>. Since a call instruction pushes a value onto the stack,
and we are always working with 64-bit, i.e., 8 byte values, this means
<span class="emph">before</span> the call instruction the value of <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> should be
divisible by 16. So every time we start executing a function we are
precisely misaligned, and so we need to ensure that when we save our
local variables, we always save an <span class="emph">odd</span> number of 8-byte stack
"slots" to re-align the stack. Our prior examples saved 0 and 2
respectively, so neither correctly implemented the calling
convention. Instead, if we have an even number n of stack slots, we
should round up and push n+1.</p><p>How do we know how many locals we have? Consider how the environment
grows and shrinks as we manipulate an expression: its maximum size
occurs at the <span class="emph">deepest</span> number of nested let-bindinngs.  Surely
we&rsquo;ll never need more locals than that, since we&rsquo;ll never have more
names in scope at once than that!</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Construct a function <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">count_vars</code></span> that computes this quantity.
Work by cases over the AST in sequential form.</p></blockquote><p>This is a safe over-approximation that can be computed before running
your <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">compile_to_instrs</code></span> function, but feel free to do something
smarter for each function call if you want something more
space-efficient.</p><p>If your code ran fine even though it was misaligned, then you may find
that it doesn&rsquo;t work when you submit to gradescope! So if you get
bizarre errors from gradescope you cannot replicate on your machine I
recommend you check your stack alignment first.</p><blockquote class="IncerciseBody"><p class="Incercise">Do Now!</p><p>Draw the sequence of stacks that results from our error-handling
code, using this more precise understanding of what belongs on the stack.</p></blockquote><h4>2.4<tt>&nbsp;</tt><a name="(part._calling-conventions._.Saving_.Restoring_.Registers)"></a>Saving/Restoring Registers</h4><p>For now, we keep all locals on the stack, and all registers are just
used for scratch space. Now that we understand the calling convention
better, we should just make sure we aren&rsquo;t using any of the
callee-save registers as scratch registers. We&rsquo;ll learn more about
saving/restoring registers later in the course when we start using
them for our locals.</p><h3>3<tt>&nbsp;</tt><a name="(part._.Putting_the_pieces_together)"></a>Putting the pieces together</h3><p>Our compiler should now insert type checks, akin to the <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">test</code></span> instruction
with which we started this lecture, everywhere that we need to assert the type
of some value.  We then need to add a label at the end of our compiled output
for each kind of error scenario that we face.  The code at those labels should
<span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">mov</code></span>e the offending value (likely in <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RAX</code></span>) into <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RDI</code></span>, followed
by the error code into <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSI</code></span>, and then call the <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">snake_error</code></span> function in
<code>stub.rs</code>.  That function must be elaborated with a case for each kind of
error we face.</p><p>We will also need to use <span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">count_vars</code></span> or some similar strategy to
correctly adjust our stack before a call, always making sure to align
the stack properly.</p><h3>4<tt>&nbsp;</tt><a name="(part._.What_calling_convention_to_use_)"></a>What calling convention to use?</h3><p>This is our first brush with calling conventions, but it won&rsquo;t be
nearly the last. We used the System V AMD64 calling convention because
that&rsquo;s what the Rust compiler knows how to generate, but that doesn&rsquo;t
mean we need to use it for functions in our source language (as we&rsquo;ll
do soon) that call other functions from the source language.  The
calling convention is just the protocol for a single call, it doesn&rsquo;t
require at all that all of the stack frames on the stack came from the
same calling convention. In fact, we will use a custom calling
convention for our own internal calls, which will be preferable in
certain ways to the System V calling convention.</p><h3>5<tt>&nbsp;</tt><a name="(part._.Testing)"></a>Testing</h3><p>Our programs can now produce observable output!  Granted, it is only complaints
about type mismatches, so far, but even this is useful.</p><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Construct a test program that demonstrates that your type testing
works properly.  Construct a second test program that demonstrates that your
<span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">if</code></span> expressions work properly, too.  Hint: sometimes, &ldquo;no news is good
news.&rdquo;</p></blockquote><blockquote class="ExerciseBody"><p class="Exercise">Exercise</p><p>Enhance your compiler with a new unary primitive, <span title="Cobra" class="sourceCode"><code data-lang="text/x-snake" class="sourceCode">print</code></span>, that
accepts a single argument, prints it to the console, and returns its value.</p></blockquote><a name="(part._(gentag._10._lectureerrors))"></a><p class="FootnoteBlock"><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._11._lectureerrors))"></a>1</span></span><span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">test</code></span> is to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">and</code></span> the same way <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">cmp</code></span> is
to <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">sub</code></span>: they perform the same logical operation, but throw away the
results and keep only the flags.</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._12._lectureerrors))"></a>2</span></span>Previously we used
<span title="Rust" class="sourceCode"><code data-lang="text/x-rustsrc" class="sourceCode">extern "C"</code></span>, which means "use whatever my default C compiler
uses". We&rsquo;ll use "sysv64" from now on to make it clearer that this
doesn&rsquo;t really have anything to do with C, the language</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._13._lectureerrors))"></a>3</span></span>This is a security nightmare and so in practice we have both software and hardware-level techniques for stopping code from accessing memory it shouldn&rsquo;t, but it&rsquo;s a good first approximation to think about memory this way for the purposes of compilation.</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._14._lectureerrors))"></a>4</span></span>Some
of you may be familiar with alternative implementations where we use
an additional register <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> as the base of our stack frame. This
is only necessary if the stack frame has dynamic size. Since our snake
languages will all have statically bounded frame sizes, we will, like
many modern compilers, only use <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RSP</code></span> so that <span title="X64 Assembly" class="sourceCode"><code data-lang="text/x-asm64" class="sourceCode">RBP</code></span> is free to
use as an additional work register.</p></p><p class="FootnoteBlockContent"><p class="FootnoteBlockContent"><span class="FootnoteTarget"><span style="vertical-align: super; font-size: 80%"><a name="(counter-()._(gentag._15._lectureerrors))"></a>5</span></span>The reason this is enforced by the
calling convention is simply to make it more convenient to use
instructions, such as SIMD instructions that require 16-byte
alignment.</p></p></p></div></div><div id="contextindicator">&nbsp;</div></body></html>